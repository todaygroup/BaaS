<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# [https://brunch.co.kr/@ghidesigner/329](https://brunch.co.kr/@ghidesigner/329) 내용을 상세히 심층분석하여 구조에 대한 체계적인 설명을 요청합니다.

이 글은 “Google Opal이라는 도구가 왜 중요한가?”를 중심축으로, 개념 → 기능 → 활용 전략 → 시장 영향 → 한계·미래라는 구조로 짜여 있습니다. 각 층위가 꽤 명확하게 나뉘어 있어서, 구조만 잡아두면 이후 다른 도구/서비스 분석에도 그대로 재사용할 수 있는 패턴입니다.[^1_1][^1_2]

## 1. 글 전체의 상위 구조

글을 큰 덩어리로 나누면 다음과 같은 5단 구조입니다.[^1_2][^1_1]

1) 문제 제기·패러다임 전환 선언

- “코드 없이 아이디어를 현실로”, “소프트웨어 개발 패러다임의 전환” 같은 문장으로 시작해, 기존 개발 방식이 **본질적으로** 바뀌고 있다는 서사를 깝니다.[^1_1]
- 여기서 ‘바이브 코딩’이라는 상위 개념을 제시하고, Opal을 그 대표 사례로 위치시킵니다.[^1_3][^1_1]

2) Google Opal의 핵심 기능 설명

- 자연어 기반 앱 생성
- 시각적 워크플로 편집기
- Gemini·Imagen·Veo·AudioLM 등 멀티모달 모델 연결
- 최근 업데이트(병렬 처리, 고급 디버깅 등)[^1_4][^1_1]
→ “Opal이 뭘 할 수 있는지”를 기능/UX 관점에서 풀어주는 층위입니다.

3) 타깃 독자별 활용 전략 (디자이너·창업가)

- 디자이너: 인터랙티브 프로토타입, UX 플로우 검증, 고급 프로덕트 디자인 자동화 등[^1_1]
- 창업가: 초저비용 MVP, 포트폴리오식 다중 실험, ‘MVP = 일회용 실험’ 관점 전환[^1_5][^1_1]
→ 도구 소개를 ‘사용자 유형별 시나리오’로 번역하는 부분입니다.

4) 시장·생태계 관점에서의 위치와 새로운 기회

- 접근성 향상, 비개발자의 진입, 프롬프트/문제정의 역량의 중요성 상승[^1_6][^1_1]
- 새로운 경제 모델:
    - Opal 컨설턴트
    - 서비스의 제품화(산업별 반복 업무용 미니앱 + 구독)[^1_7][^1_1]
- 기존 노코드/로우코드(버블, Power Apps 등) 대비 포지셔닝:
“AI-First 멀티모달 미니 앱”이라는 틈새에 자리 잡음.[^1_8][^1_1]

5) 현재 한계와 미래 전망

- 한계:
    - Google Labs 실험 프로젝트 → SLA·장기 지속성 불확실
    - 미니앱 중심 → 대규모 엔터프라이즈 기능 부족(보안·거버넌스·확장성)
    - Google 생태계 종속, 타사 모델 미지원[^1_9][^1_1]
- 전망:
    - 다국가 서비스 확장(한국 포함 15개국 등), 커뮤니티 육성
    - Google Workspace와 심층 통합(시트, 지메일 내에서 직접 앱 구성) 가능성[^1_6][^1_1]
→ “지금은 R\&D/프로토타이핑용, 그러나 방향성은 분명하다”라는 결론으로 닫습니다.[^1_1]


## 2. 서론: 개념·담론 레벨의 구조

서론은 도구 기능 설명보다 먼저 “담론 프레이밍”을 합니다.[^1_1]

- ① 패러다임 전환 선언
    - “소프트웨어 개발의 본질이 ‘코드를 쓰는 능력’에서 ‘의도를 명확히 표현하는 능력’으로 이동한다”는 메시지.[^1_10][^1_1]
    - 이때 Opal은 그 전환을 상징하는 대표 사례로 위치합니다.
- ② 바이브 코딩 개념 정의
    - 자연어로 결과물의 분위기/목적(= vibe)을 설명하면, AI가 구현을 대신 처리하는 개발 방식.[^1_11][^1_1]
    - 기존 노코드/로우코드와 구분되는 새로운 레이블로, 독자에게 “새 카테고리”를 인식시키는 역할.
- ③ 타깃 사용자 규정
    - 디자이너, 창업가, 마케터, 교육자 등 ‘비개발자’를 주된 수혜 계층으로 명시.[^1_12][^1_1]
    - 글 전체의 논조가 “비개발자에게 권력을 돌려주는 도구”라는 방향으로 정렬됩니다.

→ 즉, 서론은 “개념 정의(바이브 코딩) → 패러다임 전환 서사 → 대상 사용자 명시”의 구조를 가지며, 기능 설명의 토대를 까는 역할입니다.[^1_1]

## 3. 본문 1: Opal 핵심 기능 블록 구조

기능 파트는 크게 네 가지 축으로 정리되어 있습니다.[^1_6][^1_1]

1) 자연어 → 워크플로 변환

- “자연어를 새로운 명령어 체계”로 채택했다는 표현.[^1_8][^1_1]
- 사용 예시: “특정 주제에 대한 블로그 게시물 앱을 만들어줘” → 구조화된 워크플로 자동 생성.[^1_7][^1_1]
- 포인트:
    - 진입 장벽(코드·API·SDK)을 극적으로 낮춤
    - “아이디어 → 앱” 사이의 인지적 간극을 줄임

2) 시각적 워크플로 편집기

- 노드 기반 다이어그램: 입력, 모델 호출, 도구 사용, 출력 단위로 분해.[^1_13][^1_1]
- 사용자는:
    - 노드 클릭 → 프롬프트 확인·수정
    - 순서 변경, 단계 추가/삭제로 흐름을 재구성
- 추가로, 이는 단순 편집기가 아니라:
    - 프롬프트 엔지니어링 원리를 자연스럽게 학습시키는 **교육** 도구로 역할.[^1_9][^1_1]

3) 멀티모달 모델·도구 연결

- Gemini(추론), Imagen(이미지), Veo(영상), AudioLM(음성) 등 Google 계열 모델을 워크플로에 연결.[^1_14][^1_1]
- 예시 시나리오:
    - 제품 설명 → 광고 스크립트 생성(Gemini)
    - 스크립트 → 영상 생성(Veo)
    - 영상 → 음성 내레이션(AudioLM)
- “복합 AI 작업의 민주화”라는 표현으로, 과거에는 엔지니어링 팀이 필요했던 파이프라인을 1인 제작 가능하게 만들었다고 강조.[^1_6][^1_1]

4) 최신 기능 업데이트(플랫폼화의 시그널)

- 병렬 처리: 여러 단계를 동시에 실행해, 속도·복잡도 둘 다 향상.[^1_4][^1_1]
- 고급 디버깅:
    - 워크플로 단계별 테스트
    - 오류 지점 실시간 표시
→ 실험 도구에서 “신뢰 가능한 프로토타입 제작 도구”로 진화 중이라는 메시지.[^1_4][^1_1]

이 블록은 “사용자 경험(UX) 관점에서 기능을 설명 → 그 기능이 어떤 학습·전환을 촉진하는지까지 연결”하는 구조로 되어 있습니다.[^1_1]

## 4. 본문 2: 타깃별 활용 전략 구조

이 부분은 “Who is this for?”에 대한 해답으로, 디자이너와 창업가를 별도 섹션으로 나눴습니다.[^1_5][^1_1]

### 디자이너 관점 구조

- ① 정적 목업의 한계를 지적
    - Figma, XD처럼 **정적인** 프로토타이핑에서, 실제 인터랙션과 데이터 흐름을 담지 못하는 한계를 짚습니다.[^1_8]
- ② 인터랙티브 프로토타입으로의 확장
    - 특정 기능/사용자 흐름을 “몇 주가 아니라 몇 분” 만에 실행 가능한 형태로 구현 가능.[^1_5][^1_1]
    - 예: 소셜 미디어 포스트 리믹스 미니앱을 만들어 즉시 유효성 검증.
- ③ 교육·훈련용 활용
    - 다양한 AI 도구 + 프롬프트 엔지니어링을 활용해 프로덕트 디자인 과정을 자동화하는 교육/실습 흐름.[^1_1]
    - 결과적으로 더 높은 수준의 UX/UI 설계를 **효율적으로** 수행하게 한다는 논리.[^1_1]


### 창업가·스타트업 관점 구조

- ① “시간·비용” 프레임
    - 과거: MVP 제작에 수만 달러, 수개월 필요
    - Opal: 거의 무료, 몇 시간 내 완성 → 시장 반응 테스트 가능[^1_12][^1_1]
- ② 포트폴리오 기반 혁신
    - 하나의 아이디어에 올인하지 않고, 다수 프로토타입을 동시에 돌려 시장 피드백으로 가설 검증.[^1_7][^1_1]
    - MVP를 “제품”이 아니라 “일회용 실험”으로 보는 관점 전환을 제안.
- ③ 비즈니스 리스크의 구조적 감소
    - 개발자 채용·외주 리스크를 줄이고, 피벗·실험 빈도를 높이는 구조로 설명.[^1_6][^1_1]

이 섹션은 “도구 기능 → 의사결정과 실행 방식이 어떻게 바뀌는가?”까지 내려가는 구조로 짜여 있습니다.[^1_1]

## 5. 본문 3: 시장·생태계·비즈니스 모델 구조

이 부분은 단순 도구 리뷰가 아니라 “생태계 변화” 관점에서 구조화되어 있습니다.[^1_15][^1_1]

1) 개발 접근성의 구조적 변화

- 코딩 능력 → 창의적 문제 해결 능력 + 프롬프트 설계 능력이 핵심 역량으로 이동.[^1_16][^1_1]
- 기술 장벽으로 배제되었던 잠재적 창작자 집단에 기회를 연다는 논지.

2) 새로운 직업군: Opal 컨설턴트

- 타깃: 자동화가 필요하지만 시간·노하우가 부족한 중소기업.[^1_1]
- 수익 구조:
    - 제작·설정에 드는 ‘원가’가 거의 없기 때문에 높은 수익률 구조 설명.[^1_7][^1_1]

3) 서비스의 제품화 모델

- 특정 산업의 반복 업무를 해결하는 Opal 앱을 미리 제작하여 구독형 서비스로 판매.[^1_12][^1_1]
    - 예: 부동산 매물 설명 자동 생성, 식당 메뉴 업데이트 자동화 등.

4) 경쟁 구도에서의 포지셔닝

- 버블(Bubble): 복잡한 SaaS/마켓플레이스 구축에 특화된 웹앱 플랫폼.[^1_8][^1_1]
- Power Apps: MS 365 생태계에 통합된 기업용 내부 프로세스 자동화 도구, 보안·데이터 연결성이 강점.[^1_17][^1_1]
- Opal:
    - AI 중심의 경량 ‘미니 앱’ 제작
    - 본격 사업체 인프라 구축용이 아니라, 창의적 작업 자동화·개인 생산성 향상·AI-First 멀티모달 미니 앱이라는 틈새시장 초점.[^1_6][^1_1]

→ 이 블록은 “사용자 스킬 구조, 직업 구조, 경쟁 지도” 세 레벨을 동시에 다루는 것이 특징입니다.[^1_1]

## 6. 본문 4: 한계와 미래 전망의 논리 구조

이 파트는 ‘하이프’를 걸어놓고 난 뒤, 사용 맥락을 현실적으로 조정하는 안전장치 역할을 합니다.[^1_9][^1_1]

### 현재 한계 구조

1) 실험 프로젝트로서의 태생적 한계

- Google Labs 산하 실험 → 엔터프라이즈급 SLA·전담 지원 부재.[^1_6][^1_1]
- 따라서 권장 활용: 핵심 업무 시스템이 아니라 R\&D·프로토타이핑 도구.

2) 미니 앱 중심 설계

- 확장성, 고급 보안, 거버넌스 등 대규모 엔터프라이즈 시스템에 필요한 요소 부족.[^1_9][^1_1]

3) Google 생태계 의존성

- Gemini 계열 모델 중심, 외부 모델(GPT-4, Claude 등) 미지원 → 유연성 제한.[^1_8][^1_1]


### 미래 전망 구조

1) 글로벌 확장

- 미국 중심 실험에서 한국·일본·인도 등 15개국 확대 → Google의 의지·잠재력 시그널로 해석.[^1_14][^1_1]

2) Workspace와의 심층 통합 시나리오

- 시트, 지메일 등에서 직접 Opal 앱을 구축·실행하는 그림 제시.[^1_13][^1_1]
- Opal을 독립 앱이 아니라 “Google 생산성 도구들의 내장 기능”으로 진화할 수 있다는 전망.

3) 인간–컴퓨터 상호작용 변화

- 소수 개발자가 아니라, **아이디어를 가진 모두**가 혁신의 주체가 되는 미래라는 서사로 귀결.[^1_10][^1_1]

→ 논리 구조상 “한계 → 그래서 지금은 어디까지 써야 하는가 → 그러나 방향은 어디를 향하는가”를 단계적으로 처리합니다.[^1_1]

## 7. 글의 메타 구조(프레이밍 관점)

이 글은 도구 리뷰가 아니라 “담론 설계”에 가깝게 구성되어 있습니다.[^1_1]

- 상단: 패러다임·개념(바이브 코딩, 개발 본질의 이동)
- 중단 1: 기능·UX(자연어, 워크플로, 멀티모달, 디버깅)
- 중단 2: 역할·전략(디자이너·창업가 활용, 교육·MVP·실험 문화)
- 중단 3: 비즈니스·생태계(새 직업, 구독 모델, 경쟁 지도)
- 하단: 리스크·한계·정책적 활용 범위 + 장기적 비전

따라서 이 구조를 그대로 추상화하면, 다른 신기술/도구 분석용 템플릿으로 재사용할 수 있습니다.

- 1단계: “이 도구가 상징하는 패러다임/담론은 무엇인가?”
- 2단계: “구체적으로 어떤 기능과 UX로 그 패러다임을 구현하는가?”
- 3단계: “각 타깃 사용자군에게 어떤 전략적 의미를 가지는가?”
- 4단계: “시장·직업·비즈니스 모델 차원에서 어떤 구조 변화를 촉발하는가?”
- 5단계: “지금 시점의 한계와, 합리적인 활용 범위 + 미래 시나리오는 무엇인가?”

필요하다면 이 틀을 기반으로 “Opal을 활용한 서비스/컨설팅 비즈니스” 기획 구조까지 함께 설계해볼 수 있습니다.
<span style="display:none">[^1_18][^1_19][^1_20]</span>

<div align="center">⁂</div>

[^1_1]: https://brunch.co.kr/@ghidesigner/329

[^1_2]: https://www.nomadterrace.com/articles/구글-opal-ai로-아이디어를-앱으로-만들어보자-ga8d87ks

[^1_3]: https://bookshelf-journey.tistory.com/entry/구글-오팔Google-Opal-활용-상세-가이드-코딩-없이-만드는-AI-미니-앱-혁명

[^1_4]: https://virusart.tistory.com/entry/googleopal

[^1_5]: https://yozm.wishket.com/magazine/detail/3504/

[^1_6]: https://deepfa.ir/en/blog/google-opal-ai-app-builder-no-code-platform

[^1_7]: https://scalevise.com/resources/opal-no-code-ai-app-builder/

[^1_8]: https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880

[^1_9]: https://tilnote.io/en/pages/68e5c6c4411a716bc2e1b2a9

[^1_10]: https://developers.googleblog.com/introducing-opal/

[^1_11]: https://www.youtube.com/watch?v=CZoK424BLrw

[^1_12]: https://edumorning.com/articles/1132

[^1_13]: https://developers.google.com/opal/overview

[^1_14]: https://opal.google

[^1_15]: https://digitalbourgeois.tistory.com/1702

[^1_16]: https://coolenjoy.net/bbs/38/6904370

[^1_17]: https://brunch.co.kr/@hyemin/16

[^1_18]: https://brunch.co.kr/@ghidesigner/298

[^1_19]: https://brunch.co.kr/@ghidesigner/366

[^1_20]: https://www.youtube.com/watch?v=PEkUMlmjzzs


---

# [https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880](https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880)

내용을 제 1원칙 사고로 분해하여 목적과 목표 구조와 절차에 대해서 설명해 줘

이 글 전체를 제1원칙 관점에서 보면, “왜 이 도구가 필요한가 → 이 도구의 본질은 무엇인가 → 누구에게 어떤 가치를 주는가 → 어떻게 써야 하는가 → 시장·미래 속 위치는 무엇인가”를 단계적으로 답하는 구조입니다. 아래에서는 목적(Purpose)–목표(Goals)–구조(Structure)–절차(Procedure)로 분해합니다.[^2_1][^2_2]

***

## 1. 최상위 목적과 핵심 질문

이 글이 풀고자 하는 근본 질문은 한 줄로 정리하면 다음 두 가지입니다.[^2_1]

- “코딩을 모르는 사람이 AI 앱을 직접 만들어도 되는 시대가 진짜 왔는가?”[^2_3][^2_1]
- “그렇다면 Google Opal은 이 변화 속에서 어떤 도구이고, 어디까지 믿고 써도 되는가?”[^2_2][^2_1]

이를 위해 글은 다음 두 가지 **최상위 목적**을 갖습니다.[^2_1]

- 독자가 “Google Opal이 어떤 본질을 가진 도구인지”를 개념·기능·경쟁력 관점에서 이해시키는 것.[^2_4][^2_1]
- 독자가 “나도 이걸로 실제 앱을 만들 수 있겠다”는 심리적·실천적 확신을 얻게 하는 것.[^2_5][^2_1]

***

## 2. 목적을 쪼갠 5가지 핵심 목표

제1원칙으로 목적을 쪼개면, 글은 아래 5개의 하위 목표를 순차적으로 달성하려고 설계되어 있습니다.[^2_3][^2_1]

1) 개념·정체성 명확화

- ‘Opal’이라는 이름의 혼동 요소를 제거하고, “우리가 말하는 Opal이 정확히 무엇인지” 선을 그음.[^2_1]
- 동시에 Opal의 본질을 “말로 만드는 AI 앱(의도 기반 자동화, 바이브 코딩)”으로 정의.[^2_6][^2_1]

2) 기능·역량 이해

- 자연어 기반 생성, 시각적 워크플로 편집, Google AI 통합, 배포·공유, 템플릿·리믹스, 디버깅·병렬 처리 등 기능을 체계적으로 나열.[^2_2][^2_1]
- “Input → AI Task → Output”이라는 단순 구조로 작동 원리를 축약.[^2_1]

3) 타깃과 사용 시나리오 명시

- 이 도구가 ‘누구를 위한 것인지’를 역할별(마케터, 기획자, 교육자, 1인 기업가 등)로 명확히 정의.[^2_7][^2_1]
- 각 역할이 어떤 반복 업무를 어떻게 자동화·프로토타입화할 수 있는지 사례로 보여줌.[^2_1]

4) 경쟁·시장 속 위치 파악

- n8n/Make·Bubble/Adalo·OpenAI Agent Builder 등과 기능·전략 차이를 비교.[^2_4][^2_1]
- SWOT, 시장 성장률(노코드 AI 플랫폼 시장 전망) 등을 통해 구조적 위치를 설명.[^2_8][^2_1]

5) 실행·미래·리스크 의사결정 지원

- Step-by-step 실전 튜토리얼로 “오늘 당장 어떻게 시작할지”를 안내.[^2_5][^2_1]
- 타임라인, 시장 트렌드, 미래 통합 시나리오, 한계·리스크(실험 단계, 섀도우 IT, 복잡 로직 한계)를 제시해 장기적 활용 범위를 제안.[^2_2][^2_1]

***

## 3. 구조: 상위에서 하위로 내려가는 논리 설계

글의 목차는 이 목표들을 계층 구조로 배치한 것에 가깝습니다.[^2_1]

### 3.1 1층: 프레이밍과 개념 정리

- 서론: “AI 앱 제작의 새로운 시대”라는 맥락 설정 → 시민 개발자, 코딩 장벽 붕괴라는 시대 서사.[^2_3][^2_1]
- “당신이 찾는 Opal이 맞나요?”:
    - 여러 Opal 브랜드(Opal Security, OpalAI, Opal.so, Optimizely Opal)를 구분
    - 표로 “이 글의 대상 = Google Labs의 노코드 AI 미니 앱 빌더”라고 못 박음.[^2_1]

→ 제1원칙상 “우리가 이야기하는 대상이 정확히 무엇인지부터 정의한다”는 첫 단계입니다.

### 3.2 2층: 본질과 기능(What \& How)

- “Opal의 본질: 말로 만드는 AI 앱”:
    - 본질을 “아이디어를 말하면 AI가 앱 설계도로 번역해주는 번역기”로 정의.[^2_2][^2_1]
    - 바이브 코딩·의도 기반 자동화라는 상위 개념과 연결.
- “핵심 기능 상세 분석”:
    - 자연어 기반 생성
    - 시각적 워크플로 편집
    - Google 모델 통합(Gemini, Imagen, Veo 등)
    - 공유·배포
    - 템플릿/리믹스
    - 디버깅·병렬 실행
→ “도구가 실제로 할 수 있는 일”을 하나의 카테고리로 정리.[^2_9][^2_1]


### 3.3 3층: 사용자·경쟁·시장(Who \& Compared to What)

- “누구를 위한 도구인가?”: 타깃 오디언스를 역할·업무 기준으로 분류.[^2_1]
- “경쟁 구도 분석, 심층 비교”:
    - 카테고리: AI 워크플로 자동화 vs 노코드 앱 빌더
    - 경쟁 도구별 차이(n8n/Make, Bubble/Adalo, OpenAI Agent Builder).
    - Opal의 AI-native, 의도 기반 접근을 차별점으로 강조.[^2_4][^2_1]
- SWOT에서 Strength/Weakness/Opportunity/Threat를 한 번에 구조화.[^2_1]


### 3.4 4층: 실행 절차(How to Use)

- “실전 가이드: Step-by-Step”:
    - 준비물: Google 계정, 2025년 10월 이후 한국 사용 가능.[^2_2][^2_1]
    - 시작경로 2가지: 템플릿 리믹스 vs 처음부터 만들기.[^2_1]
- 실전 예제 1: 독서 추천 챗봇(템플릿 기반)
- 실전 예제 2: 블로그 포스팅 자동화(From Scratch)
→ 실제 워크플로 노드 구조와 프롬프트 설계까지 보여주며 “추상 → 구체”를 연결.[^2_5][^2_1]


### 3.5 5층: 타임라인·시장·미래·한계(When \& So What)

- 타임라인: 2025년 7월 공개 → 9월 첫 대규모 업데이트 → 10월 15개국 확장 → 커뮤니티 피드백 기반 진화.[^2_2][^2_1]
- 노코드 AI 시장 규모·CAGR 제시로 “Opal이 속한 큰 흐름” 설명.[^2_8][^2_1]
- 미래 시나리오:
    - Workspace 완전 통합
    - API·외부 연동 확장
    - 앱 마켓플레이스
    - 엔터프라이즈 기능 강화.[^2_2][^2_1]
- 한계·과제:
    - 실험 딱지, 플랫폼 안정성
    - 데이터 보안·섀도우 IT
    - 복잡 로직·에러 핸들링 한계.[^2_2][^2_1]
- 결론에서 “코딩이 아닌 문제 정의·프롬프트·비판적 검토 역량이 더 중요해지는 시대”라는 메시지로 다시 1층의 철학과 연결.[^2_1]

***

## 4. 절차: 독자가 따라가게 되는 사고·행동 플로우

이 글이 독자에게 강제하는 “사고와 행동의 순서”는 다음과 같이 정리됩니다.[^2_1]

1) 인식 전환

- “코딩 = 전제 조건”이라는 기존 믿음을 흔들고, 시민 개발자 개념을 주입.[^2_3][^2_1]

2) 대상 식별

- 여러 Opal 중 ‘Google Opal’을 정확히 식별하도록 유도.[^2_1]

3) 본질 이해

- Opal을 “말로 앱을 만드는 AI 번역기” + “Input–AI Task–Output 구조의 워크플로 엔진”으로 이해하게 함.[^2_6][^2_1]

4) 도구의 한계·역량 범위 설정

- “이 도구가 잘하는 일/못하는 일”을 기능·경쟁 비교·SWOT을 통해 인지하게 함.[^2_2][^2_1]

5) 자기포지셔닝

- “내가 마케터/기획자/교육자/1인 기업가라면 어떤 문제를 해결할 수 있는가?”를 상상하도록 타깃별 예시 제시.[^2_7][^2_1]

6) 첫 실천 행동 유도

- Opal 접속 → 템플릿 리믹스 또는 From Scratch 선택 → 간단 앱 하나 만들어보기.[^2_5][^2_1]

7) 전략적 판단

- 노코드 AI 시장 성장, Opal의 미래·한계 정보를 보고, “R\&D·프로토타입 용도로 도입할지, 핵심 시스템에는 보류할지”를 판단하도록 돕는 구조.[^2_8][^2_1]

8) 역량 프레임 전환

- 마지막으로 “How보다 What이 중요해지는 시대”라는 메시지로, 독자의 개인 역량 개발 방향(문제 정의·프롬프트·비판적 검토)을 재정렬.[^2_1]

***

## 5. 이 구조를 그대로 재사용하는 프레임

이 글의 구조는 다른 AI/노코드 도구 분석에도 그대로 적용 가능한 **제1원칙 템플릿**으로 요약할 수 있습니다.[^2_3][^2_1]

1) 대상 정체성 명확화: 같은 이름/유사 카테고리 도구들과 구분
2) 본질 정의: “이 도구가 궁극적으로 하는 일”을 한 문장·한 구조로 요약
3) 기능 Deep-Dive: Input–Process–Output 관점으로 핵심 기능 나열
4) 타깃·사용 시나리오: 역할별로 해결하는 반복 문제를 매핑
5) 경쟁·SWOT·시장: 다른 도구 대비 위치와 전략적 장단점
6) Step-by-step 실전: 최소 1~2개의 구체적인 워크플로 예제
7) 타임라인·트렌드: 언제, 왜, 어떤 흐름 속에서 나왔는지
8) 미래·한계·리스크: 지금은 어디까지 쓰고, 무엇을 기다려야 하는지
9) 메시지: 이 도구가 “일하는 방식/역량 구조”에 던지는 의미 정리

원하시면, 이 Skywork 글 구조를 그대로 차용해서 “당신 버전의 Opal 완전 가이드 아웃라인”으로 재정렬해 드릴 수 있습니다.
<span style="display:none">[^2_10][^2_11][^2_12][^2_13][^2_14][^2_15][^2_16][^2_17][^2_18][^2_19][^2_20][^2_21]</span>

<div align="center">⁂</div>

[^2_1]: https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880

[^2_2]: https://metatour.net/google-opal-ai/

[^2_3]: https://tilnote.io/en/pages/68e5c6c4411a716bc2e1b2a9

[^2_4]: https://www.youtube.com/watch?v=SrPWhiZhwV4

[^2_5]: https://jayaiissue.com/entry/구글-오팔-사용법-완벽-가이드-코딩-없이-AI-앱-10분-만에-만드는-법

[^2_6]: https://nine-ai.tistory.com/33

[^2_7]: https://tilnote.io/pages/68a2e846d3a1e2a5e2434dbe

[^2_8]: https://www.futuremarketinsights.com/reports/no-code-ai-platform-market

[^2_9]: https://opal.google

[^2_10]: https://www.youtube.com/watch?v=u4QZf7PB5C4

[^2_11]: https://skywork.ai/skypage/ko/ai-assist-works-productivity/1983793798761779200

[^2_12]: https://ailab.aiblueocean.com/2025/08/google-opal.html

[^2_13]: https://www.marketresearchfuture.com/reports/no-code-ai-platform-market-11647

[^2_14]: https://www.youtube.com/watch?v=J2-utZUP-Ig

[^2_15]: https://www.fortunebusinessinsights.com/no-code-ai-platform-market-110382

[^2_16]: https://tilnote.io/pages/68879d2bc4bf40599c6dab10

[^2_17]: https://straitsresearch.com/report/no-code-ai-platform-market

[^2_18]: https://bookshelf-journey.tistory.com/entry/구글-오팔Google-Opal-한국-출시-완벽-가이드

[^2_19]: https://brunch.co.kr/@@3jds/91

[^2_20]: https://www.futuremarketinsights.com/reports/ai-platform-market

[^2_21]: https://bookshelf-journey.tistory.com/entry/구글-오팔Google-Opal-활용-상세-가이드-코딩-없이-만드는-AI-미니-앱-혁명


---

# 핵심 가정들을 제1원칙으로 분해한 목록 요청

이 Skywork Opal 글이 전제하고 있는 핵심 가정을 제1원칙 단위로 최대한 쪼개면, 대략 다음과 같은 리스트로 정리할 수 있습니다.[^3_1][^3_2]

***

## 1. 사용자·역량 관련 가정

1. 대부분의 잠재적 창작자는 코딩 역량이 없다.[^3_2]
2. 비개발자도 “앱으로 만들고 싶은 아이디어”는 충분히 가지고 있다.[^3_2]
3. 이들은 복잡한 UI·설정보다 자연어 대화를 더 쉽게 받아들인다.[^3_3][^3_2]
4. 자연어로 자신의 의도·요구사항을 어느 정도 명확하게 표현할 수 있다.[^3_4][^3_2]
5. 프롬프트를 다듬는 과정에서 “문제 정의 능력”이 점진적으로 향상될 수 있다.[^3_2]
6. 템플릿을 수정해보는 경험은 “학습 곡선”을 크게 낮춰준다.[^3_2]
7. 시민 개발자(Citizen Developer)는 앞으로 계속 늘어날 사용자 세그먼트다.[^3_5][^3_2]

***

## 2. 기술·도구 관련 가정

8. 자연어 → 실행 가능한 워크플로로의 자동 변환이 충분히 신뢰 가능한 수준이다.[^3_3][^3_2]
9. `Input → AI Task → Output` 구조만으로도 상당수 실무용 미니 앱이 커버된다.[^3_1][^3_2]
10. 노드 기반 시각적 편집만으로도 비개발자가 앱 로직을 이해·수정할 수 있다.[^3_2]
11. Google의 모델(Gemini, Imagen, Veo 등)을 “기본 세트”로 쓰는 것만으로도 대부분의 AI 활용 니즈를 충족할 수 있다.[^3_3][^3_2]
12. 별도 서버·호스팅 없이 URL 공유만으로도 많은 사용 사례가 해결된다.[^3_5][^3_2]
13. 브라우저 기반 UI와 Google 계정 로그인은 전 세계적으로 충분히 보편적이다.[^3_3][^3_2]
14. 시각적 디버깅·병렬 실행 정도의 기능이면 “실험 도구 이상의 신뢰성”을 줄 수 있다.[^3_4][^3_2]

***

## 3. 비즈니스·시장 관련 가정

15. 노코드 AI 플랫폼 시장은 향후 10년 이상 고성장(CAGR 20~30%대)할 것이다.[^3_6][^3_2]
16. 기업들은 개발자 리소스 부족으로 노코드·로우코드를 적극 채택할 수밖에 없다.[^3_7][^3_2]
17. 중소기업·Tier3 기업은 특히 저비용·고속 프로토타입 도구에 대한 수요가 크다.[^3_6][^3_2]
18. “Opal 컨설턴트”와 같은 새로운 직업군을 지탱할 만큼 수요가 생길 것이다.[^3_5][^3_2]
19. 특정 산업의 반복 업무를 해결하는 미니 앱은 구독형 제품으로서 지불 의사가 존재한다.[^3_7][^3_2]
20. 앱 마켓플레이스가 만들어지면, 사용자 간 앱 거래·공유가 활발히 일어날 것이다.[^3_5][^3_2]

***

## 4. 전략·포지셔닝 관련 가정

21. AI-네이티브(의도 기반) 방식은 기존 “수동 로직 연결형” 워크플로 도구와 뚜렷이 구분된다.[^3_1][^3_2]
22. “말로 만든다”는 UX는 n8n/Make/Bubble/Adalo 대비 명확한 경쟁 우위다.[^3_8][^3_2]
23. Opal은 엔터프라이즈 코어 시스템이 아니라 미니 앱·프로토타입 영역에 집중하는 것이 합리적이다.[^3_9][^3_2]
24. Google Workspace와의 깊은 통합은 장기적으로 큰 네트워크 효과를 만든다.[^3_3][^3_2]
25. API·외부 연동이 추가되면 Opal은 기존 워크플로 도구의 직접 경쟁자가 될 수 있다.[^3_5][^3_2]

***

## 5. 리스크·한계 관련 가정

26. “Google Labs 실험”이라는 상태는 기업 도입 시 신뢰성 리스크로 작용한다.[^3_4][^3_2]
27. 현재 수준의 보안·거버넌스 기능으로는 핵심 엔터프라이즈 업무에 쓰기 어렵다.[^3_9][^3_2]
28. 너무 쉬운 노코드 도구는 섀도우 IT와 데이터 유출 리스크를 키울 수 있다.[^3_10][^3_2]
29. 복잡한 조건·반복·에러 핸들링이 필요한 워크플로는 여전히 전통적 개발이 유리하다.[^3_9][^3_2]
30. 베타·실험 단계인 이상, 가격·기능·지속성은 향후 변동 가능성을 전제로 봐야 한다.[^3_4][^3_2]

***

## 6. 인간·역량 구조에 대한 근본 가정

31. 소프트웨어 개발의 본질은 “코드 작성”이 아니라 “문제 정의와 의도 표현” 쪽으로 이동 중이다.[^3_11][^3_2]
32. 코딩 스킬보다 “무엇을 만들 것인가”를 정의하고 AI에게 정확히 지시하는 능력이 더 중요해질 것이다.[^3_12][^3_2]
33. AI 도구는 인간의 창의성을 대체하기보다 “아이디어 구현 속도를 극적으로 높이는 촉매” 역할을 한다.[^3_5][^3_2]
34. 따라서 Opal 같은 도구의 가치는 “기능 자체”보다 “누가 어떤 문제를 어떻게 정의하느냐”에 달려 있다.[^3_1][^3_2]

이 리스트는 Skywork 글이 전개되는 논리 뒤에 깔린 숨은 전제들을 “인간/기술/시장/전략/리스크/역량” 축으로 쪼갠 것입니다. 필요하면 각 가정이 깨졌을 때 어떤 전략·설계가 달라져야 하는지도 이어서 정리해 줄 수 있습니다.[^3_1][^3_2]
<span style="display:none">[^3_13][^3_14][^3_15][^3_16][^3_17][^3_18][^3_19][^3_20][^3_21]</span>

<div align="center">⁂</div>

[^3_1]: https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880

[^3_2]: https://developers.google.com/opal

[^3_3]: https://developers.googleblog.com/ko/introducing-opal/

[^3_4]: https://www.aitechsuite.com/ai-news/google-expands-no-code-ai-tool-opal-globally-democratizing-app-creation

[^3_5]: https://www.futuremarketinsights.com/reports/no-code-ai-platform-market

[^3_6]: https://finance.yahoo.com/news/no-code-ai-platforms-market-143000513.html

[^3_7]: https://www.youtube.com/watch?v=SrPWhiZhwV4

[^3_8]: https://discuss.pytorch.kr/t/opal-google-ai-feat-no-code/7662

[^3_9]: https://newsroom.technavio.org/no-code-ai-platform-market

[^3_10]: https://tilnote.io/en/pages/68e5c6c4411a716bc2e1b2a9

[^3_11]: https://deepsense.in/google-opal-no-code-ai-vs-chatgpt/

[^3_12]: https://skywork.ai/skypage/ko/list/11-02-2025

[^3_13]: https://ai.kqwer.com/2025/09/blog-post_28.html

[^3_14]: https://jayaiissue.com/entry/구글-오팔-사용법-완벽-가이드-코딩-없이-AI-앱-10분-만에-만드는-법

[^3_15]: https://jeondase.tistory.com/318

[^3_16]: https://creator4257.tistory.com/entry/Skywork-AI-완벽-가이드-2025년-기업-혁신의-핵심

[^3_17]: https://kr.linkedin.com/pulse/no-code-ai-오케스트레이션-google-opal기술-백서-whitepaper-keonwoo-park-6o9qc

[^3_18]: https://www.researchandmarkets.com/reports/5948653/no-code-artificial-intelligence-ai-platform

[^3_19]: https://jeondase.com/318

[^3_20]: https://blog.naver.com/techref/224002795701

[^3_21]: https://www.fortunebusinessinsights.com/no-code-ai-platform-market-110382


---

# 목적과 하위 목표를 트리 구조로 도식화해줘

최상위 목적 1개 아래에 하위 목표들이 단계적으로 내려가는 형태로, 텍스트 트리로 도식화하겠습니다.[^4_1][^4_2]

***

## 목적–목표 트리 구조

**[최상위 목적]**
Opal을 통해 “코딩 없이도 누구나 AI 앱을 만들 수 있는 시대”를 이해하고, 실제로 활용할 수 있게 한다.[^4_2][^4_1]

- 1단계 목표: Opal이 정확히 무엇인지 혼동 없이 정의한다.[^4_1][^4_2]
    - 1-1. ‘Opal’이라는 이름을 쓰는 다른 서비스들과 구분한다 (Opal Security, OpalAI, Opal.so 등).[^4_2]
    - 1-2. 이 글에서 말하는 대상은 “Google Labs의 노코드 AI 미니 앱 빌더”임을 명시한다.[^4_3][^4_2]
    - 1-3. Opal의 본질을 “말로 만드는 AI 앱(의도 기반 자동화, 바이브 코딩)”으로 한 문장 정의한다.[^4_4][^4_2]
- 2단계 목표: Opal의 작동 원리와 핵심 기능을 구조적으로 이해시킨다.[^4_1][^4_2]
    - 2-1. 기본 작동 구조를 `Input → AI Task → Output` 3단계로 설명한다.[^4_2]
    - 2-2. 자연어 기반 앱 생성 기능을 사례(예시 프롬프트)와 함께 설명한다.[^4_2]
    - 2-3. 시각적 워크플로 편집기(노드 구조, 드래그\&드롭, 프롬프트 수정)를 설명한다.[^4_5][^4_2]
    - 2-4. Gemini·Imagen·Veo 등 Google AI 모델 통합 방식을 설명한다.[^4_6][^4_2]
    - 2-5. 공유·배포(링크 공유), 템플릿·리믹스, 디버깅·병렬 실행 등의 보조 기능을 정리한다.[^4_1][^4_2]
- 3단계 목표: “누가, 무엇을 위해” 이 도구를 쓰는지 맥락을 만든다.[^4_1][^4_2]
    - 3-1. 핵심 타깃을 시민 개발자(Citizen Developer)로 정의한다.[^4_2]
    - 3-2. 마케터·기획자/PM·교육자·1인 기업가 등 역할별 주요 활용 목적을 제시한다.[^4_7][^4_2]
    - 3-3. 각 역할이 해결할 수 있는 반복 업무·프로토타이핑 니즈를 예시로 보여준다.[^4_8][^4_2]
- 4단계 목표: 경쟁 도구·시장 속에서 Opal의 위치와 전략적 의미를 파악하게 한다.[^4_1][^4_2]
    - 4-1. Opal이 속한 두 시장 축을 정의한다:
        - AI 워크플로 자동화
        - 노코드 앱 빌더.[^4_2]
    - 4-2. n8n / Make.com / Bubble / Adalo / OpenAI Agent Builder와의 차이를 기능·접근 방식으로 비교한다.[^4_9][^4_2]
    - 4-3. Opal의 AI-native·의도 기반 생성이라는 차별 포인트를 명확히 한다.[^4_7][^4_2]
    - 4-4. SWOT 분석으로 강점·약점·기회·위협을 요약한다.[^4_9][^4_2]
    - 4-5. 노코드 AI 시장 성장 데이터(CAGR, 시장 규모)를 통해 “이 카테고리의 성장성”을 보여준다.[^4_10][^4_2]
- 5단계 목표: 독자가 실제로 Opal을 사용해 첫 앱을 만들어보게 한다.[^4_11][^4_2]
    - 5-1. 시작 전 준비물(구글 계정, 지역 지원 상황)을 안내한다.[^4_12][^4_2]
    - 5-2. 시작 경로 두 가지(템플릿 리믹스 vs From Scratch)를 제시한다.[^4_2]
    - 5-3. 실전 예제 1: 독서 추천 챗봇 템플릿 리믹스 절차(노드 이해, 프롬프트 수정, 테스트, 공유)를 단계별로 보여준다.[^4_2]
    - 5-4. 실전 예제 2: 블로그 포스팅 자동화 앱을 처음부터 만드는 절차(프롬프트 정의, 워크플로 검토·수정, 모델 선택)를 제시한다.[^4_1][^4_2]
    - 5-5. 노드별 설정 예시 표로, “어떤 단계에 어떤 모델·프롬프트를 쓰는지”까지 구체화한다.[^4_2]
- 6단계 목표: Opal의 현재 위치와 향후 진화 방향, 리스크를 입체적으로 이해시킨다.[^4_1][^4_2]
    - 6-1. 타임라인(출시–업데이트–글로벌 확장–커뮤니티 피드백)을 정리한다.[^4_12][^4_2]
    - 6-2. 노코드 AI 시장 트렌드(성장률, 사용자 분포, 지역별 특징)를 요약한다.[^4_10][^4_2]
    - 6-3. 미래 시나리오(Workspace 완전 통합, API·외부 연동, 앱 마켓플레이스, 엔터프라이즈 기능 강화)를 제시한다.[^4_6][^4_2]
    - 6-4. 현재 한계·과제(실험 딱지, 안정성, 보안·섀도우 IT, 복잡 로직 한계)를 명확히 짚는다.[^4_5][^4_2]
    - 6-5. “지금은 어디까지, 무엇에 써야 하는가(R\&D·프로토타이핑 중심)”라는 실질적 활용 범위를 제안한다.[^4_13][^4_2]
- 7단계 목표: 개인·조직 역량 관점에서 Opal이 던지는 메시지를 정리한다.[^4_14][^4_2]
    - 7-1. 개발의 중심이 ‘코드(How)’에서 ‘문제 정의와 의도 표현(What)’으로 이동했다는 점을 강조한다.[^4_4][^4_2]
    - 7-2. 비개발자에게는 “생산성·자동화의 날개”, 개발자에게는 “최고의 프로토타이핑 도구”라는 역할 분담을 제시한다.[^4_2]
    - 7-3. “Opal은 AI 시대의 스케치북”이라는 은유로, 작은 아이디어라도 바로 실험해보라는 행동 메시지로 마무리한다.[^4_2]

이 트리를 그대로 가져가면, 다른 AI/노코드 도구 리뷰를 설계할 때도 “최상위 목적 → 7개 정도의 하위 목표 → 각 목표별 세부 목적” 구조로 재사용할 수 있습니다.[^4_4][^4_2]
<span style="display:none">[^4_15][^4_16][^4_17][^4_18][^4_19][^4_20][^4_21]</span>

<div align="center">⁂</div>

[^4_1]: https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880

[^4_2]: https://developers.googleblog.com/ko/introducing-opal/

[^4_3]: https://tilnote.io/pages/68e5c6c4411a716bc2e1b2a9

[^4_4]: https://www.datacamp.com/tutorial/google-opal-tutorial

[^4_5]: https://developers.google.com/opal

[^4_6]: https://nine-ai.tistory.com/33

[^4_7]: https://insight.infograb.net/blog/2025/10/15/google-opal-review/

[^4_8]: https://www.youtube.com/watch?v=SrPWhiZhwV4

[^4_9]: https://www.futuremarketinsights.com/reports/no-code-ai-platform-market

[^4_10]: https://jayaiissue.com/entry/구글-오팔-사용법-완벽-가이드-코딩-없이-AI-앱-10분-만에-만드는-법

[^4_11]: https://www.aitechsuite.com/ai-news/google-expands-no-code-ai-tool-opal-globally-democratizing-app-creation

[^4_12]: https://discuss.pytorch.kr/t/opal-google-ai-feat-no-code/7662

[^4_13]: https://tilnote.io/en/pages/68e5c6c4411a716bc2e1b2a9

[^4_14]: https://skywork.ai/skypage/ko/ai-research-assistant/1982630074659213312

[^4_15]: https://brunch.co.kr/@ghidesigner/366

[^4_16]: https://skywork.ai/skypage/en/Anything-AI-App-Builder:-A-Deep-Dive-into-Creating-Apps-with-createanything/1972901710979461120

[^4_17]: https://www.youtube.com/watch?v=u4QZf7PB5C4

[^4_18]: https://bookshelf-journey.tistory.com/entry/구글-오팔Google-Opal-활용-상세-가이드-코딩-없이-만드는-AI-미니-앱-혁명

[^4_19]: https://www.youtube.com/watch?v=PEkUMlmjzzs

[^4_20]: https://okgood0412.tistory.com/322

[^4_21]: https://skywork.ai/skypage/ko/ganttchart-ai-project-planning/1983061966184382464


---

# 트리 구조를 간단한 텍스트 다이어그램으로 만들어줘

**[최상위 목적]**
Opal로 “코딩 없이 누구나 AI 앱을 만들고 이해하게 한다”[^5_1][^5_2]

├─ 1. Opal 정체성 명확화[^5_1]
│  ├─ 1-1. 다른 ‘Opal’ 서비스들과 구분
│  ├─ 1-2. 대상이 Google Labs 노코드 AI 미니 앱임을 명시
│  └─ 1-3. “말로 만드는 AI 앱”이라는 본질 정의

├─ 2. 작동 원리·기능 이해[^5_3][^5_1]
│  ├─ 2-1. Input → AI Task → Output 구조 설명
│  ├─ 2-2. 자연어 기반 앱 생성 소개
│  ├─ 2-3. 시각적 워크플로(노드) 편집 설명
│  ├─ 2-4. Gemini·Imagen·Veo 통합 방식 설명
│  └─ 2-5. 공유·템플릿·디버깅·병렬 실행 기능 정리

├─ 3. 타깃과 사용 맥락 정의[^5_1]
│  ├─ 3-1. 시민 개발자라는 핵심 타깃 규정
│  ├─ 3-2. 마케터·기획자·교육자·1인 기업가 등 역할 제시
│  └─ 3-3. 역할별 반복 업무/프로토타입 활용 예시

├─ 4. 경쟁·시장 속 위치 파악[^5_4][^5_1]
│  ├─ 4-1. “AI 워크플로 자동화 / 노코드 앱 빌더” 이중 시장 규정
│  ├─ 4-2. n8n·Make·Bubble·Adalo·Agent Builder와 비교
│  ├─ 4-3. AI-native·의도 기반 생성 차별점 강조
│  ├─ 4-4. SWOT 분석으로 전략적 위치 요약
│  └─ 4-5. 노코드 AI 시장 성장 데이터 제시

├─ 5. 실제 사용·첫 앱 제작 유도[^5_5][^5_1]
│  ├─ 5-1. 준비물 및 사용 가능 지역 안내
│  ├─ 5-2. 시작 경로: 템플릿 리믹스 vs From Scratch
│  ├─ 5-3. 예제 1: 독서 추천 챗봇 제작 절차
│  ├─ 5-4. 예제 2: 블로그 자동화 앱 제작 절차
│  └─ 5-5. 노드별 모델·프롬프트 설정 예시 제시

├─ 6. 여정·미래·리스크 이해[^5_6][^5_1]
│  ├─ 6-1. 출시–업데이트–글로벌 확장 타임라인
│  ├─ 6-2. 노코드 AI 시장 트렌드·사용자 분포 설명
│  ├─ 6-3. Workspace 통합·API·마켓플레이스·엔터프라이즈 시나리오
│  ├─ 6-4. 실험 상태, 보안, 섀도우 IT, 로직 한계 등 과제
│  └─ 6-5. “R\&D·프로토타입 중심 활용” 권장 범위 제시

└─ 7. 역량·메시지 정리[^5_7][^5_1]
   ├─ 7-1. 코드(How)보다 문제 정의·의도표현(What)의 중요성 강조
   ├─ 7-2. 비개발자=자동화 도구 제작자 / 개발자=프로토타입 가속기 역할 구분
   └─ 7-3. “Opal = AI 시대의 스케치북”이라는 행동 메시지로 마무리

<div align="center">⁂</div>

[^5_1]: https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880

[^5_2]: https://developers.google.com/opal

[^5_3]: https://www.youtube.com/watch?v=SrPWhiZhwV4

[^5_4]: https://jayaiissue.com/entry/구글-오팔-사용법-완벽-가이드-코딩-없이-AI-앱-10분-만에-만드는-법

[^5_5]: https://www.aitechsuite.com/ai-news/google-expands-no-code-ai-tool-opal-globally-democratizing-app-creation

[^5_6]: https://tilnote.io/en/pages/68e5c6c4411a716bc2e1b2a9


---

# 각 단계별 필요한 리소스와 입력물 정리해줘

각 “단계 목표”를 달성하기 위해 필요한 리소스(도구·환경)와 입력물(아이디어·데이터·결정)을 정리하면 아래와 같습니다.[^6_1][^6_2]

***

## 1. Opal 정체성 명확화 단계

- 필요한 리소스
    - Skywork Opal 가이드 전문(현재 보고 있는 글)[^6_2]
    - Opal 공식 사이트·공식 블로그(Introducing Opal)[^6_3]
    - 이름이 겹치는 다른 Opal 서비스 설명 자료(Opal Security, OpalAI, Opal.so 등)[^6_2]
- 필요한 입력물
    - “우리가 다루려는 Opal은 무엇인가?”에 대한 명확한 정의 문장[^6_2]
    - 독자 대상(시민 개발자, 비개발 실무자)에 대한 가설·페르소나 설정[^6_2]

***

## 2. 작동 원리·기능 이해 단계

- 필요한 리소스
    - Opal에 실제 접속 가능한 환경(브라우저, 인터넷, Google 계정)[^6_4][^6_2]
    - Opal 에디터 UI(노드 맵, 사이드바, App 탭 등)[^6_5]
    - Google AI 모델(Gemini, Imagen, Veo) 통합 옵션 설명 문서[^6_6][^6_2]
- 필요한 입력물
    - “이 앱이 처리할 입력은 무엇인가?”에 대한 정의 (텍스트, 파일, URL 등)[^6_7][^6_2]
    - 각 단계에서 수행할 AI 작업 설명(요약, 생성, 분석 등)[^6_6][^6_2]
    - 원하는 최종 출력 형식(텍스트, 표, 이미지, 링크 등)에 대한 명시[^6_2]

***

## 3. 타깃과 사용 맥락 정의 단계

- 필요한 리소스
    - 현재 조직/사용자의 직무별 업무 목록(마케팅, 기획, 교육, 프리랜서 등)[^6_2]
    - 노코드/AI 도입 관련 내부 정책·제약(보안, 데이터 위치 등)[^6_8]
    - 노코드 AI 시장·사용자 분포 리포트(시장 조사 보고서)[^6_9][^6_2]
- 필요한 입력물
    - “어떤 역할이, 어떤 반복 업무를 줄이고 싶은가?”에 대한 구체적인 Pain Point 리스트[^6_2]
    - 각 역할별로 “완전 자동화 vs 보조 도구” 구분 기준[^6_10]

***

## 4. 경쟁·시장 속 위치 파악 단계

- 필요한 리소스
    - n8n, Make.com, Bubble, Adalo, OpenAI Agent Builder 등 주요 경쟁 도구 스펙·가격·사용 사례[^6_11][^6_12]
    - 노코드 AI 플랫폼 시장 규모·CAGR·세그먼트 데이터(Future Market Insights, Technavio 등)[^6_13][^6_9][^6_2]
    - Opal 공식 문서(FAQ, Overview, Quickstart)와 서드파티 리뷰·튜토리얼[^6_14][^6_6]
- 필요한 입력물
    - 비교 기준(접근 방식, 사용 난이도, 연동성, 제어 수준, 가격 등) 정의[^6_11][^6_2]
    - “우리 조직이 중시하는 요소”에 대한 가중치(보안, 속도, 비용, 확장성 등)[^6_8]

***

## 5. 실제 사용·첫 앱 제작 단계

- 필요한 리소스
    - Google 계정, 지원 지역에서의 Opal 접근 권한[^6_4][^6_2]
    - Opal 템플릿 갤러리(예: Book Recs, 블로그 작성 템플릿)[^6_3][^6_2]
    - 튜토리얼 영상·문서(독서 챗봇, 블로그 자동화 예제)[^6_15][^6_2]
- 필요한 입력물
    - 구체적인 앱 아이디어 1~2개(예: 독서 추천, 블로그 자동화)[^6_2]
    - 템플릿 선택 및 수정 포인트(언어, 형식, 조건 등) 정의[^6_2]
    - 각 노드별 프롬프트 내용과 사용할 모델 선택(예: 검색 단계=경량 모델, 작성 단계=Gemini 2.5 Pro)[^6_1][^6_2]
    - 테스트용 입력 데이터(샘플 주제, 키워드, 사용자 질문 등)[^6_2]

***

## 6. 여정·미래·리스크 이해 단계

- 필요한 리소스
    - Opal 릴리스 노트·공식 블로그 타임라인[^6_16][^6_3]
    - 노코드 AI 시장 및 AI 플랫폼 시장 전망 리포트 여러 개[^6_17][^6_18][^6_9]
    - 기업 IT·보안·거버넌스 정책 문서(섀도우 IT 대응 기준)[^6_19][^6_8]
- 필요한 입력물
    - “우리가 허용 가능한 실험 수준”에 대한 내부 기준(파일럿 범위, 데이터 등급)[^6_8]
    - 핵심 시스템 vs 주변·R\&D 영역 구분 맵(어디까지 Opal 허용할지)[^6_2]
    - 향후 1~3년 내 기대 기능(Workspace 통합, API 공개 등)에 대한 우선순위[^6_20]

***

## 7. 역량·메시지 정리 단계

- 필요한 리소스
    - 조직 내 직무·역량 구조(개발자/비개발자 역할 정의)[^6_2]
    - AI·노코드 도입을 다룬 내부 교육 자료 또는 외부 인사이트 글[^6_21][^6_14]
- 필요한 입력물
    - “우리 조직/개인이 강화해야 할 핵심 역량” 정의(문제 정의, 프롬프트, 검증 등)[^6_2]
    - 비개발자/개발자 각각에게 기대하는 역할 변화(예: 프로토타이핑 책임 분담)[^6_2]
    - Opal을 “AI 시대의 스케치북”으로 실제 활용하기 위한 실험 계획(월 몇 개 PoC, 어떤 팀에서 등)[^6_1][^6_2]

이렇게 보면, 각 단계는 “도구 자체 리소스(Opal·문서·시장 데이터)”와 “당신 조직·업무에서 가져와야 하는 입력물(아이디어, 정책, 우선순위)”의 조합으로 구성됩니다.[^6_1][^6_2]
<span style="display:none">[^6_22][^6_23][^6_24][^6_25][^6_26][^6_27][^6_28][^6_29]</span>

<div align="center">⁂</div>

[^6_1]: https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880

[^6_2]: https://developers.googleblog.com/introducing-opal/

[^6_3]: https://www.jootoor.com/google-opal/

[^6_4]: https://developers.google.com/opal/quickstart

[^6_5]: https://developers.google.com/opal/overview

[^6_6]: https://www.youtube.com/watch?v=zDIUMn7hJfw

[^6_7]: https://discuss.pytorch.kr/t/opal-google-ai-feat-no-code/7662

[^6_8]: https://www.futuremarketinsights.com/reports/no-code-ai-platform-market

[^6_9]: https://insight.infograb.net/blog/2025/10/15/google-opal-review/

[^6_10]: https://jayaiissue.com/entry/구글-오팔-사용법-완벽-가이드-코딩-없이-AI-앱-10분-만에-만드는-법

[^6_11]: https://www.youtube.com/watch?v=SrPWhiZhwV4

[^6_12]: https://finance.yahoo.com/news/no-code-ai-platforms-market-143000513.html

[^6_13]: https://tilnote.io/pages/68e5c6c4411a716bc2e1b2a9

[^6_14]: https://www.datacamp.com/tutorial/google-opal-tutorial

[^6_15]: https://developers.googleblog.com/ko/introducing-opal/

[^6_16]: https://www.fortunebusinessinsights.com/no-code-ai-platform-market-110382

[^6_17]: https://www.futuremarketinsights.com/reports/ai-platform-market

[^6_18]: https://newsroom.technavio.org/no-code-ai-platform-market

[^6_19]: https://developers.google.com/opal

[^6_20]: https://www.kdnuggets.com/building-ai-automations-with-google-opal

[^6_21]: https://skywork.ai/skypage/ko/mcp-server-taskqueue-mcp-AI-엔지니어를-위한-심층-분석-가이드/1971415075506941952

[^6_22]: https://www.youtube.com/watch?v=PEkUMlmjzzs

[^6_23]: https://the-see.tistory.com/259

[^6_24]: https://docs.opalmedapps.com/development/local-dev-setup/

[^6_25]: https://www.optimizely.com/developers/Opal/

[^6_26]: https://www.youtube.com/watch?v=PYHMVHuts2E

[^6_27]: https://www.youtube.com/watch?v=NWNNDvehBIU

[^6_28]: https://ecobeauty.tistory.com/entry/Opal-AI-나만의-AI-미니-앱을-구축하는-워크플로우-초보-가이드

[^6_29]: https://www.datacamp.com/es/tutorial/google-opal-tutorial


---

# 구현 절차를 실행 가능한 작업 단위로 분해해줘

Answer skipped.

---

# 우선순위 기준과 의사결정 규칙 제안해줘

Opal을 어디에, 어떻게 우선 적용할지 결정할 때 쓸 수 있는 **우선순위 기준 + 의사결정 규칙**을 “실험용 도구, 프로토타이핑 적합성, 섀도우 IT 리스크” 관점에서 제안하겠습니다.[^8_1][^8_2][^8_3]

***

## 1. 1차 필터: “Opal로 해도 되는가?” 여부

**기준 A: 업무 중요도·리스크 레벨**[^8_4][^8_3]

- A1. 고객 PII/민감 정보·재무·규제 데이터 포함? → Yes면 Opal 금지.
- A2. 다운되면 비즈니스가 멈추는 미션 크리티컬 프로세스? → Yes면 Opal 금지.
- A3. 규제 준수(금융/의료/공공) 필수 영역? → Yes면 Opal 금지.

**규칙 A**

- A1~A3 중 하나라도 Yes → “엔터프라이즈급 플랫폼(예: Power Apps, Salesforce, 커스텀 개발)으로만 구현”[^8_5][^8_4]
- 모두 No → Opal 후보 유지(다음 단계로).

***

## 2. 2차 필터: “Opal이 특히 적합한가?” 여부

**기준 B: 작업 특성**[^8_6][^8_7][^8_3]

- B1. 반복적·단순하지만 사람 시간이 많이 드는가? (요약, 정리, 초안 생성 등)
- B2. 결과물이 “문서·콘텐츠·요약·간단 툴” 수준인가? (보고서 초안, 블로그, 챗봇, 간단 폼 등)
- B3. 복잡한 조건 분기·정교한 에러 핸들링이 필수인지?

**규칙 B**

- B1=Yes AND B2=Yes AND B3=No → Opal **우선 후보**[^8_8][^8_9][^8_3]
- B3=Yes → Zapier/n8n/Make, 로우코드/코드 기반으로 이관 고려[^8_7][^8_8]

***

## 3. 3차 필터: “실험·프로토타입 가치” 기준

**기준 C: 실험 가치·속도**[^8_2][^8_3]

- C1. 아이디어 검증이 목적(MVP, PoC, UX 프로토타입)인가?
- C2. 정답보다 “빠른 피드백·실패”가 중요한가?
- C3. 구현 난이도 대비 기대 학습/통찰이 큰가?

**규칙 C**

- C1=Yes OR C2=Yes → Opal **1순위** (아이디어 검증 도구)[^8_10][^8_3][^8_7]
- C1=No AND 장기 운영이 전제 → 장기 유지보수 관점에서 다른 플랫폼도 함께 검토.

***

## 4. 4차 필터: “조직 거버넌스·섀도우 IT” 관점

**기준 D: 관리 가능성**[^8_11][^8_3][^8_4]

- D1. IT/보안이 정의한 “Opal 샌드박스 영역” 안에서 쓰이는가?
- D2. 결과물(앱)·데이터 흐름을 중앙에서 인벤토리/모니터링할 수 있는가?
- D3. 만든 앱이 자연스럽게 다른 팀에 공유·확산될 가능성이 큰가?

**규칙 D**

- D1=Yes → “샌드박스 안에서 자유 실험 허용”[^8_12][^8_4]
- D1=No AND D3=Yes → “사용 전 사전 승인 필수 + 카탈로그 등록 강제”
- D2=No → 민감 데이터·실운영 데이터 연계 금지(입출력 모두 제한).[^8_13][^8_4]

***

## 5. 우선순위 결정 매트릭스 (간단 규칙)

각 후보 업무에 대해 아래 기준을 체크하고, 우선순위를 단순 점수화해서 쓰면 됩니다.[^8_3][^8_6][^8_1]

- 비즈니스 **리스크 낮음** (A1~A3 모두 No) → +2
- 반복·콘텐츠형 작업 (B1\&B2 Yes) → +2
- 프로토타입/실험 목적 (C1 또는 C2 Yes) → +2
- 샌드박스 내에서 관리 가능 (D1 Yes) → +1
- 복잡 로직·규제·민감데이터 필요 (A or B3 Yes) → -3

**의사결정 규칙(실무용 간단 버전)**

- 총점 ≥ 5 → “Opal로 1차 PoC 진행”
- 2 ≤ 총점 < 5 → “Opal로 실험 가능하나, 중장기 구현 플랫폼은 별도 검토”
- 총점 < 2 또는 -값 → “Opal 비적합, 다른 플랫폼 사용”

***

## 6. 운영 규칙(정책 레벨)

1) **샌드박스 우선 원칙**[^8_4]

- Opal은 “R\&D/프로토타입/내부 비핵심 업무” 영역에서만 사용 허용.
- 프로덕션 전환 시에는 반드시 엔터프라이즈 플랫폼 또는 코드 기반 재구현.

2) **민감 데이터 금지 원칙**[^8_11][^8_3][^8_4]

- PII, 재무, 헬스케어 등 민감 데이터는 Opal 입력·출력 모두 금지.
- 필요한 경우, 샘플·마스킹 데이터만 사용.

3) **카탈로그·리뷰 원칙**[^8_12][^8_4]

- 누구든 Opal 앱을 만들면 내부 카탈로그(예: Notion, Confluence)에 등록.
- 일정 사용량·영향 이상일 경우, IT/보안·아키텍트가 정기 리뷰.

4) **수명 주기 원칙**

- “실험용 앱”에는 만료일(예: 3개월)을 기본 설정.
- 계속 쓰면 “정식 재구현 후보”로 분류, 플랫폼 재선정 절차로 이동.[^8_2][^8_3]

이 기준·규칙 세트를 그대로 체크리스트 화하면, Opal 관련 PoC/업무 자동화 아이템을 고를 때 일관된 의사결정이 가능합니다.
<span style="display:none">[^8_14][^8_15][^8_16][^8_17][^8_18][^8_19][^8_20]</span>

<div align="center">⁂</div>

[^8_1]: https://skywork.ai/skypage/ko/google-opal-ai-guide/1983742548047994880

[^8_2]: https://www.mobiinside.co.kr/2025/10/24/google-opal-ai/

[^8_3]: https://www.baytechconsulting.com/blog/google-opal-what-is-it-2025

[^8_4]: https://goddaehee.tistory.com/436

[^8_5]: https://insight.infograb.net/blog/2025/10/15/google-opal-review/

[^8_6]: https://www.cosmiannews.com/news/399714

[^8_7]: https://www.velopers.kr/post/5462

[^8_8]: https://brunch.co.kr/@hyemin/16

[^8_9]: https://brunch.co.kr/@ghidesigner/366

[^8_10]: https://www.ainvest.com/news/google-opal-rise-vibe-coding-era-code-ai-development-2512/

[^8_11]: https://spin.ai/blog/shadow-ai-vs-shadow-it-role-of-saas-risk-assessment-zero-trust-risk-mitigation/

[^8_12]: https://www.coursera.org/enterprise/articles/shadow-it

[^8_13]: https://kr.linkedin.com/pulse/no-code-ai-오케스트레이션-google-opal기술-백서-whitepaper-keonwoo-park-6o9qc

[^8_14]: https://yozm.wishket.com/magazine/detail/3504/

[^8_15]: https://www.youtube.com/watch?v=1skQUvXi8P8

[^8_16]: https://www.facebook.com/groups/698593531630485/posts/1469482074541623/

[^8_17]: https://www.youtube.com/watch?v=u4QZf7PB5C4

[^8_18]: https://tonycico0912.tistory.com/439

[^8_19]: https://developers.googleblog.com/ko/introducing-opal/

[^8_20]: https://mudidi.tistory.com/3407


---

# 01 n8n이란 무엇인가

n8n이란?
공식 홈페이지 : [https://n8n.io/](https://n8n.io/)
n8n(pronounced "n-eight-n")은 노드 기반 워크플로우 자동화 플랫폼입니다. 코딩 없이 시각적 인터페이스를 통해 다양한 서비스와 애플리케이션을 연결하여 자동화 워크플로우를 구축할 수 있습니다. 
주요 특징
시각적 워크플로우 편집기: 코드를 작성할 필요 없이 드래그 앤 드롭 방식으로 노드를 연결하여 복잡한 자동화 로직을 구현할 수 있습니다.
다양한 통합 노드: 500개 이상의 다양한 애플리케이션 및 서비스(API, 데이터베이스, 클라우드 서비스 등)와 연동할 수 있는 기본 노드를 제공합니다.
유연한 확장성: JavaScript 코드를 사용해 커스텀 노드를 직접 개발하거나, 기존 노드의 기능을 확장할 수 있어 거의 모든 자동화 시나리오에 대응 가능합니다.
셀프 호스팅 지원: 클라우드 버전 외에, 자체 서버에 직접 설치할 수 있는 커뮤니티 버전(무료)을 제공하여 데이터 프라이버시와 보안을 강화할 수 있습니다.
강력한 데이터 처리: 여러 단계의 데이터 변환, 분기(IF), 병합(Merge), 반복(Loop) 등 복잡한 데이터 흐름을 손쉽게 처리할 수 있습니다.
핵심 개념
n8n을 효과적으로 사용하기 위해 알아야 할 몇 가지 핵심 개념이 있습니다.
워크플로우 (Workflows)
자동화 작업의 전체적인 흐름을 정의하는 캔버스입니다.
하나 이상의 노드(Node)들로 구성되며, 이 노드들이 연결되어 특정 작업을 순차적으로 또는 조건에 따라 수행합니다.
노드 (Nodes)
워크플로우를 구성하는 가장 기본적인 단위입니다.
각 노드는 특정 기능(예: 데이터 읽기, API 호출, 이메일 전송)을 수행합니다.
노드는 크게 세 가지 종류로 나뉩니다.
트리거 노드 (Trigger Nodes): 워크플로우를 시작시키는 노드입니다. (예: 특정 시간에 실행, 웹훅 수신)
일반 노드 (Regular Nodes): 데이터를 가져오거나, 변환하거나, 특정 작업을 수행하는 노드입니다.
코어 노드 (Core Nodes): 분기(IF), 병합(Merge) 등 워크플로우의 흐름을 제어하는 노드입니다.
연결 (Connections)
노드와 노드 사이를 이어주는 선입니다.
데이터가 한 노드에서 다음 노드로 어떻게 전달될지를 결정합니다.
자격 증명 (Credentials)
API 키, 사용자 이름, 비밀번호 등 외부 서비스에 접근하기 위한 인증 정보를 안전하게 저장하고 관리하는 기능입니다.
한 번 저장된 자격 증명은 여러 워크플로우에서 재사용할 수 있습니다.
실행 (Executions)
워크플로우가 트리거되어 실제로 실행된 기록입니다.
실행 로그를 통해 각 노드가 어떻게 동작했는지, 데이터가 어떻게 변환되었는지 확인할 수 있어 디버깅에 유용합니다.

내용 정리

n8n의 개념과 핵심 요소를, 요청하신 내용 중심으로 정리합니다.

***

## 1. n8n이란 무엇인가

- n8n은 **노드 기반 워크플로우 자동화 플랫폼**으로, 다양한 서비스와 앱을 연결해 데이터 이동·변환·알림 등을 자동화하는 도구입니다.[^10_1][^10_2]
- 시각적 드래그앤드롭 UI와 함께 JavaScript·Python 코드를 섞어 쓸 수 있어, 노코드부터 하드코드까지 폭넓게 커버하는 것이 특징입니다.[^10_3][^10_1]

***

## 2. 주요 특징 요약

- **시각적 워크플로우 편집기**: 캔버스에서 노드를 드래그해 연결하면서 복잡한 자동화 로직을 설계·수정할 수 있습니다.[^10_2][^10_1]
- **다양한 통합 노드**: 400~500개 이상의 SaaS·DB·API 노드를 제공하며, Slack, PostgreSQL, OpenAI 등과 바로 연동 가능합니다.[^10_4][^10_1][^10_3]
- **코드 확장성**: JavaScript/Python 코드 노드를 사용해 커스텀 로직·라이브러리(npm, Python 패키지)를 활용할 수 있습니다.[^10_1][^10_3]
- **셀프 호스팅 지원**: Docker·VM·Kubernetes 등에 설치 가능한 커뮤니티 버전과, 관리형 클라우드 버전을 모두 제공합니다.[^10_5][^10_6][^10_1]
- **강력한 데이터 처리**: 분기(IF), 병합(Merge), 반복(Loop)과 같은 코어 노드를 통해 복잡한 멀티스텝 데이터 파이프라인을 구성할 수 있습니다.[^10_7][^10_1]

***

## 3. 핵심 개념 정리

- **워크플로우(Workflow)**
    - 하나의 자동화 시나리오 전체를 정의하는 단위로, 캔버스 위에 여러 노드가 연결된 구조입니다.[^10_2][^10_1]
    - 예: “Webhook 수신 → 데이터 변환 → DB 저장 → 이메일·Slack 알림”.
- **노드(Node)**
    - 워크플로우를 구성하는 기본 블록으로, 각 노드가 특정 기능(API 호출, 파일 처리, 분기 등)을 담당합니다.[^10_4][^10_1]
    - 주요 유형:
        - 트리거 노드: Webhook, Cron, App Event 등 워크플로우 시작점.[^10_8][^10_1]
        - 일반 노드: HTTP 요청, DB 쿼리, 이메일 전송 등 작업 수행.
        - 코어 노드: IF, Merge, Split, Loop 등 흐름 제어·데이터 구조 조작.
- **연결(Connection)**
    - 노드 간 데이터 흐름을 나타내는 선으로, 상류 노드 출력이 하류 노드 입력으로 전달됩니다.[^10_7][^10_1]
- **자격 증명(Credentials)**
    - 외부 서비스 API 키, OAuth 토큰 등을 암호화해 저장·재사용하는 기능으로, 여러 워크플로우에서 공통 인증 정보를 관리합니다.[^10_9][^10_1]
- **실행(Executions)**
    - 워크플로우가 실제로 한 번 돌아간 “런(run)” 단위이며, 각 노드의 입력/출력·에러를 실행 로그에서 확인해 디버깅에 사용합니다.[^10_1][^10_7]

***

## 4. 엔터프라이즈·AI 측면 특징

- n8n은 온프레미스 배포, SSO(SAML/LDAP), 암호화된 시크릿 스토어, RBAC, 감사 로그 등 **엔터프라이즈 기능**을 제공합니다.[^10_10][^10_1]
- 최신 버전은 LLM·AI 에이전트 워크플로우(여러 LLM·툴·메모리·벡터스토어 연계)를 지원해, 멀티스텝 AI 자동화에도 활용할 수 있습니다.[^10_11][^10_12][^10_1]

***

## 5. 한 줄 정리

- n8n은 “시각적 노드 기반 + 필요 시 코드”라는 하이브리드 방식을 통해, 단순 자동화부터 복잡한 AI 워크플로우까지 **유연하게 설계·운영할 수 있는 오픈 소스 자동화 플랫폼**입니다.[^10_3][^10_1]
<span style="display:none">[^10_13][^10_14][^10_15][^10_16][^10_17][^10_18][^10_19][^10_20]</span>

<div align="center">⁂</div>

[^10_1]: https://n8n.io

[^10_2]: https://datascientest.com/en/n8n-an-overview-of-the-workflow-automation-tool

[^10_3]: https://github.com/n8n-io/n8n

[^10_4]: https://docs.n8n.io/integrations/builtin/node-types/

[^10_5]: https://www.hostinger.com/self-hosted-n8n

[^10_6]: https://northflank.com/blog/how-to-self-host-n8n-setup-architecture-and-pricing-guide

[^10_7]: https://tha-shed.com/n8n-cheatsheet/

[^10_8]: https://automategeniushub.com/guide-to-n8n-trigger-nodes/

[^10_9]: https://docs.n8n.io/integrations/builtin/credentials/

[^10_10]: https://osher.com.au/blog/benefits-of-self-hosting-n8n/

[^10_11]: https://hatchworks.com/blog/ai-agents/n8n-guide/

[^10_12]: https://github.com/n8n-io/self-hosted-ai-starter-kit

[^10_13]: https://n8n.io/ai/

[^10_14]: https://latenode.com/blog/low-code-no-code-platforms/n8n-setup-workflows-self-hosting-templates/what-is-n8n-workflow-automation-complete-platform-overview-honest-analysis-2025

[^10_15]: https://www.hostinger.com/in/tutorials/what-is-n8n

[^10_16]: https://www.reddit.com/r/n8n/comments/1m6dn1w/i_found_a_way_to_use_dynamic_credentials_in_n8n/

[^10_17]: https://www.hostinger.com/tutorials/what-is-n8n

[^10_18]: https://hackceleration.com/n8n-review/

[^10_19]: https://docs.n8n.io/hosting/

[^10_20]: https://github.com/n8n-io


---

# [https://wikidocs.net/302246](https://wikidocs.net/302246) 내용 정리

위키독스 302246은 **「01-03 데이터 흐름의 이해 (Flow Logic)」**로, n8n에서 데이터가 어떻게 이동·처리되는지에 초점을 맞춘 장입니다. 핵심만 정리하면 아래와 같습니다.[^11_1]

***

## 1. 전체 개요

- n8n 워크플로우는 “트리거 노드에서 시작된 데이터가 연결(Connection)을 따라 각 노드로 전달되고, 노드마다 데이터를 가공하며 다음으로 넘기는 연쇄 구조”로 동작한다고 설명합니다.[^11_1]
- 이 연속적인 데이터 흐름을 이해하는 것이, 복잡한 자동화 로직을 설계·디버깅하는 기본이라고 강조합니다.[^11_1]

***

## 2. 데이터 흐름의 기본 원리

- 트리거 노드(예: Webhook, Cron)에서 최초 데이터가 생성되면, 연결된 다음 노드의 입력으로 전달됩니다.[^11_1]
- 각 노드는 입력 데이터를 받아 가공(조회·변환·필터링 등)하고, 새로운 출력 데이터를 생성해 다음 노드로 넘깁니다.[^11_1]

***

## 3. 노드 간 데이터 구조와 처리

- 노드 출력은 주로 **아이템 배열 구조**(items[])로 관리되며, 다음 노드는 이 배열을 기준으로 루프처럼 처리할 수 있습니다.[^11_1]
- 데이터 변환, 필터링, 매핑 등은 Set, IF, Merge 같은 코어 노드를 통해 구현하며, 각 노드가 어떤 형태의 데이터를 기대·반환하는지 이해하는 것이 중요하다고 설명합니다.[^11_1]

***

## 4. 분기·병합·병렬 처리

- IF 노드로 조건 분기를 만들고, 각 분기에서 다른 노드 체인을 실행한 뒤, Merge 노드로 다시 합치는 패턴을 다룹니다.[^11_1]
- 여러 외부 시스템 호출을 병렬로 실행한 후 결과를 한 번에 모으는 식의 패턴도, 데이터 흐름 관점에서 설명합니다.[^11_1]

***

## 5. 실행 순서 제어

- 기본적으로 n8n은 연결 관계를 기반으로 자동으로 실행 순서를 결정하지만, 다음과 같은 방식으로 제어 가능하다고 정리합니다.[^11_1]
    - 명시적 연결: 어떤 노드 뒤에 어떤 노드가 올지 직접 선으로 연결.
    - Wait 노드: 특정 시간/조건까지 대기 후 다음 단계 진행.
    - Merge 노드: 여러 경로의 노드들이 모두 끝난 뒤에 다음 단계로 넘어가도록 동기화.[^11_1]

***

## 6. 실무적 포인트

- “각 노드에서 데이터가 어떻게 변형되는지”를 실행 로그와 함께 추적하는 습관이 중요하다고 강조하며, 이는 디버깅과 최적화의 핵심이라고 설명합니다.[^11_1]
- 결국 이 장의 목적은, n8n을 단순히 UI 도구로 보는 것이 아니라, **데이터가 흐르는 파이프라인**으로 이해하도록 사고 방식을 전환시키는 것입니다.[^11_1]
<span style="display:none">[^11_10][^11_11][^11_12][^11_13][^11_14][^11_15][^11_16][^11_17][^11_2][^11_3][^11_4][^11_5][^11_6][^11_7][^11_8][^11_9]</span>

<div align="center">⁂</div>

[^11_1]: https://wikidocs.net/302246

[^11_2]: https://velog.io/@jejeong000/n8n-1

[^11_3]: https://wikidocs.net/308959

[^11_4]: https://wikidocs.net/312180

[^11_5]: https://wikidocs.net/290881

[^11_6]: https://wikidocs.net/290951

[^11_7]: https://wikidocs.net/290882

[^11_8]: https://wikidocs.net/292565

[^11_9]: https://wikidocs.net/profile/info/book/28613

[^11_10]: https://wikidocs.net/292573

[^11_11]: https://wikidocs.net/book/18092

[^11_12]: https://wikidocs.net/314128

[^11_13]: https://wikidocs.net/290953

[^11_14]: https://wikidocs.net/310112

[^11_15]: https://wikidocs.net/290977

[^11_16]: https://wikidocs.net/282389

[^11_17]: https://wikidocs.net/291122


---

# 06 워크플로우

[06 워크플로우: 자동화의 심장](https://wikidocs.net/290941#06)
[워크플로우란 무엇인가?](https://wikidocs.net/290941#_1)
[워크플로우의 핵심 구성 요소](https://wikidocs.net/290941#_2)
[1. 노드 (Nodes)](https://wikidocs.net/290941#1-nodes)
[2. 연결 (Connections)](https://wikidocs.net/290941#2-connections)
[3. 데이터 (Data)](https://wikidocs.net/290941#3-data)
[워크플로우의 생명주기](https://wikidocs.net/290941#_3)
[워크플로우 시각화 (Mermaid)](https://wikidocs.net/290941#mermaid)
[디버깅 가이드: 워크플로우가 멈췄을 때](https://wikidocs.net/290941#_4)
[1. 실행 기록(Executions) 확인](https://wikidocs.net/290941#1-executions)
[2. 노드 데이터 확인 (Pin Data)](https://wikidocs.net/290941#2-pin-data)
[3. 흔한 에러 유형](https://wikidocs.net/290941#3)
[결론](https://wikidocs.net/290941#_5)
06 워크플로우: 자동화의 심장
n8n의 모든 것은 워크플로우(Workflow)에서 시작하고 끝납니다. 워크플로우는 여러분의 아이디어를 실제 자동화로 구현하는 캔버스이자, 모든 작업이 일어나는 공간입니다. 이 문서는 n8n의 가장 핵심적인 개념인 워크플로우에 대한 전반적인 개요를 제공합니다.
이 문서는 n8n 공식 문서의 [Workflows](https://docs.n8n.io/workflows/) 페이지를 기반으로 작성되었습니다.
워크플로우란 무엇인가?
워크플로우는 자동화 작업을 시각적으로 설계한 청사진입니다. 마치 디지털 레고 블록(노드)을 연결하여 원하는 결과물을 만드는 것과 같습니다. 예를 들어, "매일 아침 9시에 새로운 뉴스 기사를 가져와서, 그 내용을 요약한 뒤, 슬랙으로 보내줘"와 같은 작업을 워크플로우로 만들 수 있습니다.
하나의 워크플로우는 여러 개의 노드(Nodes)와 그들을 잇는 연결(Connections)로 구성되며, 데이터는 이 연결선을 따라 흐릅니다.
워크플로우의 핵심 구성 요소

1. 노드 (Nodes)
노드는 워크플로우의 가장 기본적인 실행 단위로, 특정 작업을 수행하는 블록입니다. n8n에는 수백 개의 노드가 있으며, 크게 두 종류로 나눌 수 있습니다.
트리거 노드 (Trigger Nodes): 워크플로우를 시작시키는 노드입니다. 항상 워크플로우의 맨 앞에 위치하며, "언제" 또는 "어떤 조건에서" 자동화를 시작할지 정의합니다. (예: Schedule - 정해진 시간에 시작, Webhook - 특정 URL 요청이 오면 시작)
일반 노드 (Regular Nodes): 실제 작업을 수행하는 노드입니다. 데이터를 가져오고, 변환하고, 다른 서비스로 보내는 등의 역할을 합니다. (예: HTTP Request, Google Sheets, OpenAI)
2. 연결 (Connections)
연결은 노드와 노드 사이를 잇는 선입니다. 이 연결은 두 가지 중요한 역할을 합니다.
실행 순서 정의: 어떤 노드가 실행된 후 다음에 어떤 노드가 실행될지 순서를 결정합니다.
데이터 전달: 이전 노드에서 처리된 결과 데이터(JSON 형식)를 다음 노드로 전달하는 통로 역할을 합니다.
3. 데이터 (Data)
모든 노드는 데이터를 입력으로 받아 처리한 후, 결과 데이터를 출력으로 내보냅니다. 이 데이터는 JSON(JavaScript Object Notation) 형식을 사용하며, 워크플로우의 각 단계를 거치면서 데이터가 어떻게 변하는지 n8n 인터페이스에서 시각적으로 확인할 수 있습니다.
워크플로우의 생명주기
워크플로우를 만들고 운영하는 과정은 보통 다음 단계를 따릅니다.
생성 (Create): Add workflow 버튼을 눌러 빈 캔버스에서 시작하거나, 기존의 템플릿을 활용하여 워크플로우를 만듭니다.
구축 (Build): 필요한 트리거 노드와 일반 노드들을 캔버스에 추가하고, 파라미터를 설정한 뒤, 노드들을 연결하여 자동화 로직을 구성합니다.
테스트 (Test): Execute workflow 버튼을 눌러 워크플로우를 수동으로 실행해 봅니다. 각 노드가 예상대로 동작하는지, 데이터가 올바르게 전달되는지 확인하는 중요한 과정입니다.
활성화 (Activate): 테스트가 완료되면, 워크플로우 우측 상단의 Active 토글을 켜서 워크플로우를 "라이브" 상태로 만듭니다. 이제 트리거 노드에 설정된 조건에 따라 워크플로우가 자동으로 실행됩니다.
관리 (Manage): 워크플로우의 실행 기록(Executions)을 확인하여 성공/실패 여부를 모니터링하고, 필요에 따라 워크플로우를 수정하고 버전을 관리합니다.
워크플로우 시각화 (Mermaid)
워크플로우의 흐름을 시각적으로 이해하면 훨씬 쉽습니다. 아래는 간단한 뉴스 알림 워크플로우의 구조입니다.
graph LR

```
A[Schedule Trigger<br>매일 아침 9시] --> B[HTTP Request<br>뉴스 데이터 가져오기]
```

B --> C[AI Agent<br>뉴스 요약하기]
C --> D[Slack<br>메시지 전송]

style A fill:\#ff9900,stroke:\#333,stroke-width:2px
style B fill:\#40e0d0,stroke:\#333,stroke-width:2px
style C fill:\#8a2be2,stroke:\#333,stroke-width:2px,color:\#fff
style D fill:\#4a154b,stroke:\#333,stroke-width:2px,color:\#fff

디버깅 가이드: 워크플로우가 멈췄을 때
자동화가 항상 완벽할 수는 없습니다. 문제가 생겼을 때 해결하는 방법입니다.

1. 실행 기록(Executions) 확인
왼쪽 사이드바의 'Executions' 메뉴에서 과거 실행 기록을 볼 수 있습니다. - 초록색: 성공 - 빨간색: 실패. 클릭하여 어떤 노드에서 에러가 났는지 확인하세요.
2. 노드 데이터 확인 (Pin Data)
특정 노드가 예상치 못한 데이터를 내뱉는지 의심된다면, 노드 위에 마우스를 올리고 핀 아이콘을 클릭하여 데이터를 고정(Pin)해보세요. 테스트 실행 시 고정된 데이터를 사용하여 디버깅할 수 있습니다.
Pin Data is disabled as this node's output contains binary data. n8n이 의도적으로 막아둔 기능입니다. 그 이유는 '웹 브라우저의 성능 보호' 때문입니다.
왜 안 되는지, 기술적인 이유를 조금 더 쉽게 풀어서 설명해 드릴게요.
🛑 브라우저가 멈추는 것을 방지 n8n의 'Pin Data' 기능은 데이터를 서버가 아닌 사용자의 웹 브라우저(메모리)와 워크플로우 파일(JSON) 자체에 저장합니다.
텍스트 데이터: 용량이 작아서(수 KB) 브라우저에 저장해도 문제가 없습니다.
Binary(이미지/영상) 데이터: 파일 그 자체를 텍스트 코드로 변환(Base64 인코딩)해서 저장해야 하는데, 이 과정에서 용량이 원본보다 약 30% 더 커집니다.
만약 10MB짜리 이미지를 Pin 하면, 워크플로우 코드가 순식간에 수만 줄의 텍스트로 불어납니다.
이 상태로 저장하면 다음에 이 워크플로우를 열 때 브라우저가 버벅거리거나 아예 멈춰버립니다(Crash).
📂 워크플로우 파일의 비대화 방지 Pin된 데이터는 워크플로우의 "일부"가 되어버립니다. 만약 바이너리 데이터를 Pin 할 수 있게 해준다면, 워크플로우 파일(workflow.json) 크기가 수십 MB를 넘어가게 됩니다. 이렇게 되면:
워크플로우 로딩 속도가 극도로 느려집니다.
복사/붙여넣기가 안 되거나, n8n 서버에 과부하를 줄 수 있습니다.
💡 그럼 어떻게 테스트해야 하나요? 앞서 말씀드린 대로, 바이너리 데이터는 "브라우저에 저장(Pin)"하려 하지 마시고, "서버나 파일 시스템에 흘려보내는" 방식으로 테스트해야 합니다.
Pin 대신 다운로드: 결과를 눈으로 확인하고 싶다면, Google Drive나 Slack 노드를 임시로 연결해서 파일을 전송받아 확인하세요.
작은 샘플 파일 사용: 개발 중에는 실제 대용량 파일 대신 10KB 미만의 아주 작은 이미지 아이콘 등을 사용해서 로직만 점검하세요. (작은 파일은 간혹 처리가 될 때도 있지만, 습관적으로 안 하는 게 좋습니다.)
결국, "사용자의 컴퓨터가 멈추지 않도록 n8n이 안전장치를 걸어둔 것"이라고 이해하시면 됩니다.
3. 흔한 에러 유형
JSON Parse Error: API 응답이 올바른 JSON 형식이 아닐 때 발생합니다. JSON Parse 노드를 사용해보세요.
Expression Error: 수식(Expression)에 오타가 있거나, 존재하지 않는 변수를 참조했을 때 발생합니다.
결론
워크플로우는 n8n의 심장과도 같습니다. 노드를 연결하여 데이터의 흐름과 작업 순서를 정의하는 이 간단한 개념을 통해, 우리는 코딩 없이도 복잡하고 강력한 자동화 시스템을 구축할 수 있습니다. 다음 장부터는 다양한 노드와 기능을 활용하여 실제로 워크플로우를 만들어보는 방법을 더 깊이 있게 다룰 것입니다.

내용 정리

n8n 가이드북의 “06 워크플로우” 장은, 워크플로우를 **자동화의 심장**으로 보고 개념·구성요소·생명주기·디버깅을 한 번에 잡아주는 챕터입니다.[^12_1]

***

## 1. 워크플로우의 정의

- 워크플로우는 “자동화 작업을 시각적으로 설계한 청사진”으로, 디지털 레고 블록(노드)을 연결해 원하는 결과를 만드는 구조로 설명합니다.
- 예: “매일 9시에 뉴스 가져오기 → 요약 → Slack 전송” 같은 시나리오를 하나의 워크플로우로 구성합니다.

***

## 2. 핵심 구성 요소

- **노드(Nodes)**
    - 트리거 노드: 워크플로우 시작 시점/조건 정의 (Schedule, Webhook 등).
    - 일반 노드: 실제 작업 수행(HTTP Request, Google Sheets, OpenAI 등).
- **연결(Connections)**
    - 노드 실행 순서를 정의하고, 이전 노드의 출력 데이터를 다음 노드로 전달하는 통로 역할을 합니다.
- **데이터(Data)**
    - 모든 노드는 입력 데이터를 받아 처리 후 JSON 형식으로 출력하며, 각 단계에서 데이터가 어떻게 변하는지 UI에서 시각적으로 확인할 수 있습니다.

***

## 3. 워크플로우의 생명주기

- **생성(Create)**: Add workflow로 빈 캔버스 시작 또는 템플릿 기반 생성.
- **구축(Build)**: 트리거·일반 노드를 배치하고 파라미터 설정 후 연결해 로직 구성.
- **테스트(Test)**: Execute workflow로 수동 실행, 각 노드 동작·데이터 전달을 검증.
- **활성화(Activate)**: Active 토글 ON → 트리거 조건에 따라 자동 실행되는 라이브 상태가 됨.
- **관리(Manage)**: 실행 기록(Executions) 모니터링, 실패 분석, 수정·버전 관리 수행.

***

## 4. 시각화 예시(Mermaid)

- 간단한 뉴스 알림 워크플로우를 Mermaid 다이어그램으로 표현해,
“Schedule → HTTP Request → AI 요약 → Slack 전송” 흐름을 시각적으로 보여줍니다.
- 각 노드에 다른 색·스타일을 적용해 트리거/외부 API/AI/슬랙 역할을 구분합니다.

***

## 5. 디버깅 가이드

- **1) 실행 기록(Executions)**
    - 사이드바의 Executions에서 과거 실행을 확인, 성공/실패(초록/빨강)와 에러 발생 노드를 추적합니다.[^12_1]
- **2) 노드 데이터 확인(Pin Data)**
    - 특정 노드의 출력을 “핀”으로 고정해 테스트 시 같은 데이터를 반복 사용하며 디버깅할 수 있습니다.
    - 다만 바이너리 데이터(이미지·영상 등)는 Pin이 막혀 있는데, 이는 Base64 인코딩 시 워크플로우 JSON이 비대해져 브라우저가 멈추는 것을 방지하기 위한 안전장치라고 설명합니다.
    - 대신:
        - Google Drive·Slack 등으로 결과 파일을 보내 직접 확인하거나
        - 작은 샘플 파일로만 테스트하는 방식을 권장합니다.
- **3) 흔한 에러 유형**
    - JSON Parse Error: API 응답이 JSON 형식이 아닐 때 → JSON Parse 노드 활용 권장.
    - Expression Error: 수식 오타·존재하지 않는 변수 참조 시 발생 → 표현식 재검토 필요.

***

## 6. 결론 메시지

- 워크플로우는 n8n의 **심장**이며, “노드 + 연결 + 데이터 흐름”이라는 단순 개념만 이해하면, 코딩 없이도 복잡한 자동화를 구축할 수 있다고 정리합니다.
- 이후 장에서 다양한 노드와 기능을 활용해 실제 워크플로우를 만드는 실습으로 이어진다고 예고합니다.

<div align="center">⁂</div>

[^12_1]: https://wikidocs.net/302246


---

# 글에서 사용된 핵심 개념들과 정의를 목록으로 보여줘

이 챕터(06 워크플로우)에 등장하는 핵심 개념과 정의만 깔끔하게 뽑으면 다음과 같습니다.[^13_1]

***

## 1. 워크플로우 관련 개념

- **워크플로우(Workflow)**
자동화 작업을 시각적으로 설계한 청사진이자 캔버스로, 여러 노드와 연결로 구성되며 데이터 흐름과 작업 순서를 정의하는 공간.[^13_1]
- **워크플로우의 생명주기**
생성(Create) → 구축(Build) → 테스트(Test) → 활성화(Activate) → 관리(Manage)로 이어지는, 워크플로우가 만들어지고 운영·개선되는 전 과정.[^13_1]

***

## 2. 노드·연결·데이터

- **노드(Node)**
워크플로우의 가장 기본적인 실행 단위로, 특정 작업을 수행하는 블록.[^13_1]
- **트리거 노드(Trigger Nodes)**
워크플로우를 시작시키는 노드로, “언제/어떤 조건에서” 자동화를 시작할지 정의하며 항상 워크플로우의 맨 앞에 위치.[^13_1]
- **일반 노드(Regular Nodes)**
데이터를 가져오고, 변환하고, 외부 서비스로 보내는 등 실제 작업을 수행하는 노드.[^13_1]
- **연결(Connections)**
노드와 노드를 잇는 선으로,
    - 실행 순서를 정의하고
    - 이전 노드의 결과 데이터(JSON)를 다음 노드로 전달하는 통로 역할을 하는 요소.[^13_1]
- **데이터(Data)**
모든 노드가 입력으로 받아 처리하고 출력하는 정보로, 기본적으로 JSON 형식을 사용하며 단계별로 어떻게 변하는지 UI에서 확인 가능.[^13_1]

***

## 3. 실행·디버깅 관련 개념

- **실행 기록(Executions)**
워크플로우가 트리거되어 실제로 동작한 각각의 실행 로그로, 성공/실패 여부와 어느 노드에서 에러가 났는지 확인하는 데 사용.[^13_1]
- **Pin Data(데이터 고정)**
특정 노드의 출력 데이터를 고정해 이후 테스트 실행 시 매번 같은 데이터를 사용하도록 하는 기능으로, 데이터 구조를 눈으로 확인하고 디버깅을 빠르게 하기 위한 도구.[^13_2][^13_1]
- **바이너리 데이터(Binary Data) Pin 제한**
이미지·영상 등 바이너리 데이터는 Pin 시 워크플로우 파일이 비대해지고 브라우저가 멈출 수 있어, n8n이 Pin Data를 의도적으로 막아둔다는 제약 설명.[^13_2][^13_1]
- **JSON Parse Error**
API 응답이 올바른 JSON 형식이 아닐 때 발생하는 오류 유형.[^13_1]
- **Expression Error**
수식(Expression)에 오타가 있거나, 존재하지 않는 변수를 참조할 때 발생하는 오류 유형.[^13_1]

***

## 4. 시각화 관련 개념

- **워크플로우 시각화(Mermaid)**
Mermaid 문법을 사용해 “트리거 → HTTP Request → AI 요약 → Slack 전송”과 같은 워크플로우 구조를 다이어그램으로 표현해, 전체 흐름을 한눈에 이해하도록 돕는 방식.[^13_1]
<span style="display:none">[^13_10][^13_11][^13_12][^13_13][^13_14][^13_15][^13_16][^13_17][^13_3][^13_4][^13_5][^13_6][^13_7][^13_8][^13_9]</span>

<div align="center">⁂</div>

[^13_1]: https://wikidocs.net/290941

[^13_2]: https://docs.n8n.io/data/data-pinning/

[^13_3]: https://wikidocs.net/290882

[^13_4]: https://wikidocs.net/290949

[^13_5]: https://namu.wiki/w/n8n

[^13_6]: https://observerlife.tistory.com/166

[^13_7]: https://www.hostinger.com/kr/tutorials/what-is-n8n

[^13_8]: https://n8n-docs.teamlab.info/data/data-pinning/

[^13_9]: https://dev-momo.tistory.com/entry/n8n을-이용하여-워크플로우-자동화-하기

[^13_10]: https://healigen.org/n8n-node-types-features-guide/

[^13_11]: https://www.youtube.com/watch?v=oixGnHydeSM

[^13_12]: https://www.youtube.com/watch?v=BQ8RXgW4hiI

[^13_13]: https://www.werun.kr/2024/12/n8n-5.html

[^13_14]: https://velog.io/@heyggun/n8n-n8n-용어-및-기초-실행-결과-확인-workflow-디버깅-및-pin-기능

[^13_15]: https://www.youtube.com/watch?v=W-S9g1VKyLA

[^13_16]: https://community.n8n.io/t/how-to-save-pin-data-between-executions/24298

[^13_17]: https://rupijun.tistory.com/entry/n8n-데이터-타입-처리-멀티모달-데이터-통합-자동화-플랫폼


---

# 트리거 노드와 일반 노드 차이점 상세 설명하기

트리거 노드와 일반 노드는 **“언제·어떻게 자동화를 시작하느냐” vs “무엇을 수행하느냐”**에서 역할이 완전히 다릅니다.[^14_1][^14_2]

***

## 1. 역할과 위치의 차이

- **트리거 노드(Trigger Nodes)**
    - 워크플로우의 **시작점**입니다.
    - 특정 이벤트·시간·조건이 발생했을 때 “지금부터 이 워크플로우를 실행해라”라는 신호를 보냅니다.[^14_3][^14_2]
    - 항상 흐름의 맨 앞에 위치하며, 하나의 워크플로우에 여러 트리거를 둘 수도 있지만, 한 번 실행될 때는 하나의 트리거만 실제로 발화합니다.[^14_1]
- **일반 노드(Regular Nodes)**
    - 트리거 이후에 **실제 작업을 수행하는 단계**입니다.
    - 데이터를 가져오고, 변환하고, 외부 서비스로 보내고, 분기·병합 등을 처리합니다.[^14_4][^14_2]
    - 워크플로우 중간·후반에 자유롭게 여러 개 배치될 수 있습니다.

***

## 2. 실행 방식과 입력 데이터

- **트리거 노드**
    - 외부 이벤트(웹훅 호출, Gmail 새 메일, Stripe 결제 등)나 내부 일정(Schedule), 수동 클릭(Manual Trigger) 같은 **조건을 계속 감시**합니다.[^14_5][^14_6]
    - 조건이 충족되면, 해당 이벤트로부터 받은 데이터를 “초기 입력 데이터”로 만들어 워크플로우에 공급합니다.[^14_1]
    - 일부 트리거(Manual Trigger)는 별도 데이터 없이 “실행만 시작”하기도 합니다.[^14_5]
- **일반 노드**
    - 항상 **이전 노드의 출력(JSON 데이터)**을 입력으로 받아 처리합니다.[^14_2]
    - 이 입력을 기반으로 API 호출, DB 작업, 텍스트 변환, 파일 처리 등 실제 업무 로직을 수행하고, 그 결과를 다음 노드로 넘깁니다.[^14_4]

***

## 3. 구성·설정 관점 차이

- **트리거 노드 설정**
    - “언제/무엇을 감지할 것인가”가 핵심입니다. 예:[^14_6][^14_3]
        - Schedule: 매일 09:00, 5분마다 등 주기 설정
        - Webhook: URL 경로, 메소드, 인증 방식 설정
        - 앱 트리거(Gmail, Slack 등): 어떤 이벤트(새 메일, 새 메시지)를 감지할지 선택
    - 트리거는 **실행 빈도·타이밍·실시간성**을 좌우하는, 워크플로우 수준의 스케줄러/리스너입니다.[^14_7]
- **일반 노드 설정**
    - “무엇을 할 것인가”가 핵심입니다. 예:[^14_2][^14_4]
        - HTTP Request: URL, 메소드, 헤더, 바디
        - Google Sheets: 어느 시트에 어떤 열을 쓰거나 읽을지
        - OpenAI/AI 노드: 프롬프트, 모델, 파라미터
    - 같은 워크플로우에서도 여러 일반 노드를 조합해, 데이터 파이프라인과 비즈니스 로직을 세밀하게 설계합니다.[^14_4]

***

## 4. 아이콘·구조·제한의 차이

- **트리거 노드 특징**[^14_8][^14_2]
    - 보통 번개나 특수 아이콘으로 표시, “Trigger” 카테고리로 분류.
    - 출력 브랜치만 있고, 다른 노드의 뒤에 올 수 없습니다(항상 시작점).
    - 워크플로우가 Active 상태여야 실제로 자동 감지·실행됩니다.
- **일반 노드 특징**[^14_2][^14_4]
    - 여러 입력/출력 브랜치를 가질 수 있고, 트리거 뒤 어디에나 배치 가능.
    - 워크플로우 내부에서 자유롭게 연결·분기·병합·반복 구조를 만들 수 있습니다.

***

## 5. 비유로 보는 차이

- 트리거 노드:
    - “파란 불이 켜지는 순간을 감시하는 신호등” 또는 “알람 시계” 역할.
    - 신호가 켜져야 차(워크플로우)가 출발합니다.[^14_6][^14_7]
- 일반 노드:
    - 신호가 켜진 뒤, 도로를 달리며 “어디로 가고, 무엇을 하고, 어떤 경로로 돌아올지”를 결정하는 **각 구간·작업자**입니다.[^14_4][^14_2]

요약하면, **트리거 노드는 ‘언제/무슨 이벤트에서’ 자동화를 시작할지 결정하는 출발점**, **일반 노드는 그 이후 실제 업무를 처리하는 실행 단계**입니다. 둘을 구분해서 설계해야 워크플로우 구조가 명확해지고, 디버깅도 훨씬 쉬워집니다.[^14_1][^14_2]
<span style="display:none">[^14_10][^14_11][^14_12][^14_13][^14_14][^14_15][^14_16][^14_17][^14_18][^14_19][^14_20][^14_9]</span>

<div align="center">⁂</div>

[^14_1]: https://docs.n8n.io/integrations/creating-nodes/plan/node-types/

[^14_2]: https://wikidocs.net/290941

[^14_3]: https://wikidocs.net/291035

[^14_4]: https://automategeniushub.com/introduction-to-n8n-nodes/

[^14_5]: https://automategeniushub.com/guide-to-n8n-trigger-nodes/

[^14_6]: https://gabrielwithappy.github.io/book_blog/posts/2025-05-16-n8n/part2/about_trigger.html

[^14_7]: https://anehe.com/10

[^14_8]: https://toyourlight.tistory.com/150

[^14_9]: https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.n8ntrigger/

[^14_10]: https://www.youtube.com/watch?v=zieOwVaYe1E

[^14_11]: https://wikidocs.net/290977

[^14_12]: https://deepwiki.com/n8n-io/n8n-docs/3.3-core-and-trigger-nodes

[^14_13]: https://monopaper.tistory.com/4

[^14_14]: https://codefinity.com/courses/v2/508f89fc-4a9c-489a-9a42-91a84d72138f/e7ab30e1-2e69-41f0-81e8-83617fb41416/5a41563b-317f-4566-a380-077367bd73d1

[^14_15]: https://blog.naver.com/eziya76/223038806560

[^14_16]: https://www.youtube.com/watch?v=BTtRfPZ3HAk

[^14_17]: https://www.technology.dimins.com/online-help/workbench_help/Content/Production/trigger-process-node.html

[^14_18]: https://www.youtube.com/watch?v=eJhn4iHOvdM

[^14_19]: https://rasino.tistory.com/m/entry/【Node-RED-⑤】노드-레드-핵심노드-설명-4편-Core-Node-Description-4

[^14_20]: https://www.youtube.com/watch?v=2mjhtMKljB0


---

# 일반 노드의 실행 순서와 오류 처리 방법 알려줘

일반 노드의 실행 순서와 오류 처리는 “연결 구조에 따른 기본 규칙 + 에러 발생 시 흐름을 어디로 보낼지 설계하는 패턴”으로 이해하면 됩니다.[^15_1][^15_2]

***

## 1. 일반 노드 실행 순서

### 1) 기본 실행 원칙

- **순차 실행**:
하나의 경로에서 노드들이 선으로 연결되어 있으면, **위에서 아래로 연결된 순서대로** 실행됩니다.[^15_2]
예: `Trigger → A → B → C`
    - Trigger가 데이터 생성
    - A가 실행되고 출력 생성
    - B는 A의 출력을 입력으로 받아 실행
    - C는 B의 출력을 입력으로 받아 실행
- **병렬 실행**:
하나의 노드에서 여러 분기(예: 두 개의 출력)로 나뉘면, **각 분기 경로는 병렬로 실행**됩니다.[^15_2]
예: `A → (B1, B2)`
    - A가 끝나면 B1과 B2가 각각 동시에(논리적 병렬) 돌아갑니다.
- **모든 입력 대기**:
Merge 등 **여러 입력을 받는 노드**는, 연결된 모든 상위 노드의 실행이 끝날 때까지 대기했다가 실행합니다.[^15_2]
예: `B1 → C ← B2`
    - C는 B1, B2 둘 다 완료된 후 실행.


### 2) 실행 순서 제어 방법

- **명시적 연결**:
어떤 노드 뒤에 무엇이 올지 선으로 직접 연결하는 것이 가장 기본적인 순서 제어입니다.[^15_3][^15_2]
- **Wait/Delay 노드 활용**:
특정 시간만큼 대기하거나, 조건이 충족될 때까지 기다렸다가 다음 노드를 실행하도록 할 수 있습니다.[^15_4][^15_2]
- **Merge·Split 노드 활용**:
여러 경로로 나눈 뒤 다시 모아야 할 때, Merge 노드를 사용해 “이 노드들 모두 끝난 다음 이 다음 노드 실행” 같은 동기화를 걸 수 있습니다.[^15_2]

***

## 2. 일반 노드 오류 처리 방법

오류 처리는 크게 **노드 수준 처리**와 **워크플로우 수준 처리(전역 에러 핸들링)**로 나뉩니다.[^15_5][^15_1]

### 1) 노드 수준 오류 처리

각 일반 노드에는 “이 노드에서 문제가 났을 때 어떻게 할 것인가”를 제어하는 옵션과 패턴이 있습니다.

- **기본 동작: 실패 시 워크플로우 중단**
    - 노드에서 에러가 발생하면, 기본 설정에서는 그 시점에서 해당 실행이 실패 상태로 종료됩니다.[^15_1]
    - 이때 실행 기록(Executions)에 빨간색으로 표시되고, 마지막 실행 노드·에러 메시지가 저장됩니다.[^15_3]
- **Continue on Fail**
    - 많은 노드의 Settings에 “Continue on Fail” 옵션이 있습니다.
    - 활성화하면, **노드가 실패해도 워크플로우 전체를 멈추지 않고 다음 노드로 진행**합니다.[^15_6]
    - 실패 정보는 `$json.error` 등으로 내려보내서 이후 IF/Switch 노드로 분기 처리(로그, 대체 경로 등)할 수 있습니다.[^15_7][^15_6]
- **Retry on Fail (재시도 설정)**
    - 노드 Settings의 “Retry on Fail”에서 재시도 횟수와 대기 시간(ms)을 설정해, 일시적인 네트워크·서버 오류에 자동으로 재시도할 수 있습니다.[^15_5]
    - 예:
        - Max Tries: 3–5
        - Wait Between Tries: 5000–10000ms
- **Stop and Error 노드 사용**
    - 의도적으로 “여기서 실행을 실패시키고 싶다”는 경우, IF 등으로 조건을 체크한 뒤 **Stop and Error** 노드를 연결하면, 커스텀 메시지를 포함하여 강제로 워크플로우 실패를 발생시킬 수 있습니다.[^15_8][^15_1]
    - 이 노드는 해당 브랜치의 마지막에만 둘 수 있고, 이후 노드를 연결할 수 없습니다.[^15_8]


### 2) 워크플로우 수준 오류 처리(전역)

- **Error Trigger 워크플로우**
    - 별도의 “에러 처리 전용 워크플로우”를 만들고, 첫 노드로 **Error Trigger**를 배치하면, 연결된 다른 워크플로우에서 실패가 발생했을 때 자동으로 이 에러 워크플로우가 실행됩니다.[^15_9][^15_1][^15_5]
    - 여기서 할 수 있는 일:
        - Slack/Email 등 알림 전송
        - 에러 로그를 Sheets/DB/Notion 등에 기록
        - 필요한 경우, 원래 워크플로우 재시도 로직 구현
- **Try–Catch 패턴(분기 기반)**
    - 위험 구간(예: 외부 API 호출들)을 하나의 블록으로 묶고, 실패 시 다른 경로(IF/Switch)로 보내서 로컬하게 처리하는 패턴입니다.[^15_6][^15_7]
    - 예:
        - 성공 경로: 다음 정상 처리 로직으로 진행
        - 실패 경로: 에러 상세 로그 저장 + 운영자 알림 + 대체 API 호출

***

## 3. 실무용 요약 패턴

일반 노드 실행·에러 처리 설계를 간단한 규칙으로 요약하면:

1. **실행 순서**
    - “선이 이어진 순서대로 + 분기된 것은 병렬 + Merge는 모두 끝난 뒤”라는 기본 룰을 기준으로 설계합니다.[^15_2]
2. **노드 설정**
    - 중요한 외부 API 노드에는 `Retry on Fail`을 켜고, 재시도 횟수/대기 시간을 설정합니다.[^15_5]
    - 반복 처리 루프에서 일부 실패가 전체를 막지 않도록 `Continue on Fail`을 적절히 사용합니다.[^15_6]
3. **분기 기반 에러 처리**
    - 실패한 노드에서 내려오는 에러 정보를 IF/Switch로 체크해,
        - 정상 데이터 경로
        - 에러 처리 경로(로그·알림·대체 동작)
를 분리합니다.[^15_7][^15_6]
4. **전역 에러 워크플로우**
    - 운영 환경에서는 항상 Error Trigger 기반 글로벌 에러 워크플로우를 하나 두고, 모든 주요 워크플로우에 연결해 두는 것이 안정적입니다.[^15_10][^15_9][^15_5]

이 구조로 설계하면, 일반 노드가 “어떤 순서로 실행되고, 어디서 에러가 나더라도 어떻게 처리할지”가 명확해져, 장애를 예측 가능한 형태로 관리할 수 있습니다.[^15_1][^15_2]
<span style="display:none">[^15_11][^15_12][^15_13][^15_14][^15_15][^15_16][^15_17][^15_18][^15_19][^15_20]</span>

<div align="center">⁂</div>

[^15_1]: https://docs.n8n.io/flow-logic/error-handling/

[^15_2]: https://wikidocs.net/302246

[^15_3]: https://wikidocs.net/290941

[^15_4]: https://wikidocs.net/291033

[^15_5]: https://iimagined.ai/blog/n8n-error-handling

[^15_6]: https://mainly.nz/n8n-error-handling-best-practices/

[^15_7]: https://www.aifire.co/p/5-n8n-error-handling-techniques-for-a-resilient-automation-workflow

[^15_8]: https://logicworkflow.com/nodes/stop-and-error-node/

[^15_9]: https://www.linkedin.com/posts/s-naresh-kumar-745322211_n8n-workflowautomation-errorhandling-activity-7378252984910204928-wveK

[^15_10]: https://www.youtube.com/watch?v=bTF3tACqPRU

[^15_11]: https://community.n8n.io/t/workflow-nodes-execution-order/13546

[^15_12]: https://www.youtube.com/watch?v=XEUVl3bbMhI

[^15_13]: https://www.youtube.com/watch?v=mOqXIc7iJmQ

[^15_14]: https://wikidocs.net/290979

[^15_15]: https://community.n8n.io/t/best-practice-for-workflow-error-handling/136458

[^15_16]: https://www.youtube.com/watch?v=x6dJiPn4UsM

[^15_17]: https://n8n-tutorial.com/tutorials/n8n/error-handling-and-debugging/n8n-error-handling-best-practices/

[^15_18]: https://www.reddit.com/r/n8n/comments/1md5l8z/how_do_you_handle_the_errors_in_the_workflow/

[^15_19]: https://www.youtube.com/watch?v=m8axLIrruI8

[^15_20]: https://www.reddit.com/r/n8n/comments/1lpqwtq/use_this_super_simple_node_to_to_do_error_handling/


---

# No-Code AI 오케스트레이션: Google Opal기술 백서 (Whitepaper)

[keonwoo Park ](https://www.linkedin.com/in/keonwoo-park-323552148/)
Think different, embrace complexity, and always think more.
2025년 9월 15일
No-Code AI Mini-App Orchestration: Prompt-to-Graph 컴파일러, 런타임, 거버넌스, 엔터프라이즈 통합 전략
문서 목적

Opal의 제품 정의와 사실을 공신력 있는 출처로 명확화
내부 동작을 아키텍처 관점에서 구조화(공개 정보 + 합리적 가설)
대규모 조직(Enterprise)이 요구하는 보안·컴플라이언스·SLO/SLI 프레임 제시
운영 난제/리스크와 완화책, 엔터프라이즈 통합 패턴 및 로드맵 제안

1. Executive Summary (요약)

Opal의 본질: 자연어 설명을 받아 시각적 워크플로우(미니-앱) 로 변환하고, 대화형 명령과 비주얼 에디터를 혼용해 코드 없이(no-code) 멀티-스텝 AI 앱을 만들고 공유·리믹스할 수 있게 하는 Google Labs의 실험 도구입니다. 미국 퍼블릭 베타로 제공되며, 자연어→시각 플로우 번역과 공유/리믹스가 공식적으로 확인됩니다. [InfoWorld+3Google Developers Blog+](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)[3opal.withgoogle.com](http://3opal.withgoogle.com/)[+3](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
포지셔닝: Zapier/Make 같은 자동화 툴의 “연결성”과 LLM의 “의도 추론”을 접합한 Prompt-to-Workflow(PTW) 계열. TechCrunch는 이를 “vibe-coding” 트렌드의 한 축으로 설명합니다. [TechCrunch](https://techcrunch.com/2025/07/25/google-is-testing-a-vibe-coding-app-called-opal/?utm_source=chatgpt.com)
핵심 가치: 비개발자(마케터/CS/운영/기획)도 아이디어→실행 가능한 미니앱을 수분 내에 전환. 빠른 실험·내부 확산에 최적. [Google Developers Blog+1](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
한계(베타 기준): 지역(미국) 제한, 깊은 외부 시스템/DB 통합 범위 미확정, 복잡 로직/실시간 스트림·규제 환경에서의 운영 가이드 미공개. (공개 보도 및 베타 성격에 근거) [InfoQ+1](https://www.infoq.com/news/2025/07/google-opal-ai/?utm_source=chatgpt.com)

2. 제품 팩트 체크 (Facts)

제품 정의(공식): “자연어로 설명하고, 비주얼 워크플로우로 편집하며, 미니-AI 앱을 만들고 공유/리믹스 할 수 있다.” 구글 개발자 블로그와 랜딩 페이지가 명시. [Google Developers Blog+1](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
상태/범위(보도 일치): 미국 퍼블릭 베타. 자연어 명령과 시각 에디터를 혼합해 멀티-스텝 앱(프롬프트·모델·툴 체인)을 만든다. [InfoWorld+2InfoQ+2](https://www.infoworld.com/article/4028370/google-labs-introduces-opal-for-developing-ai-mini-apps.html?utm_source=chatgpt.com)
사용성 메시지(공식·영상): “코드 없이 동적 멀티-스텝 미니앱을 만든다.” “설명만 하면 Opal이 시각 워크플로우로 번역.” 구글 개발자 공식 영상에서도 소개. [유튜브+1](https://www.youtube.com/watch?v=E0hrcDO3Noc&utm_source=chatgpt.com)
‘Vibe-Coding’ 맥락(보도): 텍스트 설명만으로 앱 뼈대를 일으키는 흐름. [TechCrunch](https://techcrunch.com/2025/07/25/google-is-testing-a-vibe-coding-app-called-opal/?utm_source=chatgpt.com)

3. 시스템 아키텍처 개요 (개념 모델)
주의: 아래는 공개 UX와 일반적 LLM 오케스트레이션 패턴을 합쳐 도출한 합리적 가설입니다. (내부 소스/코드는 비공개)
3.1 계층 구조(개념)

Presentation/UX: 대시보드, 템플릿 갤러리, 자연어 입력 UI, 비주얼 워크플로우 에디터
Prompt-to-Graph(PTG) 컴파일러: 자연어에서 행위/대상/조건을 추출해 그래프(노드/엣지/가드) 로 변환
Model Invocation Layer: LLM·요약/분류/추출/생성 모델과 외부 툴 호출, 프롬프트 체이닝
Runtime Orchestrator: 트리거/태스크 실행, 분기·루프, 재시도/타임아웃/폴백, 관찰성
Control Plane: 버전 이력/롤백, 권한/공유, 리뷰/주석, 템플릿 저장소
Security \& Compliance: 인증/인가, 데이터 경계·마스킹, 감사 로그, 정책 엔진
Infra: GCP 상 서버리스/컨테이너, 모델 서빙, 오토스케일, 리전 분산(지연 최소화)

3.2 데이터 흐름(간결 다이어그램)

사용자 자연어 의도 → PTG 컴파일러(의도 파싱/스키마 귀납/그래프 합성) → 비주얼 편집(분기/가드/변수) → 오케스트레이터(트리거→태스크 체인) → 모델/툴 호출 → 결과 집계 → UI 출력/알림/저장 → 공유·리믹스/버전화

4. Prompt-to-Graph(PTG) 컴파일러 (핵심 가설)
4.1 단계별 파이프라인

의도 파싱: 행위(요약/분류/전송), 대상(메일/슬랙/시트), 제약(조건/검증) 추출
스키마 귀납: 입력/출력 타입(텍스트/객체)과 필수 필드 유도
그래프 합성: 이벤트(트리거)→변환(LLM)→전달(슬랙/시트) 노드 연결
가드 삽입: 무한 루프/모순 조건 방지, 권한/토큰 누수 방지
타입 검사: 노드 간 I/O 계약(Contract) 정합성 검증
양방향 정제: 비주얼 에디터 수정 ↔ 자연어 리프레이징 동기화

4.2 내부 표현(Intermediate Representation, 추정)

외부에 노출되지 않는 간단한 DSL/IR 로 그래프를 표준화:

이 수준의 IR/DSL이 존재할 가능성은 비주얼 그래프의 재현성/감사/롤백을 위해 매우 높습니다. (일반적 오케스트레이션 설계 원칙)
5. Model Invocation Layer (호출·체이닝)
5.1 설계 목표

안전·추적 가능성: 어떤 입력이 어떤 모델로, 어떤 설정으로 갔는지 재현
비용·지연 최적화: 캐시/샘플링/사전 요약으로 토큰·호출 비용 절감
실패 복원력: 재시도/백오프/폴백 모델·단축 경로

5.2 호출 정책(권장)

민감 데이터(PII/저작권/규제)는 옵트-인 게이트와 마스킹/블라인딩 적용 후 호출
컨텍스트 구조화: JSON/키-밸류로 이전 노드 결과를 명시 전달(디버그·감사 용이)
관찰성: 노드/사용자/워크플로우 단위로 지연(ms), 오류율(%), 토큰비용 모니터링

5.3 모델 선택(팩트 \& 추정)

Opal이 내부적으로 Google 모델을 호출한다는 설명은 주요 보도에 반복되나, 정확한 SKU/옵션은 비공개입니다. 엔터프라이즈 설계에선 모델 불가지론(agnostic) 을 유지하고, SLI/비용 기준으로 동적 선택하는 접근이 현실적입니다. [TechCrunch+1](https://techcrunch.com/2025/07/25/google-is-testing-a-vibe-coding-app-called-opal/?utm_source=chatgpt.com)

6. Runtime Orchestrator (런타임 오케스트레이션)
6.1 책임

트리거 관리(메일/웹훅/스케줄), 분기·루프, 예외 처리, 리트라이, 상태 관리(필요 시), 멱등성 보장

6.2 실패 시나리오와 방어책

외부 API 타임아웃 → 재시도/서킷 브레이커/폴백
모델 품질 저하 → 사후 검증(형식/길이/금칙 패턴), 휴먼 승인 루프
비용 폭주 → 호출 상한/샘플링/요약 전처리/캐시
순환 참조/루프 → 정적 분석 + 런타임 감시(루프 가드)

7. Control Plane (버전/권한/협업/배포)
7.1 버전 이력 \& 롤백

워크플로우 변경 시 스냅샷 저장, 브랜치-머지, 이전 버전 즉시 복귀

7.2 권한·공유

읽기/편집/배포 권한 분리
팀/조직 템플릿 저장소, 외부 공유 링크 만료/도메인 제한

7.3 리뷰/승인(엔터프라이즈 권장)

민감 데이터/외부 전송 포함 플로우는 사전 승인 경유
코멘트/주석/변경 요청 워크플로우

공유/리믹스는 Opal의 핵심 UX 요소이므로, 조직 도입 시 거버넌스 레일을 반드시 설정해야 합니다. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
8. 입력/출력 UX, 유스케이스, 도입 로드맵
8.1 입력/출력 요약

입력: 자연어 프롬프트 + 비주얼 에디터(노드 추가/삭제/분기/가드/변수)
출력: 미니-앱(UI+액션), 자동화(알림/저장/연동), 공유 링크

8.2 대표 유스케이스

마케팅: 신제품 자료 요약→채널별 포스트 초안→캘린더 알림
CS: 신규 티켓 요약→우선순위 분류→응답 초안→담당자 통지
운영/지식관리: 회의록 요약→TODO 추출→Jira/Sheets 업데이트
교육: 강의자료 요약→퀴즈 생성→성과 리포트

8.3 6–8주 파일럿 로드맵(권장)

1–2주: 파일럿 과제·KPI 확정(지연/성공률/비용/만족도/ROI)
3–4주: 템플릿 구축·권한/승인 규정·금칙 프롬프트 수립
5–6주: A/B 가드레일(보수/공격형 설정), 비용/지연 최적화
7–8주: 결과 평가·확대 적용/보류 결정

9. 보안·프라이버시·컴플라이언스
9.1 데이터 경계

입력 데이터 마스킹/토큰화(PII/고객기밀), 전송/저장 암호화(TLS/at-rest)
데이터 보존/삭제 SLA, 지역성(데이터 레지던시) 명시

9.2 인증/인가

SSO, RBAC(역할 기반), 시크릿 별도 보관(Secret Manager), 시크릿 로깅 금지

9.3 감사 가능성(Auditability)

“누가/언제/무엇을 호출/공유/배포”를 전면 로깅
규제 도메인(금융/헬스/공공)은 사전 승인 + 사후 감사 조합

9.4 콘텐츠 책임

자동 발행 금지, 휴먼-인-더-루프 승인
저작권/출처 표기, 허위 가능성 경고, 편향 점검

Opal 고유 보안 백서는 공개되지 않았지만, 상기 항목은 엔터프라이즈 LLM 오케스트레이션의 표준 요구 사항입니다. 구글의 공식 정의는 “자연어→시각 플로우·공유/리믹스”에 초점이며, 보안/규제 구현은 조직 정책과 결합해 설계해야 합니다. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
10. 성능·SLO/SLI·FinOps
10.1 핵심 SLI(예시)

워크플로우 생성 지연(초), 에디터 반응(밀리초), 태스크 성공률(%), 모델 호출 에러율(%), 평균 토큰/호출 비용

10.2 초기 SLO(권장)

95% 워크플로우 생성 ≤ 2초, 태스크 성공률 ≥ 99.0%, 월간 가용성 ≥ 99.9%

10.3 최적화 전술

프롬프트 컴파일 캐시, 템플릿 사전 컴파일, 히트 노드 프리로딩
사전 요약/샘플링으로 토큰 절감, 결과 캐시 재사용
재시도 지수 백오프/서킷 브레이커/폴백 경로
리전 분산/오토스케일/샤딩으로 지연 단축

10.4 FinOps

호출/토큰 비용 대시보드, 상한(Quota)·알람, 비용/품질 트레이드오프 가시화
분기별 비용-효율 개선 목표(예: -15%)

11. 엔터프라이즈 통합 패턴
패턴 A) 하이브리드 브리지

Opal은 오케스트레이션 레이어로, 민감 연산/심층 로직은 사내 백엔드에서 처리
Webhook/API Gateway로 상호 연동, 데이터는 최소 필요 항목만 교환

패턴 B) Workspace-First 통합

Docs/Sheets/Drive와 기본 연계(요약→보고서→시트 기록→승인 메일)
Google 계정/조직 정책과 자연호환

패턴 C) Vertex/에이전트 증강(가설)

Vertex AI/에이전트와 결합해 고성능 모델 선택/평가/룰 엔진/도메인 메모리 결합

12. 경쟁 지형 분석(요약)

Microsoft Power Platform/Copilot Studio: 엔터프라이즈 데이터·거버넌스 강력, 자연어→자동 그래프화는 제한적
Zapier/Make/n8n: 외부 연동 성숙, LLM 의존 워크플로우는 사용자가 손수 구성하는 편
Bubble/Glide/Lovable: 완성형 앱·UI 자유도 높음, 대신 학습/설정 복잡
Runway/Gemini Agents Apps: 멀티모달 생성·편집 강점, 업무 자동화·미니앱은 별도 설계 필요
Opal의 자리: “의도→플로우 자동화” 에 최적, 빠른 실험·공유/리믹스 강점, 거버넌스/깊은 통합은 단계적 보완 대상 (공식/주요 보도 종합) [TechCrunch+3InfoWorld+3InfoQ+3](https://www.infoworld.com/article/4028370/google-labs-introduces-opal-for-developing-ai-mini-apps.html?utm_source=chatgpt.com)

13. 알려진 제약/리스크와 완화책

지역 제한(미국 베타) → 한국/글로벌 조직은 프록시 파일럿(미국 계정/파트너 경유)로 학습, 본격 롤아웃 대비 문서화. [InfoQ](https://www.infoq.com/news/2025/07/google-opal-ai/?utm_source=chatgpt.com)
깊은 API/DB 통합: 코드 내보내기/커스텀 백엔드는 제한 가능성 → 하이브리드 패턴으로 게이트웨이 배치, 민감 연산 내부화. [InfoWorld](https://www.infoworld.com/article/4028370/google-labs-announces-opal-for-developing-ai-mini-apps.html?utm_source=chatgpt.com)
LLM 예측 불가성: 복잡 프롬프트/모순 조건에서 품질 변동 → 사전/사후 검증·휴먼 승인·A/B 가드레일
비용 통제: 사용 폭증 시 토큰/호출 급증 → 상한·경보·캐시/요약·배치 처리

14. 로드맵/연구 과제(가설)

코드 내보내기/외부 DB 커넥터/마켓플레이스: 생태계 확대의 분수령
고급 제어 패널: 정확도/톤/비용/지연 슬라이더, 테스트·검증 탭
멀티모달 플로우: 이미지/오디오/비디오 노드
네이티브 에이전트: 메일/캘린더/문서를 능동 추적해 자동 트리거
정량 품질 지표 공개: 요약 정확도/지연 분포/오류율 투명화

15. 결론 및 경영진 권고

결론: Opal은 자연어→시각 플로우→즉시 실행이라는 생산성 곡선을 현실로 만든 도구입니다. 비개발자 혁신을 촉진하는 촉매지만, 베타 단계 특성상 깊은 통합/규제/감사/SLA 는 보수적으로 설계해야 합니다. (공식/주요 보도 근거) [Google Developers Blog+1](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
경영진 권고 5가지

6–8주 파일럿로 실제 업무에서 ROI 검증
템플릿 저장소/금칙 프롬프트/승인 워크플로우로 거버넌스 제도화
AIOps/FinOps 계측(지연/성공률/비용/품질) 상시 모니터링
Workspace/Vertex/사내 서비스 단계적 연동
휴먼-인-더-루프 승인으로 책임/신뢰 확보

\#구글오팔 \#GoogleOpal \#노코드AI \#프롬프트자동화 \#시각워크플로우 \#미니앱 \#AI오케스트레이션 \#LLM체이닝 \#업무자동화 \#엔터프라이즈AI \#AI거버넌스 \#AIOps \#FinOps \#VertexAI \#GoogleWorkspace \#AI프로토타이핑

No-Code AI Orchestration: Google Opal Technical White Paper
No-Code AI Mini-Apps from Prompt-to-Workflow: Architecture, Operations, Security, and Enterprise Integration
Executive Summary
What Opal is (fact). Opal is a new Google Labs experiment that lets users build, edit, and share mini-AI apps using natural language, translating plain-English descriptions into visual, multi-step workflows that chain prompts, Google models, and tools—no code required. It also offers a template gallery and remix/sharing features. [opal.withgoogle.com+1](https://opal.withgoogle.com/?utm_source=chatgpt.com)
Status \& scope (fact). Opal is currently available as a U.S. public beta via Google Labs. Coverage across TechCrunch, InfoWorld, and InfoQ consistently describes Opal as a no-code, prompt-to-workflow builder for “AI mini apps,” sometimes framed as part of a broader “vibe-coding” trend: describing what you want and letting the system scaffold the app. [TechCrunch+2InfoWorld+2](https://techcrunch.com/2025/07/25/google-is-testing-a-vibe-coding-app-called-opal/?utm_source=chatgpt.com)
Why it matters (analysis). Opal compresses the distance between intent and implementation: non-technical users can go from idea to a working automation in minutes. For enterprises, Opal is a high-leverage layer for rapid experimentation and internal diffusion of AI workflows—provided it’s paired with appropriate governance, security, and integration guardrails.

1) Fact Baseline

Product definition. Describe the mini-app you want; Opal converts it into a visual workflow; you can refine it either by conversational edits or via the visual editor; then share or remix it. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
Access. Public beta, U.S. only (at launch) through Google Labs; sign-in with Google. [TechCrunch+2InfoWorld+2](https://techcrunch.com/2025/07/25/google-is-testing-a-vibe-coding-app-called-opal/?utm_source=chatgpt.com)
Core features. Natural-language app authoring, template gallery for starter mini-apps, remix capability, and multi-step chaining of prompts, models, and tools. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
Positioning. A no-code prompt-to-workflow builder; media characterize it as “vibe-coding” (intent-first app creation). [TechCrunch](https://techcrunch.com/2025/07/25/google-is-testing-a-vibe-coding-app-called-opal/?utm_source=chatgpt.com)

From here on, where the internal design is not yet publicly documented, we label it “inference/hypothesis,” based on established orchestration patterns that would produce the behavior Opal demonstrates.
2) System Architecture (Outside-In → Inside-Out)
2.1 User-Visible Flow (fact)

User describes a goal in natural language.
Opal composes a multi-step, visual workflow (nodes/edges/conditions).
User iterates: adjust steps, prompts, branches, and outputs in the visual editor—or keep talking to revise.
The mini-app is run, shared, or remixed. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)

2.2 Layered Architecture (inference/hypothesis)
Likely layers to realize the above UX:

Presentation / UX: Dashboard, Template Gallery, Conversational UI, Visual Workflow Editor.
Prompt-to-Graph Compiler (PTG): Extracts actions/targets/constraints from text and compiles them to a typed graph of tasks.
Model Invocation Layer: Chains LLM and utility tools; handles context passing, retries, fallbacks, and cost controls.
Runtime Orchestrator: Executes triggers, branching, and loops; manages exceptions and idempotency; emits logs/metrics.
Control Plane: Version history, rollback, permissions, sharing/remix, review comments.
Security \& Compliance: AuthN/Z, data boundaries, masking, audit logs, policy engine.
Infrastructure: Google Cloud serverless/containers, model serving, autoscale, multi-region to reduce latency.

2.3 End-to-End Dataflow (inference/hypothesis)

Natural-language intent → PTG compilation → visual graph
Visual refinement (branching, guards, variables)
Orchestrator runs triggers → task chain
Model/Tool calls with structured inputs/outputs
Aggregation → UI output / notification / storage
Share / Remix → Version history

3) Prompt-to-Graph (PTG) Compiler
3.1 Pipeline (inference/hypothesis)

Intent parsing: Identify actions (“summarize”), domains (“new emails”), destinations (“Slack \#marketing”), constraints (“only top-20% salient”).
Schema induction: Infer input/output types (text, objects) and required fields.
Graph synthesis: Map to nodes (trigger/transform/notify/store) and edges (data/control flow).
Guards \& constraints: Prevent infinite loops, circular dependencies, privilege leaks.
Type/contract checks: Verify the I/O contract between nodes.
Bidirectional refinement: User edits in the visual editor; the description stays in sync.

3.2 Minimal IR/DSL (conceptual, inference)
An internal, non-exposed IR (intermediate representation) increases reproducibility, debuggability, and auditability:

trigger.gmail.new_message(filter: "label:inbox")
task.llm.summarize(input: trigger.body, style: "concise", max_tokens: 512)
task.slack.post(channel: "\#marketing", text: llm.summarize.output)
task.sheets.append(spreadsheet: "CS_Daily", row: [trigger.from, llm.summarize.output, now()])
guard.if(salience >= 0.8) then proceed else drop

4) Model Invocation \& Tooling
4.1 Responsibilities (inference/hypothesis)

Structured context passing (JSON/kv) so every step is reproducible.
Resilience: timeouts, retries (exponential backoff), fallback models/paths.
FinOps: summarize/trim long inputs, cache repeat results, cap tokens/requests.
Observability: per-node latency, error rates, token cost, quality metrics.

4.2 Model choice (fact + inference)
Coverage suggests Opal uses Google models under the hood but does not enumerate SKUs. A model-agnostic plan—selecting models by SLI/cost targets—keeps options open and risk controlled. [TechCrunch](https://techcrunch.com/2025/07/25/google-is-testing-a-vibe-coding-app-called-opal/?utm_source=chatgpt.com)
5) Runtime Orchestrator
5.1 Core functions (inference/hypothesis)

Triggers: email/webhook/scheduler
Flow control: branches, loops, guards, error handling
State/idempotency: optional state when required; deduplicate repeated triggers
Metrics: success rate, latency histograms, cost per run

5.2 Failure playbook (inference/hypothesis)

External API timeout → retry + circuit breaker + fallback path
Low-quality LLM output → post-validators (format/length/content rules) + human-in-the-loop approval
Cost spikes → caps, rate limits, forced summarization, caching
Runaway loops → static/dynamic loop guards

6) Control Plane: Versioning, Access, Collaboration
6.1 Versioning (inference/hypothesis)

Snapshot on every graph change; branch/merge; instant rollback.

6.2 Access \& sharing (fact + inference)

Shareable links, remixable templates, and permission controls are part of Opal’s core story—great for innovation, but enterprises must layer scoped sharing, link expiry, and domain restrictions to prevent data leakage. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)

6.3 Review \& approval (enterprise guidance)

Pre-publish approval for flows that move sensitive data externally.
Commenting, review assignments, change requests for high-risk apps.

7) Input/Output UX, Use Cases, and Adoption
7.1 UX summary (fact)

Input: Conversational prompts or visual edits (add/delete nodes, branches, guards, variables).
Output: Runnable mini-apps; automations that notify/store/integrate; share/remix links. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)

7.2 Practical use cases (analysis)

Marketing: turn press kits into channel-specific post drafts; schedule reminders.
CS: summarize new tickets → triage → response draft → owner notification.
Ops/Knowledge: summarize meeting notes → extract TODOs → update Jira/Sheets.
L\&D: summarize lesson → generate quizzes → compile learner insights.

7.3 6–8 week pilot (enterprise playbook)

Weeks 1–2: pick two high-leverage flows; define KPIs (latency, success rate, cost, satisfaction, ROI).
Weeks 3–4: template the pattern; set permission and approval rules; define “blocked prompts/tools.”
Weeks 5–6: A/B guardrails (conservative vs. aggressive settings); tune cost/latency.
Weeks 7–8: evaluate outcomes; scale or shelve.

8) Security, Privacy, and Compliance
8.1 Data boundaries (enterprise guidance)

Mask/tokenize PII and confidential data before model calls; encrypt in transit/at rest; document retention/erasure SLAs and data residency.

8.2 AuthN/Z \& secrets (enterprise guidance)

SSO + RBAC; keep secrets in a vault; never log tokens or secrets; scope tokens minimally.

8.3 Auditability (enterprise guidance)

End-to-end audit trail: who/when/what flow ran, which data moved where, which model/tool was called with which parameters.

8.4 Content responsibility (enterprise guidance)

No auto-publish without human approval. Label and attribute generated content where required; warn on potential hallucinations or bias. Establish a process to review flagged outputs.

Opal’s public materials emphasize the no-code UX and sharing/remix; security, compliance, and audit specifics are not yet published. The above represents standard enterprise controls for LLM orchestration. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
9) Performance, SLO/SLI, and FinOps
9.1 Suggested SLIs

Workflow creation latency (s)
Editor interaction latency (ms)
Task success rate (%) and model call error rate (%)
Avg. token/req cost
User satisfaction (CSAT), iteration cycle time

9.2 Starter SLOs

P95 workflow creation ≤ 2 s; task success rate ≥ 99.0%; monthly availability ≥ 99.9%.

9.3 Optimization tactics

PTG cache; precompile hot templates; pre-warm the editor.
Summarize → call; cache frequent results; cap tokens and requests.
Backoff, breakers, fallbacks; regional endpoints and autoscale.

9.4 FinOps

Cost dashboards; quotas and alerts; quarterly goals (e.g., −15% cost/tx at equal quality).

10) Enterprise Integration Patterns
Pattern A — Hybrid Bridge (analysis)

Treat Opal as the orchestration layer; keep sensitive logic in in-house microservices behind an API gateway or webhooks.
Exchange only necessary fields across the boundary; apply masking at source.

Pattern B — Workspace-First (analysis)

Lean into Docs/Sheets/Drive for drafting, logging, and collaboration; align with the org’s Google identity and policies.

Pattern C — Vertex/Agent Augmentation (inference)

Pair Opal with Vertex AI and agent frameworks to choose models by policy (price/latency/quality), enforce domain memory, and centralize evaluation.

11) Competitive Landscape (what’s different)

Microsoft Power Platform / Copilot Studio: Strong enterprise data connectors and governance; less “type a paragraph → auto-graph your app.”
Zapier / Make / n8n: Proven automation; many connectors; LLM-heavy logic still requires more manual graph design.
Bubble / Glide / Lovable: High UI freedom for full apps; steeper learning/setup for logic + LLM chaining.
Runway / Gemini Agents Apps: Multimodal generation/edition strengths; app-scale workflow packaging is a separate design exercise.
Opal’s niche: The closest to intent → workflow with rapid experimentation and remix as first-class citizens; governance and deep integration should be layered on by the enterprise. [TechCrunch+2InfoWorld+2](https://techcrunch.com/2025/07/25/google-is-testing-a-vibe-coding-app-called-opal/?utm_source=chatgpt.com)

12) Known Constraints \& Risks (beta reality)

Geographic availability: U.S.-only at launch; global rollout TBD. [InfoWorld+1](https://www.infoworld.com/article/4028370/google-labs-introduces-opal-for-developing-ai-mini-apps.html?utm_source=chatgpt.com)
Deeper integrations: Undocumented limits around external APIs, custom backends, or code export—assume conservative capability and plan a hybrid approach. (Synthesis of early coverage.) [InfoWorld](https://www.infoworld.com/article/4028370/google-labs-introduces-opal-for-developing-ai-mini-apps.html?utm_source=chatgpt.com)
LLM unpredictability: Complex/contradictory prompts can degrade graph quality—mitigate with pre/post validators, human approval, and guardrails.

13) Roadmap \& Research Questions (inference/hypothesis)

Code export / external DB connectors / marketplace: Pivotal for ecosystem growth.
Advanced controls: Sliders for accuracy/tone/cost/latency; test \& verification tab.
Multimodal nodes: First-class image/audio/video processing.
Native agents: Proactive scanning of mail/calendar/docs to trigger flows.
Transparent quality metrics: Publish latency distributions, summarization accuracy, failure taxonomies for trust.

14) C-Suite Takeaways \& Recommendations

What Opal already changes (fact): It turns plain language into runnable, shareable workflows with a visual editor and template/remix loop, measurably compressing time-to-prototype for non-engineers. [Google Developers Blog](https://developers.googleblog.com/en/introducing-opal/?utm_source=chatgpt.com)
How to adopt safely (analysis):

Run a 6–8 week pilot in Marketing/CS/Ops with clear KPIs.
Stand up a template library and approval workflow; define blocked prompts/tools.
Instrument AIOps/FinOps (latency, success, cost, quality).
Integrate via Workspace first; bridge to internal services via gateway/webhooks.
Keep a human-in-the-loop for anything externally published or sensitive.

\#GoogleOpal \#NoCodeAI \#AIAppBuilder \#PromptToWorkflow \#VisualWorkflow \#MiniApps \#AIAutomation \#LLMOrchestration \#GoogleLabs \#EnterpriseAI \#AIGovernance \#AIOps \#FinOps \#GoogleWorkspace \#AIPrototyping

내용을 제1원칙 사고 기준으로 분해하고 심층 분석 후 상세히 설명

이 화이트페이퍼를 제1원칙 관점에서 보면, “Opal이 실제로 무엇을 하는 도구인가?”를 사실과 가설로 분리하고, 이를 기반으로 **아키텍처·운영·거버넌스·엔터프라이즈 통합 전략**까지 한 번에 설계한 문서입니다. 아래에서는 (1) 최상위 목적, (2) 핵심 전제, (3) 시스템 구조, (4) 운영·거버넌스 프레임, (5) 엔터프라이즈 의사결정 관점으로 분해해 설명합니다.[^16_1][^16_2]

***

## 1. 최상위 목적과 문제 정의

화이트페이퍼의 최상위 목적은 두 줄로 요약됩니다.[^16_3][^16_1]

- Opal이라는 도구를 **“노코드 AI 미니앱 오케스트레이터”**로 정확히 정의하고, 공신력 있는 출처(Developers Blog, TechCrunch, InfoWorld 등)로 팩트를 고정한다.[^16_2][^16_4]
- 그 위에, 아직 공개되지 않은 내부 동작을 **추론 가능한 아키텍처 모델**로 재구성하고, 엔터프라이즈가 요구하는 보안·컴플라이언스·SLO/SLI·통합 패턴을 제안한다.[^16_1]

즉 “마케팅식 소개”가 아니라, **아키텍트·CIO·보안팀이 Opal을 어디까지 믿고 어떻게 쓸지 판단할 수 있도록 하는 기준선**을 만드는 것이 문서의 본질입니다.[^16_2][^16_1]

***

## 2. 핵심 전제(제1원칙 수준의 가정)

문서 전반은 몇 가지 근본 가정을 깔고 전개됩니다.[^16_3][^16_1]

- ① Opal의 본질: **자연어 → 시각 워크플로우(그래프) → 실행 가능한 미니 AI 앱**으로 변환하는 Prompt-to-Workflow(Prompt-to-Graph) 컴파일러 + 런타임이다.[^16_2][^16_3]
- ② 타깃: 비개발자(마케터, CS, 운영, 기획)가 코드 없이 멀티스텝 AI 앱을 만들고 공유/리믹스할 수 있게 하는 도구다.[^16_5][^16_3]
- ③ 상태: Google Labs의 **실험적 US 퍼블릭 베타**, 기능은 강력하지만 SLA·심층 통합·규제 대응은 미완성이다.[^16_6][^16_2]
- ④ 엔터프라이즈 요구: 보안, 데이터 경계, 감사 가능성, SLO/SLI, FinOps, 거버넌스 없이는 대규모 조직 도입이 불가능하다.[^16_6][^16_1]
- ⑤ 따라서 “Opal을 도입할지 말지”가 아니라, **어디까지·어떻게 쓰고 무엇과 결합해야 안전한가**가 의사결정의 핵심이다.[^16_1]

이 전제를 바탕으로, 문서 전체가 “팩트 → 합리적 가설 → 엔터프라이즈 설계 가이드” 순으로 층을 쌓습니다.[^16_1][^16_2]

***

## 3. 시스템 구조: Prompt-to-Graph 오케스트레이터로 보는 Opal

### 3.1 계층 구조 (레이어 모델)

화이트페이퍼는 Opal을 아래 7개 레이어로 나눕니다.[^16_3][^16_1]

1) **Presentation / UX 레이어**

- 대시보드, 템플릿 갤러리, 자연어 대화 UI, 비주얼 워크플로우 에디터.[^16_2][^16_3]
- 사용자는 “무엇을 하고 싶은지”만 설명하면 되고, 결과는 노드/엣지 형태 그래프로 시각화됩니다.

2) **Prompt-to-Graph(PTG) 컴파일러**

- 자연어 설명에서 **행위·대상·조건**을 추출해 내부 그래프(노드/엣지/조건, 타입)로 변환하는 계층.[^16_1][^16_2]
- 역할:
    - 의도 파싱 (요약·분류·전송·저장 등)
    - 스키마 귀납 (입·출력 타입과 필드)
    - 그래프 합성 (Trigger → Transform → Notify/Store 체인)
    - 가드 삽입 (무한 루프, 권한 누수 방지)
    - 타입/컨트랙트 검사 (노드 간 I/O 정합성).[^16_1]

3) **Model Invocation Layer**

- LLM·멀티모달 모델(Gemini 계열 등)과 도구를 호출하고, 컨텍스트를 JSON/키-값 구조로 전달하며, 재시도·폴백·비용 제어를 담당합니다.[^16_3][^16_2]
- 목표: 재현성(어떤 입력이 어떤 모델 세팅으로 갔는지), 회복력, 비용/지연 최적화.[^16_1]

4) **Runtime Orchestrator**

- 트리거(메일·웹훅·스케줄) 실행, 분기/루프, 예외 처리, 재시도, 상태·멱등성, 로그/메트릭 방출을 관리하는 **실행 엔진**입니다.[^16_6][^16_1]

5) **Control Plane**

- 워크플로우 버전 이력·롤백, 권한·공유, 템플릿 저장소, 리뷰·코멘트, 승인 프로세스를 관리하는 관리 평면.[^16_3][^16_1]

6) **Security \& Compliance**

- 인증/인가(SSO·RBAC), 데이터 경계·마스킹, 감사 로그, 정책 엔진 등 엔터프라이즈 필수 보안 기능을 위치시키는 레이어(실 구현은 아직 공개 X, 설계 가이드로 제시).[^16_1]

7) **Infra 레이어**

- GCP 기반 서버리스/컨테이너, 모델 서빙, 오토스케일, 멀티리전 배포로 지연을 줄이고 가용성을 확보하는 인프라.[^16_6][^16_1]

이 구조는 “Opal = Chat UI + 그래프 에디터”가 아니라, **“Prompt-to-Graph 컴파일러 + 워크플로우 엔진 + 관리·보안 평면”을 가진 노코드 AI 플랫폼**이라는 해석입니다.[^16_2][^16_1]

### 3.2 데이터 흐름 (Intent → Graph → Run)

데이터 플로우도 제1원칙 수준으로 쪼개져 있습니다.[^16_1]

1) 사용자 자연어 의도 입력
2) PTG 컴파일러가 의도를 분석해 그래프(IR/DSL) 생성
3) 비주얼 에디터에서 노드·분기·변수·가드를 수동/대화형으로 조정
4) 런타임 오케스트레이터가 트리거를 감지해 태스크 체인을 실행
5) Model Invocation Layer가 LLM·툴을 호출, 결과를 구조화해 전달
6) 결과 집계 후 UI 출력/알림/저장(미니앱 UI, 알림, 시트/드라이브 기록 등)[^16_4][^16_3]
7) 워크플로우를 템플릿/앱으로 공유·리믹스하고, 버전 이력 관리.[^16_2]

핵심 포인트는, **모든 단계가 “타이핑된 그래프”와 “구조화된 JSON 컨텍스트”를 중심으로 연결되어야 재현성과 감사가 가능하다**는 전제입니다.[^16_1]

***

## 4. 운영·거버넌스·보안: 엔터프라이즈 도입 프레임

화이트페이퍼는 Opal을 “그대로 프로덕션 코어로 쓰라”가 아니라, **파일럿·샌드박스 + 하이브리드 통합 + 강한 거버넌스**를 전제로 합니다.[^16_6][^16_1]

### 4.1 보안·프라이버시·컴플라이언스 제1원칙

- **데이터 경계**
    - PII/기밀정보는 마스킹·토큰화 후 모델 호출, 전송·저장 시 암호화, 데이터 레지던시·보존/삭제 SLA를 명시.[^16_1]
- **인증/인가**
    - SSO, RBAC, 시크릿은 별도 Vault에 저장, 토큰·시크릿 로깅 금지, 최소 권한 원칙.[^16_3][^16_1]
- **감사 가능성**
    - “누가/언제/어떤 플로우가/어떤 데이터로/어떤 모델과 툴을 호출했는지” 전면 로깅.[^16_1]
- **콘텐츠 책임**
    - 자동 발행 금지, 항상 Human-in-the-loop 승인, 저작권·출처 표기, 허위·편향 가능성에 대한 경고 프로세스.[^16_1]

이 항목들은 Opal 고유 문서가 아니라, **일반적인 LLM 오케스트레이션 플랫폼에 적용되는 표준 엔터프라이즈 요구사항**으로 제시됩니다.[^16_6][^16_1]

### 4.2 성능·SLO/SLI·FinOps

- 제안 SLI: 워크플로우 생성 지연, 에디터 반응 속도, 태스크 성공률, 모델 호출 에러율, 호출당 평균 토큰·비용 등.[^16_1]
- 권장 SLO: P95 생성 ≤ 2초, 성공률 ≥ 99%, 월 가용성 99.9% 수준.[^16_1]
- 최적화 전략: PTG 캐시, 템플릿 사전 컴파일, 프롬프트 요약으로 토큰 절감, 캐시 재사용, 백오프/서킷 브레이커, 리전 분산·오토스케일.[^16_6][^16_1]
- FinOps: 비용 대시보드, 상한·알람, 분기별 비용/품질 트레이드오프 개선 목표(예: 분기 -15%).[^16_1]

→ 제1원칙: “Opal = SaaS 도구”가 아니라, **“비용과 성능이 측정·관리되어야 할 운영 대상 시스템”**이라는 관점입니다.

### 4.3 엔터프라이즈 통합 패턴

세 가지 패턴이 제안됩니다.[^16_1]

- **패턴 A: 하이브리드 브리지**
    - Opal은 오케스트레이션/UX 레이어로, 민감한 비즈니스 로직·데이터 처리는 사내 백엔드(Microservice, API Gateway)에서 수행.[^16_1]
    - Webhook/API Gateway로 양쪽을 연결, Opal에는 최소 필드만 보내고, 내부에서 권한·감사를 강화.
- **패턴 B: Workspace-First 통합**
    - Docs/Sheets/Drive/Gmail 중심 시나리오에 Opal을 얹어, 요약→문서/시트 업데이트→메일/승인 플로우를 빠르게 구성.[^16_7][^16_1]
    - Google 계정·조직 정책과 자연스럽게 결합하는 “내부 업무 자동화 허브” 역할.
- **패턴 C: Vertex/Agents 증강 (가설)**
    - Vertex AI 모델·평가·룰엔진·도메인 메모리를 백엔드로 두고, Opal은 상단의 UX/오케스트레이션 쉘이 되는 구조.[^16_1]

***

## 5. 경쟁 지형과 전략적 포지셔닝

화이트페이퍼는 경쟁 도구들과의 **원리 수준 차이**를 이렇게 정리합니다.[^16_8][^16_1]

- **Power Platform / Copilot Studio**:
    - 엔터프라이즈 커넥터·데이터·거버넌스 강하지만, “문단을 치면 그래프가 자동 생성되는” 의도→플로우 자동화는 제한적.[^16_1]
- **Zapier / Make / n8n**:
    - 외부 연동·자동화는 성숙하지만, LLM 기반 플로우는 사용자가 직접 그래프를 많이 설계해야 함.[^16_9][^16_10]
- **Bubble / Glide / Lovable**:
    - UI/앱 자유도는 높지만, 학습·설정이 무거운 편.[^16_1]
- **Runway / Gemini Agent Apps**:
    - 멀티모달 생성·편집은 강하지만, 업무용 미니앱/자동화는 별도 설계 필요.[^16_11][^16_1]
- **Opal**:
    - “의도 → 그래프 → 실행 가능한 미니앱”을 가장 공격적으로 자동화하는, **intent-first prompt-to-workflow** 니치에 포지셔닝.[^16_5][^16_3]
    - 빠른 실험·공유/리믹스에는 최적이지만, 거버넌스·깊은 통합·SLA는 엔터프라이즈가 따로 설계/보완해야 한다.[^16_6][^16_1]

***

## 6. C레벨·아키텍트 관점 정리

제1원칙 기준으로 이 화이트페이퍼가 말하는 “의사결정 메시지”는 다음과 같습니다.[^16_2][^16_1]

1) **Opal이 이미 바꿔버린 것 (Fact)**

- 자연어로 설명하면, 시스템이 그래프를 짜고, 비주얼 에디터·템플릿·리믹스를 통해 **비개발자도 수분 내에 AI 미니앱을 만든다**.[^16_3][^16_2]
- “아이디어 → 실행 가능한 프로토타입”까지의 거리가 현저히 줄었다.

2) **지금 당장 할 수 있는 것 (권고)**

- 6–8주 파일럿을 마케팅/CS/운영에서 돌려, 실제 KPI(지연·성공률·비용·만족도·ROI)로 평가.[^16_1]
- 템플릿 저장소·금칙 프롬프트·승인 워크플로우를 세팅해, 섀도우 IT이 아닌 **관리되는 실험 공간**으로 만든다.[^16_12][^16_1]
- AIOps/FinOps 계측(로그, 메트릭, 비용)을 깔고, Workspace/내부 서비스는 게이트웨이 패턴으로 단계적 연동.[^16_6][^16_1]
- 어떤 외부 발행/민감 업무든 Human-in-the-loop 승인 필수.[^16_1]

3) **아직 기다려야 할 것 (제약·로 roadmap)**

- 글로벌 가용성, 코드 내보내기, 외부 DB/API 커넥터, 마켓플레이스, 고급 거버넌스 패널이 나와야 “코어 업무”로 확장 가능.[^16_8][^16_6][^16_1]

***

요약하면, 이 화이트페이퍼는 Opal을 **“Prompt-to-Graph 노코드 AI 오케스트레이터”**로 재정의하고, 이를 엔터프라이즈 환경에 맞게 쓰기 위해 필요한 **아키텍처 모델, 운영·보안·FinOps 프레임, 통합 패턴, 파일럿 로드맵**을 제1원칙 수준에서 풀어낸 문서입니다.[^16_3][^16_1]
<span style="display:none">[^16_13][^16_14][^16_15][^16_16][^16_17][^16_18][^16_19][^16_20][^16_21]</span>

<div align="center">⁂</div>

[^16_1]: https://kr.linkedin.com/pulse/no-code-ai-오케스트레이션-google-opal기술-백서-whitepaper-keonwoo-park-6o9qc

[^16_2]: https://developers.googleblog.com/en/introducing-opal/

[^16_3]: https://developers.google.com/opal

[^16_4]: https://siliconangle.com/2025/07/25/google-debuts-no-code-opal-tool-building-ai-mini-apps/

[^16_5]: https://techcrunch.com/2025/10/07/google-launches-its-ai-vibe-coding-app-opal-in-15-more-countries/

[^16_6]: https://www.infoworld.com/article/4069504/google-enhances-debugging-performance-in-opal-its-low-code-ai-based-app-builder.html

[^16_7]: https://blog.google/technology/google-labs/opal-expansion/

[^16_8]: https://dev.to/alifar/opal-googles-no-code-ai-app-builder-is-now-global-2196

[^16_9]: https://insight.infograb.net/blog/2025/10/15/google-opal-review/

[^16_10]: https://discuss.pytorch.kr/t/opal-google-ai-feat-no-code/7662

[^16_11]: https://blog.google/technology/google-labs/mini-apps-opal-gemini-app-experiment/

[^16_12]: https://spin.ai/blog/shadow-ai-vs-shadow-it-role-of-saas-risk-assessment-zero-trust-risk-mitigation/

[^16_13]: https://www.linkedin.com/newsletters/denos-ai-x-web30-techinsight-7319821779215036416

[^16_14]: https://www.youtube.com/watch?v=PEkUMlmjzzs

[^16_15]: https://www.reddit.com/r/n8n/comments/1m8q8fw/discover_opal_by_google_build_miniai_apps_with/

[^16_16]: https://brunch.co.kr/@ghidesigner/329

[^16_17]: https://www.youtube.com/watch?v=nVPhNYdckoU

[^16_18]: https://www.facebook.com/groups/agikr/posts/2747402765600764/

[^16_19]: https://developers.googleblog.com/introducing-opal/

[^16_20]: https://developers.googleblog.com/ko/introducing-opal/

[^16_21]: https://techcrunch.com/2025/09/24/it-isnt-your-imagination-google-cloud-is-flooding-the-zone/


---

# Webhook 트리거 설정 방법 단계별로 알려줘

n8n에서 Webhook 트리거를 설정하는 기본 절차를 “처음 워크플로우 만든다” 기준으로 단계별로 정리하면 아래와 같습니다.[^17_1][^17_2][^17_3]

***

## 1. 워크플로우와 Webhook 노드 만들기

1) 새 워크플로우 생성

- n8n 에디터에서 **New workflow**를 클릭합니다.[^17_2]

2) Webhook 노드 추가

- 캔버스에서 “Add node” 클릭 → `Webhook` 검색 → **Webhook** 노드를 선택합니다.[^17_3]
- Webhook 노드는 보통 **첫 노드(트리거)**로 사용합니다.[^17_4][^17_3]

***

## 2. Webhook 기본 설정

3) HTTP Method 선택

- Webhook 노드 설정에서 **HTTP Method**를 선택합니다.
- 데이터 전송용 Webhook은 대부분 **POST**를 사용합니다.[^17_4][^17_2]

4) Path 설정

- `Path` 필드에 URL 경로를 지정합니다.
    - 예: `/webhook/new-order` 처럼 의미 있는 경로로 설정.[^17_3][^17_4]
- n8n이 이 경로를 포함한 고유 Webhook URL(테스트/프로덕션)을 자동 생성합니다.[^17_1][^17_3]

5) 인증·보안 옵션 (필요 시)

- 일부 외부 서비스는 인증 토큰·IP 화이트리스트 등을 요구할 수 있습니다.
- Webhook 노드 설정에서 **Authentication, Allowed origins, IP whitelist** 등을 필요에 따라 설정합니다.[^17_2][^17_1]

***

## 3. 응답 방식 결정

6) 응답 타이밍 설정

- Webhook 노드의 **Respond** 섹션에서, 언제 어떻게 HTTP 응답을 돌려줄지 선택합니다.[^17_5][^17_1]
    - 즉시 응답(Immediately): 요청을 받자마자 200 OK 등을 바로 반환.
    - “Respond to Webhook 노드에서 응답”: 워크플로우 후반부에 **Respond to Webhook** 노드를 추가해, 처리 결과에 따라 응답을 커스터마이징.[^17_6][^17_5]

7) 응답 데이터 형식

- 단순 200 OK만 필요하면 Webhook 노드 기본 응답 그대로 사용.[^17_1]
- JSON/HTML 등 커스텀 응답이 필요하면, 뒤쪽에 **Respond to Webhook** 노드를 두고 상태 코드·바디를 설정합니다.[^17_5][^17_6]

***

## 4. 외부 서비스와 연결·테스트

8) 테스트용 URL 복사

- Webhook 노드를 클릭하면 **Test URL / Production URL**이 표시됩니다.
- 개발·디버깅 단계에서는 **Test URL**을 사용합니다.[^17_6][^17_2]

9) 외부 서비스에 URL 등록

- 외부 앱(예: 폼 서비스, Smartlead, Stripe 등)의 Webhook 설정 화면에 n8n의 Test URL을 붙여넣습니다.[^17_2][^17_3]
- 이벤트 조건(예: “양성 리드 발생 시 호출”)을 외부 서비스 쪽에서 설정합니다.[^17_2]

10) Webhook “Listening” 모드로 전환

- n8n 에디터에서 Webhook 노드 설정 창에서 **Listen for test event** 또는 **Execute workflow**를 눌러, Webhook을 수신 대기 상태로 만듭니다.[^17_7][^17_2]

11) 테스트 이벤트 전송

- 외부 서비스에서 “테스트 Webhook 보내기” 기능을 사용하거나, Postman/HTTP 클라이언트로 Test URL에 요청을 보냅니다.[^17_5][^17_2]
- n8n에서 Webhook 노드가 초록색으로 실행되며, 수신한 데이터(JSON)를 확인할 수 있습니다.[^17_7][^17_6]

***

## 5. 실제 워크플로우 연결 및 프로덕션 전환

12) 후속 노드 연결

- Webhook 노드 뒤에 **Set / IF / HTTP Request / Google Sheets / Slack / OpenAI** 등의 일반 노드를 추가해, 수신 데이터 처리·알림·저장 로직을 구성합니다.[^17_8][^17_3]

13) 핀 데이터로 디버깅

- Webhook으로 받은 샘플 데이터를 **Pin Data**로 고정해 두고, 이후 테스트 실행 시 같은 데이터를 재사용하며 후속 노드 로직을 디버깅합니다.[^17_9][^17_6]

14) 프로덕션 URL로 교체

- 로직이 안정화되면, Webhook 노드의 **Production URL**을 복사해 외부 서비스의 Webhook 설정에 붙여넣습니다.[^17_8][^17_6]
- 워크플로우 오른쪽 상단 **Active** 토글을 켜서 워크플로우를 활성화합니다.[^17_3]

15) 실 운영 모니터링

- 외부 이벤트 발생 시 Webhook 트리거가 실행되는지 확인하고, Executions 화면에서 성공/실패와 데이터를 모니터링합니다.[^17_6][^17_2]

이 순서를 그대로 따라가면, “새 워크플로우 생성 → Webhook 트리거 설정 → 외부 서비스 연결 → 테스트 → 프로덕션 전환”까지 한 번에 설정할 수 있습니다.
<span style="display:none">[^17_10][^17_11][^17_12][^17_13][^17_14][^17_15][^17_16][^17_17][^17_18][^17_19][^17_20][^17_21]</span>

<div align="center">⁂</div>

[^17_1]: https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.webhook/

[^17_2]: https://blog.horizon.dev/configure-webhooks-in-n8n/

[^17_3]: https://anehe.com/11

[^17_4]: https://automategeniushub.com/mastering-the-n8n-webhook-node-part-a/

[^17_5]: https://www.youtube.com/watch?v=IvUYJQkf6sA

[^17_6]: https://lilys.ai/notes/930400

[^17_7]: https://www.youtube.com/watch?v=TkSVRunD340

[^17_8]: https://n8n-tutorial.com/tutorials/n8n/workflow-design/how-to-use-webhooks-in-n8n-step-by-step/

[^17_9]: https://wikidocs.net/302246

[^17_10]: https://www.youtube.com/watch?v=lK3veuZAg0c

[^17_11]: https://www.youtube.com/watch?v=WKAXLZPxCck

[^17_12]: https://www.youtube.com/watch?v=EnEKKPLjZNU

[^17_13]: https://wikidocs.net/291035

[^17_14]: https://cord-ai.tistory.com/193

[^17_15]: https://www.youtube.com/watch?v=Hn2JsIpiJfs

[^17_16]: https://docs.n8n.io/hosting/configuration/configuration-examples/webhook-url/

[^17_17]: https://anehe.com/m/11

[^17_18]: https://community.n8n.io/t/creating-custom-n8n-webhook-node/140929

[^17_19]: https://www.youtube.com/watch?v=omzkPzQHS8k

[^17_20]: https://cyan91.tistory.com/entry/n8n-트리거-설정-초보자도-쉽게-시작하는-n8n-자동화

[^17_21]: https://www.youtube.com/watch?v=OCBqR0Rmryk


---

# 코어 노드 종류와 사용 사례 보여주기

n8n의 **코어 노드(Core nodes)**는 “특정 서비스 연결”이 아니라, **데이터 처리·로직·흐름 제어** 같은 기본 빌딩블록을 담당하는 내장 노드들입니다. 대표적인 종류와 실무 사용 사례를 묶어서 정리하면 아래와 같습니다.[^18_1][^18_2]

***

## 1. 데이터 편집·가공 계열

### 1) Edit Fields / Set 노드

- **역할**: 필드 추가·수정·삭제, 이름 변경, 타입 변환 등 데이터를 원하는 구조로 정리.[^18_3][^18_1]
- **사용 사례**
    - 외부 API에서 받은 원시 JSON에서 필요한 필드만 골라 `name, email, company` 형태로 재구성.
    - 내부 팀 표준에 맞게 `first_name → 이름`, `createdAt → 등록일` 등 키 이름 통일.[^18_3]


### 2) Code 노드 (Function / Function Item)

- **역할**: JavaScript(Python 지원 인스턴스도 있음)로 커스텀 로직을 작성해, 코어 노드만으로 어렵거나 복잡한 처리를 구현.[^18_4][^18_1]
- **사용 사례**
    - 날짜 계산(지난 7일, 분기 시작일), 복잡한 문자열 파싱, 중첩 JSON 변환.
    - 레거시 시스템 요구에 맞춰 JSON → XML 변환 후 HTTP로 전송.[^18_5]

***

## 2. 로직·분기 계열

### 3) IF 노드

- **역할**: 조건식(True/False)에 따라 워크플로우를 두 갈래로 분기.[^18_6][^18_1]
- **사용 사례**
    - 리드 점수가 70 이상이면 영업팀으로, 아니면 nurture 캠페인 경로로 전송.[^18_5]
    - API 응답 코드가 200이면 성공 경로, 그렇지 않으면 에러 처리 경로로 분리.


### 4) Switch 노드

- **역할**: 여러 조건(케이스)에 따라 **여러 개의 출력 경로**로 분기.[^18_7][^18_3]
- **사용 사례**
    - HTTP 상태 코드가 200/400/500에 따라 서로 다른 처리 로직으로 라우팅.
    - 주문 상태(`pending`, `paid`, `canceled`, `refunded`)별로 다른 알림·후속 작업 실행.

***

## 3. 흐름 제어·배치 처리 계열

### 5) Split In Batches / Loop Over Items

- **역할**: 큰 배열 데이터를 **배치 단위로 나눠 반복 처리**하거나, 각 아이템을 하나씩 순회.[^18_6][^18_3]
- **사용 사례**
    - 10,000개 이메일 주소를 100개씩 배치로 나눠, 메일 서버 과부하 없이 발송.
    - 크롤링 결과 리스트를 한 항목씩 처리하면서, 각각에 대해 OpenAI·HTTP 요청 실행.


### 6) Merge 노드

- **역할**: 두 개 이상의 경로에서 온 데이터를 하나의 스트림으로 **병합**.[^18_8][^18_1]
- **사용 사례**
    - 분기 A에서 DB 정보, 분기 B에서 API 정보 수집 후, Merge로 합쳐 최종 보고서 작성.
    - Split In Batches로 나눠 처리한 결과들을 다시 하나의 리스트로 합쳐 파일 첨부 메일로 전송.[^18_9]


### 7) Wait / Delay / Wait Until

- **역할**: 지정 시간까지 대기하거나, 특정 조건을 만족할 때까지 **흐름 일시 정지**.[^18_10][^18_11]
- **사용 사례**
    - 신규 가입 후 24시간 뒤에 웰컴 이메일 발송.
    - API rate limit 회피를 위해 호출 사이에 지연 삽입.

***

## 4. 트리거·HTTP·서브플로우 계열 (흐름의 뼈대)

### 8) HTTP Request 노드

- **역할**: 어떤 API든 직접 호출할 수 있는 범용 HTTP 클라이언트.[^18_1][^18_3]
- **사용 사례**
    - 사내 백엔드 API와 연동(고객 정보 조회, 주문 생성 등).
    - 외부 SaaS(예: Apify, Notion, HubSpot)와 공식 노드 없이도 직접 REST 통신.


### 9) Webhook / Respond to Webhook

- **역할**: 외부에서 오는 HTTP 요청(Webhook)을 워크플로우 시작점으로 사용 + 요청자에게 응답 반환.[^18_12][^18_3]
- **사용 사례**
    - 폼 제출, 결제 완료, Smartlead 이벤트 등 외부 이벤트를 n8n으로 바로 받아 후속 자동화.
    - API 스타일로 n8n 워크플로우를 “자체 백엔드 엔드포인트”처럼 노출.


### 10) Sub-Workflow / Execute Workflow

- **역할**: 다른 워크플로우를 호출해 **공통 로직을 재사용**.[^18_13][^18_3]
- **사용 사례**
    - “Slack 알림 보내기” 워크플로우를 하나 만들어두고, 여러 곳에서 공통 호출.
    - “로그 기록/에러 처리” 서브플로우를 별도 관리해, 운영과 로직을 분리.

***

## 5. AI·데이터 통합과 함께 쓰는 패턴

코어 노드들은 AI 노드(OpenAI, Gemini, Claude 등)와 조합될 때 더욱 강력해집니다.[^18_14][^18_3]

- 예시 1: AI 리드 스코어링 플로우
    - Webhook(리드 유입) → Set(필드 정리) → OpenAI Chat Model(설명 기반 점수 계산) → IF(점수에 따른 분기) → HTTP Request/Slack.[^18_14][^18_3]
- 예시 2: 뉴스 요약·배포 플로우
    - Schedule Trigger → HTTP Request(뉴스 API) → Split In Batches(기사별 처리) → OpenAI 요약 → Merge → Google Sheets/Slack 전송.[^18_13][^18_3]

***

## 한 줄 정리

- **코어 노드 = “데이터 편집(Edit Fields/Code) + 로직(IF/Switch) + 흐름 제어(Split/Merge/Wait) + 통신(HTTP/Webhook) + 재사용(Sub-workflow)”** 묶음이고,
- 이 조합만 익혀도 대부분의 비즈니스 자동화·AI 워크플로우를 설계할 수 있습니다.[^18_2][^18_1][^18_3]
<span style="display:none">[^18_15][^18_16][^18_17][^18_18][^18_19][^18_20][^18_21][^18_22][^18_23][^18_24]</span>

<div align="center">⁂</div>

[^18_1]: https://docs.n8n.io/integrations/builtin/node-types/

[^18_2]: https://wikidocs.net/310103

[^18_3]: https://www.aifire.co/p/master-n8n-fast-the-10-essential-nodes-for-ai-automation

[^18_4]: https://automategeniushub.com/introduction-to-n8n-nodes/

[^18_5]: https://www.linkedin.com/posts/leadgenmanthan_key-nodes-in-n8n-activity-7372553622829649920-KYFb

[^18_6]: https://www.youtube.com/watch?v=Rmi-ckbMOQE

[^18_7]: https://wikidocs.net/310176

[^18_8]: https://github.com/n8n-io/n8n/issues/6596

[^18_9]: https://community.n8n.io/t/how-to-merge-files-from-split-in-batches-node-into-one-to-send-in-a-mail/25517

[^18_10]: https://wikidocs.net/291033

[^18_11]: https://blog.horizon.dev/configure-webhooks-in-n8n/

[^18_12]: https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.webhook/

[^18_13]: https://www.youtube.com/watch?v=D9MIGseFB3g

[^18_14]: https://wikidocs.net/292572

[^18_15]: https://community.n8n.io/t/master-list-of-every-n8n-node/155146

[^18_16]: https://www.reddit.com/r/n8n/comments/1lnwxc6/the_ultimate_n8n_cheat_sheet_20_essential_nodes/

[^18_17]: https://github.com/restyler/awesome-n8n

[^18_18]: https://www.youtube.com/watch?v=D9MIGseFB3g\&list=WL\&index=68

[^18_19]: https://wikidocs.net/291035

[^18_20]: https://community.n8n.io/t/how-to-handle-merging-output-from-a-split-node-with-varying-data-types-and-potential-non-execution-on-path/194511

[^18_21]: https://community.n8n.io/t/wait-until-finished-after-split-in-batches-and-merge-the-batches-for-spotify-workflow/4637

[^18_22]: https://www.youtube.com/watch?v=Z9664Q4LJOo

[^18_23]: https://wikidocs.net/290882

[^18_24]: https://community.n8n.io/t/split-in-batches-exiting-before-looping-all-items/27221


---

# 데이터 핀닝 개념과 장단점 설명하기

**데이터 핀닝(Data pinning)**은 n8n에서 **개발·테스트 시 특정 노드의 출력 데이터를 “고정”해 두고, 이후 테스트 실행에서 항상 그 데이터를 재사용하는 기능**입니다. 프로덕션 실행에는 적용되지 않고, 오직 워크플로우 개발·디버깅 보조용입니다.[^19_1][^19_2][^19_3]

***

## 1. 개념 정리

- 정의:
    - “데이터 핀닝을 사용하면 워크플로 개발 중 노드의 출력 데이터를 일시적으로 고정해, 외부 서비스에 반복 요청하지 않고 **예측 가능한 동일 데이터**로 워크플로를 테스트할 수 있다.”[^19_2]
    - 노드 실행 후 OUTPUT 뷰에서 **Pin data**를 누르면, 해당 노드의 출력이 저장되고, 이후 테스트 실행에서는 새로운 호출 대신 이 고정 데이터를 사용합니다.[^19_4][^19_1]
- 적용 범위:
    - 단일 메인 출력이 있는 노드에만 가능(에러 출력은 제외).[^19_3][^19_1]
    - 바이너리 데이터(이미지, 영상 등)를 출력하는 노드는 핀닝 불가.[^19_1][^19_4]
    - 프로덕션 워크플로우 실행에서는 무시되고, 항상 실제 데이터를 사용합니다.[^19_2][^19_3]

***

## 2. 장점

1) **테스트 속도·효율 향상**

- 외부 API·DB·폼 등에서 데이터를 한 번만 받아오고, 이후에는 핀된 데이터를 재사용하므로 **테스트가 매우 빠르게 반복**됩니다.[^19_5][^19_6]
- 긴 지연이 있는 API, 크롤링, 대용량 쿼리 등 “느린 상류 노드”를 매번 다시 돌릴 필요가 없습니다.[^19_7][^19_6]

2) **비용·쿼터 절감**

- LLM·외부 API 호출이 비싸거나 rate limit이 있는 경우, 핀닝으로 불필요한 재호출을 막아 **토큰·요청 비용과 쿼터 소모를 줄일 수 있습니다.**[^19_8][^19_5]

3) **일관된 디버깅 환경**

- 항상 같은 입력 데이터로 테스트하므로, 로직 수정 시 결과 변화가 “코드/노드 변경 때문인지, 입력 데이터 변경 때문인지”를 명확히 구분할 수 있습니다.[^19_6][^19_4]
- 실제 응답 구조를 그대로 가진 상태에서, IF/Switch/데이터 전처리 로직을 안정적으로 튜닝 가능.[^19_7][^19_4]

4) **모의 데이터·엣지 케이스 테스트에 유용**

- 핀된 데이터를 편집(Edit Output)해서 null 값, 이상치, 형식 오류 등을 인위적으로 만들어 **엣지 케이스를 쉽게 재현**할 수 있습니다.[^19_9][^19_7]
- Mockaroo 같은 도구로 생성한 JSON을 핀 데이터로 붙여 넣어, 다양한 시나리오를 빠르게 검증할 수 있습니다.[^19_7]

***

## 3. 단점·주의점

1) **개발 전용, 프로덕션에서는 사용 불가**

- 공식 문서에서 “데이터 핀닝은 개발용 기능이며, 프로덕션 실행에는 적용되지 않는다”고 명시합니다.[^19_3][^19_1]
- 실 운영에서 핀 데이터를 믿고 있으면, 실제 API 응답 형식 변화나 장애를 놓칠 수 있으므로 **운영 모니터링과는 별개**로 봐야 합니다.[^19_6]

2) **실제 환경과의 괴리 가능성**

- 입력 데이터를 고정해 두면, 실제 운영 중 발생하는 새로운 필드, 예외 값, 에러 응답 등을 테스트에서 놓칠 수 있습니다.[^19_5][^19_4]
- 지나치게 오랫동안 같은 핀 데이터를 쓰면, “테스트는 항상 성공하는데 실제 실행은 자꾸 깨지는” 상황이 생길 수 있습니다.[^19_10]

3) **바이너리 데이터 핀 불가 및 데이터 크기 이슈**

- 바이너리 출력 노드는 핀닝이 막혀 있고, 큰 JSON을 과도하게 핀하면 에디터에서 로딩·편집이 느려질 수 있습니다.[^19_4][^19_1]
- 필요 이상으로 많은 노드에 데이터를 핀하면, n8n 인스턴스에 불필요한 데이터가 쌓여 관리 부담이 커질 수 있습니다.[^19_11]

4) **단일 출력만 지원·교체 시 덮어쓰기**

- 단일 메인 출력이 있는 노드에만 핀 가능하고, 한 노드에 한 번에 하나의 핀 데이터만 유지됩니다.[^19_8][^19_3]
- 새로 핀을 꽂으면 기존 핀 데이터는 덮어씌워지므로, 여러 버전의 샘플 데이터를 동시에 유지하기 어렵습니다.[^19_11][^19_8]

***

정리하면, 데이터 핀닝은 n8n에서 **“한 번 받은 진짜 데이터를 재사용·편집하면서 워크플로우를 빠르고 싸게 디버깅하는 개발용 기능”**입니다. 테스트 속도와 품질을 크게 올려주지만, 프로덕션 신뢰도와는 별개이므로 **운영 전에는 반드시 핀을 해제하고 실제 데이터로 재검증**하는 습관이 필요합니다.[^19_1][^19_6][^19_2][^19_3]
<span style="display:none">[^19_12][^19_13][^19_14][^19_15][^19_16][^19_17][^19_18][^19_19][^19_20]</span>

<div align="center">⁂</div>

[^19_1]: https://docs.n8n.io/data/data-pinning/

[^19_2]: https://wikidocs.net/290951

[^19_3]: https://n8n-docs.teamlab.info/data/data-pinning/

[^19_4]: https://docs.n8n.io/data/data-mocking/

[^19_5]: https://www.altexsoft.com/blog/n8n-pros-and-cons/

[^19_6]: https://betazeta.dev/blog/n8n-pro-fundamentals/

[^19_7]: https://slashpage.com/n8n-guide/36nj8v2w4jdgwm5ykq9z?lang=ko

[^19_8]: https://www.youtube.com/watch?v=BQ8RXgW4hiI

[^19_9]: https://www.youtube.com/watch?v=zcNB8L4_9mA

[^19_10]: https://community.n8n.io/t/data-pinning-doesnt-work-again/91554

[^19_11]: https://rapidevelopers.com/n8n-tutorial/how-to-use-data-pinning-in-n8n

[^19_12]: https://www.mantra-networking.com/n8n-automation-workflow-deep-dive/

[^19_13]: https://techpoint.africa/guide/n8n-ai-automation-honest-review/

[^19_14]: https://softailed.com/blog/n8n-vs-make

[^19_15]: https://wikidocs.net/book/18092

[^19_16]: https://virtualnexgen.com/blog/master-n8n-automation-27-advanced-features-guide

[^19_17]: https://www.youtube.com/watch?v=8hyxpEEKg-I

[^19_18]: https://wikidocs.net/290966

[^19_19]: https://www.reddit.com/r/n8n/comments/1iszz3r/is_n8n_for_engineers_or_nontech_users_what_are/

[^19_20]: https://wikidocs.net/290964


---

# 워크플로우의 구성 요소별 핵심 역할 정리하기

n8n 워크플로우는 몇 가지 핵심 구성 요소가 유기적으로 맞물려 동작합니다. 각 요소별 **핵심 역할**만 정리하면 다음과 같습니다.[^20_1][^20_2]

***

## 1. 노드(Nodes)

- **역할**:
    - 워크플로우의 **기본 실행 단위**로, 데이터를 가져오고(입력), 처리하고(가공), 외부로 보내는(출력) 모든 작업을 담당합니다.[^20_3][^20_1]
- 세부 구분:
    - 트리거 노드: “언제/어떤 이벤트에” 워크플로우를 시작할지 정의.[^20_4][^20_1]
    - 액션(일반/코어) 노드: API 호출, 데이터 변환, 분기(IF/Switch), 병합(Merge) 등 실제 로직 수행.[^20_5][^20_3]

***

## 2. 연결(Connections)

- **역할**:
    - 노드와 노드를 잇는 선으로, **실행 순서를 결정**하고, 이전 노드의 출력 데이터를 다음 노드로 전달하는 통로입니다.[^20_6][^20_1]
- 특징:
    - 단일 선: 직선형(순차) 흐름.
    - 여러 선: 병렬 분기 또는 조건 분기(IF/Switch)로 다른 경로로 라우팅.[^20_7][^20_6]

***

## 3. 데이터(Data)

- **역할**:
    - 워크플로우를 통해 흐르는 **실제 정보(아이템 배열 형태의 JSON)**로, 각 노드가 입력으로 받고 출력으로 내보내는 대상입니다.[^20_8][^20_6]
- 특징:
    - 모든 노드는 입력 데이터를 가공해 새로운 출력 데이터를 생성하며, n8n UI에서 단계별 변화를 시각적으로 확인할 수 있습니다.[^20_9][^20_1]

***

## 4. 자격 증명(Credentials)

- **역할**:
    - 외부 서비스(API, DB, SaaS 등)에 접근하기 위한 **인증 정보(토큰, 키, 계정)**를 안전하게 저장·관리하고, 여러 워크플로우에서 재사용하게 해주는 요소입니다.[^20_10][^20_5]
- 특징:
    - 노드 설정에서 크리덴셜을 선택만 하면, 내부에서 안전하게 인증을 처리하므로 노드 안에 키를 직접 하드코딩할 필요가 없습니다.[^20_11][^20_12]

***

## 5. 실행 기록(Executions)

- **역할**:
    - 워크플로우가 실제로 돌았던 **모든 실행 이력**으로, 각 실행에서 어떤 노드가 어떤 데이터로 어떻게 동작했는지 추적·디버깅하는 데 사용됩니다.[^20_12][^20_1]
- 특징:
    - 성공/실패 여부, 에러 지점, 각 노드의 입력·출력을 확인할 수 있어, 문제 원인 분석과 성능 모니터링의 핵심 근거가 됩니다.[^20_12][^20_9]

***

요약하면, **노드**가 일을 하고, **연결**이 순서와 경로를 정하며, **데이터**가 그 안을 흘러가고, **자격 증명**이 외부 세계와의 안전한 통신을 가능하게 하고, **실행 기록**이 이 모든 과정을 “관찰·관리”할 수 있게 해주는 구조입니다.[^20_13][^20_6][^20_1]
<span style="display:none">[^20_14][^20_15][^20_16][^20_17][^20_18][^20_19][^20_20][^20_21]</span>

<div align="center">⁂</div>

[^20_1]: https://wikidocs.net/290941

[^20_2]: https://docs.n8n.io/workflows/

[^20_3]: https://docs.n8n.io/workflows/components/nodes/

[^20_4]: https://n8n-docs.teamlab.info/workflows/components/nodes/

[^20_5]: https://wikidocs.net/290882

[^20_6]: https://deepwiki.com/n8n-io/n8n-docs/2.1-workflows-and-data-flow

[^20_7]: https://contabo.com/blog/the-complete-beginners-guide-to-n8n-your-first-workflow/

[^20_8]: https://wikidocs.net/302246

[^20_9]: https://wikidocs.net/290900

[^20_10]: https://docs.n8n.io/integrations/builtin/credentials/

[^20_11]: https://docs.n8n.io/integrations/

[^20_12]: https://tilnote.io/pages/68139905baa37b7453843acb

[^20_13]: https://www.hostinger.com/my/tutorials/n8n-workflow-examples

[^20_14]: https://docs.n8n.io

[^20_15]: https://www.reco.ai/hub/secure-n8n-workflows

[^20_16]: https://tuanla.vn/post/n8n/

[^20_17]: https://deepwiki.com/n8n-io/n8n-docs/2.3-building-workflows

[^20_18]: https://elementor.com/blog/what-is-n8n/

[^20_19]: https://velog.io/@jejeong000/n8n-1

[^20_20]: https://github.com/Zie619/n8n-workflows

[^20_21]: https://www.youtube.com/watch?v=4cQWJViybAQ


---

# 노드의 입력 처리 출력 흐름 예시 요청하기

n8n에서 **노드가 입력을 받아 처리하고 출력으로 넘기는 흐름**을, 간단한 예시 워크플로우로 보여드리겠습니다.[^21_1][^21_2]

***

## 예시 1: Webhook → Set → HTTP Request

1) Webhook 노드 (입력 생성)

- 입력: 외부 서비스가 보내는 HTTP 요청 바디(JSON). 예:

```json
{
  "email": "user@example.com",
  "name": "Alice",
  "productId": "P-123"
}
```

- 처리: 없음(그대로 통과).
- 출력: 같은 JSON이 `items[^21_0].json` 형태로 다음 노드에 전달.[^21_3][^21_1]

2) Set 노드 (필드 정리·변환)

- 입력: Webhook 출력(`email, name, productId`).
- 처리:
    - 필요한 필드만 선택, 새 필드 추가:
        - `fullName = name`
        - `welcomeSubject = "Thanks for buying " + productId`
- 출력 예:

```json
{
  "email": "user@example.com",
  "fullName": "Alice",
  "welcomeSubject": "Thanks for buying P-123"
}
```

이 JSON이 다음 노드 입력으로 전달됩니다.[^21_4][^21_1]

3) HTTP Request 노드 (외부 API 호출)

- 입력: Set 노드 출력(JSON).
- 처리:
    - 이 값을 사용해 외부 이메일 API 엔드포인트 호출 (예: POST /send-mail).
    - 바디에 `to=email`, `subject=welcomeSubject`, `name=fullName` 매핑.[^21_5][^21_4]
- 출력: 외부 API 응답(JSON), 예:

```json
{
  "status": "queued",
  "messageId": "abc-123"
}
```

이후 노드(Slack 알림, 로그 저장 등)의 입력이 됩니다.

***

## 예시 2: HTTP Request → IF → Slack

1) HTTP Request 노드 (데이터 조회)

- 입력: 이전 노드(예: Webhook/Set)에서 넘어온 `userId`.
- 처리: DB API에 `GET /users/{userId}` 호출.[^21_5]
- 출력 예:

```json
{
  "id": "u-01",
  "name": "Alice",
  "plan": "premium",
  "active": true
}
```


2) IF 노드 (조건 분기)

- 입력: HTTP Request 출력(JSON).
- 처리: 조건: `active == true AND plan == "premium"` 인지 검사.[^21_6][^21_1]
- 출력:
    - True 브랜치: 조건을 만족하는 아이템만 True 경로로 전달.
    - False 브랜치: 나머지 아이템은 False 경로로 전달.

3) Slack 노드 (알림 전송, True 경로)

- 입력: IF True 브랜치에서 넘어온 사용자 데이터.
- 처리: Slack 채널에 “프리미엄 활성 사용자 Alice 접속” 같은 메시지 전송.[^21_5]
- 출력: Slack API 응답(JSON) → 이후 로깅·집계 노드로 전달.

***

이처럼 각 노드는 항상
**“입력(JSON) → 내부 로직(설정/코드) → 출력(JSON) → 다음 노드로 전달”**
이라는 동일한 패턴으로 동작하며, 워크플로우 전체는 이 흐름이 연결된 체인으로 구성됩니다.[^21_2][^21_1]

<div align="center">⁂</div>

[^21_1]: https://deepwiki.com/n8n-io/n8n-docs/2.1-workflows-and-data-flow

[^21_2]: https://wikidocs.net/290941

[^21_3]: https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.webhook/

[^21_4]: https://docs.n8n.io/workflows/components/nodes/

[^21_5]: https://docs.n8n.io/integrations/

[^21_6]: https://docs.n8n.io/integrations/builtin/node-types/


---

# 바이브 코딩으로 글로벌 서비스를 개발하고자 합니다.

안정적인 서비스를 개발하기 위해서 총 3개의 구조를 가지면 된다고 봅니다.
그 첫째가 개발하고자 하는 글로벌 서비스에 대한 개발 기획 단계에서 요구되는 것은 아래 각종 설계 및 기획에 관한 정의되는 내용들에 대한 가이드 북이 필요합니다.

개발기획서
기술스택
요구사항 정의서
개발 플로우
워크플로우 설계

각 화면별 “컴포넌트 트리(Tree)”, shadcn/ui 또는 Tailwind 컴포넌트 매핑

두번째로는 워크플로우를 구성하는 블록인 노드부터 연결(Connection),데이터(Data),실행(Executions), 디버깅 가이드 등이 포함된  각 구조에 대한 가이드 북이 요구됩니다.

계층 구조 (레이어 모델)

이 단계에서 개발하고자 하는 글로벌 서비스에 대한 각 기능별 모듈 그리고 각 기능별 옵션 등이 포함된 워크 플로우를 구성하는 기본 블록으로 노드라는 개념이 요구되며 각 노드가 특정 기능을 담당합니다.

노드간 데이터 흐름이나 기능별 연결을 나타내는 연결(Connection) 을 통하여 상류노트 출력이 하류 노드 입력으로 전달되는 등 각 연결(Connection) 간의 연계성 및 타당성 흐름등을 파악할 수 있어야 합니다.

외부 서비스 API 키, OAuth 토큰 등을 암호화해 저장·재사용하는 기능등을 제어하는 자격 증명(Credentials)
이 있어야 합니다.

워크플로우가 실제로 한 번 돌아간 “런(run)” 단위인 실행(Executions) 이 있어야 합니다.

각 단계에서 데이터가 어떻게 변하는지 UI에서 시각적으로 확인할 수 있도록 모든 노드는 입력 데이터를 받아 처리하고 시각적으로 확인할 수 있는 데이터(Data) 구조가 있습니다.

이후 디버깅 가이드 구조가 요구됩니다.

세번째로는 아래와 같이 서비스 개발 가이드북 시리즈 구조가 요구됩니다.

각 번호가 “별도의 가이드북(문서 한 권)”입니다.

1. 비전·요구사항 정의 가이드
2. 도메인 모델링 \& 페르소나·세그먼트 설계 가이드
3. 멀티에이전트 아키텍처 설계 가이드 (LangGraph 중심)
4. 데이터 \& RAG 인프라(Qdrant + Supabase) 설계 가이드
5. LLM 레이어 \& 프롬프트 엔지니어링 가이드
6. 서비스 Workflow 설계 \& LangGraph 구현 가이드
7. 백엔드(FastAPI) API \& 통합 가이드
8. 프론트엔드(Next.js PWA) 설계·구현 가이드
9. ESP(메일 발송 시스템) 연동 \& AB 테스트 가이드
10. Observability/로깅/평가/거버넌스 가이드
11. 배포·운영·CI/CD \& 비용 최적화 가이드
12. 운영 Runbook \& 확장(고도화) 시나리오 가이드

Monorepo 전체 구조 설계, 환경변수/Secret 관리 방법

네번째로는 "서비스에 필요한 화면 UX/UI를 위한 hi-fi wireframe" 등 서비스 전반에 요구되는 모든 화면 설계에 관한 가이드 북이 요구됩니다.

각 가이드 북은 .md 형태로 4개의 디렉토리에 구성하고 그 구성을 참고로 실제 모든 바이브 코딩을 완성할 수 있어야 합니다.

위에서 제시한 모든 내용에 빠진 내용이 있는지  서비스 설계, 구축, 운영, 관리, 사후 피드백, 향후 업데이트 및 확장에 거쳐 필요한 모든 기능들이나 내용들을 단계별로 하나하나 검토하여 필요한 모든 내용에 대해서 4개의 디렉토리에 해당하는 백서 세트로 구성하기 위한 상세 내용을 단계별로 제시해 주세요.

요청하신 구조를 기준으로, 글로벌 바이브 코딩 기반 서비스를 **처음 기획 → 설계·구현 → 운영·확장**까지 커버하는 “4개 디렉터리 · 백서 세트”에 필요한 항목을 빠짐없이 나열하겠습니다. 각 항목은 .md 한 파일 또는 섹션 수준으로 설계할 수 있습니다.[^22_1][^22_2][^22_3]

***

## 디렉터리 1: 서비스 개발 기획·설계 가이드 (`/01_planning_design`)

**목표**: “무엇을 만들 것인지(What)”를 바이브 코딩에 적합한 형태로 완전히 구조화.[^22_4][^22_1]

### 1-1. Vision \& 요구사항 정의

- `vision-and-goals.md`
    - 서비스 비전, 미션, 성공 지표(North Star, 핵심 KPI).
    - 글로벌 타깃 시장, 언어/지역 범위, 브랜딩 톤.
- `requirements-functional-nonfunctional.md`
    - 기능 요구사항(Feature 목록, 유저스토리, 우선순위 MoSCoW).
    - 비기능 요구사항: 성능, 보안, 가용성, 다국어, 접근성, 규제 요구사항 등.[^22_5]
- `personas-and-segments.md`
    - 대표 유저 페르소나(2~5개), 국내/글로벌 세그먼트 정의.
    - 유저 여정(Journey)와 주요 터치포인트.


### 1-2. 도메인 모델링 \& 정보 구조

- `domain-modeling.md`
    - 핵심 엔티티(예: User, Organization, Project, Workspace, Template, Automation, Event, Log).
    - 엔티티 간 관계 다이어그램, 다국어/통화/타임존 처리 규칙.[^22_6]
- `information-architecture.md`
    - IA: 메뉴 구조, 네비게이션, 정보 계층(프로젝트 > 워크플로우 > 실행 등).
    - URL 설계, 글로벌 URL 전략(언어 코드, 리전 필드 등).


### 1-3. 기술 스택 \& 아키텍처 방향

- `tech-stack-and-constraints.md`
    - 프론트: Next.js 14 PWA, shadcn/ui, Tailwind, LangGraph 클라이언트 사용 여부 등.[^22_7][^22_8]
    - 백엔드: FastAPI, LangGraph(멀티에이전트), Supabase(Postgres+Auth+Storage), Qdrant(RAG).[^22_9][^22_10]
    - 인프라: Vercel/Cloud Run/쿠버네티스, CDN, 이미지 처리, 메일 발송(ESP) 등.
    - 제약: 예산, 팀 스킬, 타임라인.
- `architecture-overview.md`
    - 전체 시스템 C4 수준 다이어그램(사용자 ↔ 프론트 ↔ BFF/API ↔ DB/RAG/외부 서비스).
    - 모놀리식 vs 모듈러 모놀리포 vs 마이크로서비스 전략 및 선택 이유.[^22_2][^22_11]


### 1-4. 개발기획서 \& 개발 플로우

- `development-plan.md`
    - 단계별 마일스톤: PoC → 베타 → GA → 글로벌 롤아웃.
    - 도메인별 태스크 맵(에이전트, 데이터, API, UI).
- `dev-flow-and-vibe-coding-patterns.md`
    - 바이브 코딩용 프롬프트 템플릿(아키텍처/컴포넌트/테스트/리팩토링용).[^22_12][^22_1][^22_4]
    - “One prompt → 스캐폴드 → 개선 프롬프트” 반복 구조 설명.[^22_13][^22_14]


### 1-5. 화면/컴포넌트 설계

- `screens-and-user-flows.md`
    - 핵심 플로우별 화면: 온보딩, Workspace/Project 대시보드, Workflow 편집기, 실행 로그, 설정(Workspace/사용자/통합), 결제/플랜 등.
- `component-trees-and-ui-mapping.md`
    - 각 화면별 **컴포넌트 트리**: Layout → Header/Sidebar → PageSections → Controls.[^22_7]
    - 각 노드에 대해 `shadcn/ui` 또는 Tailwind 유틸/컴포넌트 매핑 테이블.
    - 상태 관리 전략(React Server Components vs Client, tanstack-query 등) 메모.

***

## 디렉터리 2: 워크플로우 \& 노드 구조 가이드 (`/02_workflow_engine`)

**목표**: “어떻게 흐르게 만들 것인지(Flow)”를 n8n/Opal/LangGraph식 워크플로우 개념으로 표준화.[^22_15][^22_16][^22_9]

### 2-1. 워크플로우 개념·레이어 모델

- `workflow-concepts-and-layers.md`
    - 레이어: Presentation(에디터) / Workflow Runtime / Nodes / Connections / Data / Credentials / Executions / Debugging.[^22_16][^22_17]
    - “미니앱 = 그래프(노드/엣지 + 상태)” 개념 정의.


### 2-2. 노드(Node) 정의 \& 카탈로그

- `node-basics.md`
    - 노드 타입:
        - 트리거(웹훅, 스케줄, 이벤트)
        - 액션(API 호출, 이메일, DB, AI 호출)
        - 코어 로직(IF, Switch, Merge, Split, Loop, Wait)
        - 서브그래프/에이전트(LangGraph 노드 대응).[^22_18][^22_19][^22_9]
- `node-catalog.md`
    - 비즈니스 기능별 노드 카탈로그:
        - 유저·워크스페이스 관리 노드
        - 통합(ESP, Slack, Stripe, CRM 등) 노드
        - AI 노드(OpenAI/Gemini, RAG 쿼리 노드).
    - 각 노드 정의: 입력 스키마, 출력 스키마, 옵션, 실패 시 동작.


### 2-3. 연결(Connection) \& 데이터(Data) 흐름

- `connections-and-flow-control.md`
    - 단일/병렬 경로, 브랜치, 합류(Merge), 의존관계, 순서 결정 규칙.[^22_20][^22_16]
    - LangGraph StateGraph와의 맵핑(노드 간 edge, 메시지/상태 전달).[^22_21][^22_9]
- `data-model-in-workflows.md`
    - 워크플로우 내 데이터 구조: `items[]` 배열, JSON 구조, 멀티모달(텍스트+파일) 취급.[^22_22][^22_20]
    - 각 단계에서 데이터 변환·검증 규칙(타입, required, validation error 핸들링).


### 2-4. 자격 증명(Credentials) \& 시크릿

- `credentials-and-secrets.md`
    - API 키·OAuth·서비스 계정 구조, 암호화 저장, 로테이션 전략.[^22_23][^22_24]
    - 워크플로우에서 크리덴셜 참조 방식(스코프, 권한 최소화).[^22_17]


### 2-5. 실행(Executions) \& 디버깅

- `executions-and-logging.md`
    - 실행 단위(run), 상태(대기/성공/실패), 리트라이 정책, 멱등성 설계.[^22_25][^22_15]
- `debugging-and-data-pinning.md`
    - 실행 로그 확인, 노드별 입력/출력 확인, Pin Data/Mocking 사용법 및 제약(바이너리 제한 등).[^22_26][^22_27][^22_15]
    - 에러 유형별 패턴(JSON Parse Error, Expression Error, 외부 API 타임아웃 등)과 대응 룰.[^22_28][^22_25]


### 2-6. PTG/Opal·LangGraph 통합 관점 (선택)

- `prompt-to-graph-strategy.md`
    - Opal/유사 PTW 도구에서 자연어 → 노드 그래프 생성 전략.
    - 그래프 품질 검증 체크리스트(루프, 에러 경로, 자격 증명, 비용).[^22_3][^22_29][^22_30]

***

## 디렉터리 3: 서비스 개발·운영 가이드 시리즈 (`/03_service_guides`)

**목표**: 번호별 “문서 한 권” 구조를, .md 세트로 구현할 수 있게 세분화.

### 3-1. 1~2: 비전·요구사항·도메인·페르소나

- `01-vision-requirements.md` → 디렉터리 1의 내용을 확장(실제 템플릿, 예시 포함).
- `02-domain-personas-segmentation.md` → 도메인 모델링, 세그먼트별 유저스토리·기능 우선순위.


### 3-2. 3: 멀티에이전트 아키텍처 (LangGraph)

- `03-multi-agent-architecture.md`
    - LangGraph StateGraph, 노드=에이전트, Supervisor 패턴, 서브그래프 패턴.[^22_31][^22_9][^22_21]
    - 역할별 에이전트 정의(Researcher, Planner, Coder, Evaluator, Router 등)와 서비스 도메인 맵핑.


### 3-3. 4: 데이터 \& RAG 인프라 (Qdrant + Supabase)

- `04-data-rag-infra.md`
    - OLTP(Supabase Postgres) 스키마 설계, Qdrant 벡터 인덱스 구조, 인덱싱 파이프라인, 수명주기 관리.[^22_10]
    - 데이터 분류(PII/비PII), 보존 정책, 백업/복구.


### 3-4. 5: LLM 레이어 \& 프롬프트

- `05-llm-and-prompt-engineering.md`
    - 모델 선택 전략(가격/지연/품질), 시스템 프롬프트, 역할 프롬프트, 체인/에이전트용 프롬프트 패턴.[^22_14][^22_4]
    - 바이브 코딩용 아키텍처 프롬프트/테스트 프롬프트 템플릿.[^22_2][^22_12]


### 3-5. 6: 서비스 Workflow \& LangGraph 구현

- `06-service-workflows-and-langgraph.md`
    - 비즈니스 시나리오별 워크플로우 정의(예: 캠페인 자동화, 온보딩, 리포트 생성).
    - 각 워크플로우를 LangGraph 그래프로 표현(노드/엣지 다이어그램, 상태 스키마).[^22_32][^22_9]


### 3-6. 7~8: 백엔드(FastAPI) \& 프론트엔드(Next.js PWA)

- `07-fastapi-api-integration.md`
    - API 설계(REST/GraphQL), 인증(JWT/Session), LangGraph 호출 API, 백그라운드 작업 구조.[^22_11][^22_10]
- `08-nextjs-pwa-frontend.md`
    - 앱 구조(app router, 레이아웃, 다국어, Suspense/Streaming), 상태 관리, API 통신 규칙.[^22_5][^22_7]
    - 워크플로우 에디터 UI(노드 그래프, 속성 패널, 실행 로그 패널) 설계.


### 3-7. 9: ESP \& A/B 테스트

- `09-esp-and-ab-test.md`
    - Mailgun/SendGrid 등 ESP 연동 패턴, 템플릿/세그먼트 관리.
    - A/B 테스트 설계(트래픽 분배, 메트릭, 실험 기간, 분석).


### 3-8. 10~12: Observability·배포·Runbook

- `10-observability-logging-governance.md`
    - 로깅(구조화 로그), 트레이싱(OpenTelemetry), 메트릭(성공률, 지연, 비용), LLM 품질 평가.[^22_33][^22_3]
    - AI 거버넌스(프롬프트·모델 변경 관리, 데이터 사용 정책).
- `11-ci-cd-deployment-cost-optimization.md`
    - Monorepo 빌드 파이프라인, 환경별 배포(Dev/Staging/Prod), Canary/Blue-Green, 비용 모니터링.[^22_8][^22_10]
- `12-runbook-and-evolution-scenarios.md`
    - 운영 Runbook(장애 유형별 대응, 온콜, 롤백 절차).
    - 확장 시나리오: 기능 추가, 리팩터링, 멀티리전, 멀티테넌시, 에이전트 확장.
- `monorepo-structure-and-env.md`
    - Monorepo 디렉토리 구조(`apps/`, `packages/`, `infra/`), 공통 라이브러리, 테스트 전략, 환경변수/Secret 관리(.env, Vault, CI secrets).[^22_8][^22_11][^22_7]

***

## 디렉터리 4: UX/UI \& 화면 설계 가이드 (`/04_ux_ui_wireframes`)

**목표**: 바이브 코딩 시 “레이아웃·컴포넌트·상태”까지 자연어로 명확히 표현할 수 있도록, 화면 설계를 표준화.

### 4-1. UX 원칙 \& 네비게이션

- `ux-principles-and-navigation.md`
    - 글로벌 UX 원칙(일관성, 피드백, 오류 복구, 접근성).
    - 네비게이션 모델: 메인 레이아웃, 워크플로우 편집 모드, 설정 모드, 분석/리포트 모드.


### 4-2. Hi-Fi Wireframe 세트

- `wireframes-dashboard.md`
    - 로그인 후 대시보드 화면(프로젝트 리스트, 최근 실행, 알림).
- `wireframes-workflow-editor.md`
    - 캔버스/노드 목록/속성 패널/실행 로그/버전 히스토리 영역 분할.
- `wireframes-execution-logs-and-debugging.md`
    - 실행 이력 리스트, 상세 화면(타임라인, 노드별 입출력, 에러, 재실행 버튼).[^22_15]
- `wireframes-settings-and-integrations.md`
    - Workspace 설정, 멤버/권한, 통합(ESP, Slack, Stripe 등) 설정 화면.

각 wireframe 문서에는

- 컴포넌트 트리
- shadcn/ui 컴포넌트 매핑
- 상태/이벤트 목록(예: 클릭, 드래그, 저장, 실패 시 토스트)
를 포함해, “이 문서만으로도 바이브 코딩 프롬프트를 쓸 수 있도록” 설계합니다.[^22_13][^22_7]

***

## 빠진 부분 체크 및 추가 제안

위 4개 디렉터리 구성을 통해, 다음 축은 모두 커버됩니다.

- 서비스 기획·도메인·요구사항
- 워크플로우/노드/연결/데이터/실행/디버깅 구조
- 멀티에이전트/데이터/RAG/LLM/백엔드/프론트/운영 전체 가이드
- Monorepo·환경변수·CI/CD·Runbook
- UX/UI·컴포넌트 트리·Wireframe

추가로 고려하면 좋은 항목:

- **보안·프라이버시 별도 섹션**: 데이터 분류, DPA/GDPR, 권한 모델 문서.
- **Prompt Library 디렉터리**:
    - `/prompts/architecture`, `/prompts/components`, `/prompts/tests`, `/prompts-refactor` 등 바이브 코딩용 프롬프트 자산.[^22_4][^22_14]
- **Playbook/Checklist**:
    - “새 기능 추가 시 체크리스트”, “릴리즈 전 체크리스트”, “AI 기능 위험성 평가 체크리스트”.

이 구조대로 .md 파일과 폴더를 만들면, **서비스 설계→구현→운영→확장** 전 구간을 바이브 코딩에 최적화된 아키텍처 문서 세트로 덮을 수 있습니다.
<span style="display:none">[^22_34][^22_35][^22_36][^22_37][^22_38]</span>

<div align="center">⁂</div>

[^22_1]: https://dev.to/wasp/a-structured-workflow-for-vibe-coding-full-stack-apps-352l

[^22_2]: https://vfunction.com/blog/vibe-coding-architecture-ai-agents/

[^22_3]: https://blog.langchain.com/langgraph-multi-agent-workflows/

[^22_4]: https://strapi.io/blog/vibe-coding-prompt-techniques

[^22_5]: https://elementor.com/blog/what-is-n8n/

[^22_6]: https://tuanla.vn/post/n8n/

[^22_7]: https://www.pronextjs.dev/workshops/next-js-react-server-component-rsc-architecture-jbvxk/understanding-the-example-monorepo-structure-4gpny

[^22_8]: https://github.com/belgattitude/nextjs-monorepo-example/blob/main/README.md

[^22_9]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^22_10]: https://buymeacoffee.com/afgarabote/building-modern-full-stack-applications-next-js-fastapi-supabase-vercel

[^22_11]: https://forum.cursor.com/t/best-practices-for-structuring-a-next-js-fastapi-supabase-project/49706

[^22_12]: https://github.com/cpjet64/vibecoding/blob/main/prompt-engineering-guide.md

[^22_13]: https://www.youtube.com/watch?v=QFVEuG3IKuc

[^22_14]: https://supabase.com/blog/vibe-coding-best-practices-for-prompting

[^22_15]: https://wikidocs.net/290941

[^22_16]: https://deepwiki.com/n8n-io/n8n-docs/2.1-workflows-and-data-flow

[^22_17]: https://docs.n8n.io/workflows/

[^22_18]: https://docs.n8n.io/workflows/components/nodes/

[^22_19]: https://wikidocs.net/310103

[^22_20]: https://wikidocs.net/302246

[^22_21]: https://dev.to/jamiu__tijani/implementing-langgraph-for-multi-agent-ai-systems-4fck

[^22_22]: https://wikidocs.net/290964

[^22_23]: https://docs.n8n.io/integrations/builtin/credentials/

[^22_24]: https://www.reco.ai/hub/secure-n8n-workflows

[^22_25]: https://docs.n8n.io/flow-logic/error-handling/

[^22_26]: https://docs.n8n.io/data/data-pinning/

[^22_27]: https://docs.n8n.io/data/data-mocking/

[^22_28]: https://mainly.nz/n8n-error-handling-best-practices/

[^22_29]: https://kr.linkedin.com/pulse/no-code-ai-오케스트레이션-google-opal기술-백서-whitepaper-keonwoo-park-6o9qc

[^22_30]: https://developers.googleblog.com/en/introducing-opal/

[^22_31]: https://langchain-ai.github.io/langgraph/agents/multi-agent/

[^22_32]: https://dev.to/hulk-pham/building-a-multi-agent-ai-with-langgraph-a-comprehensive-guide-57nj

[^22_33]: https://www.futuremarketinsights.com/reports/ai-platform-market

[^22_34]: https://dzone.com/articles/full-stack-app-with-vibe-coding-prompts

[^22_35]: https://www.reddit.com/r/vibecoding/comments/1n66j86/thoughts_on_vibe_coded_architecture/

[^22_36]: https://www.rocket.new/blog/practical-vibe-coding-prompt-examples-for-engaging-projects

[^22_37]: https://www.reddit.com/r/nextjs/comments/1d770yb/best_backend_for_nextjs_app/

[^22_38]: https://www.notion.com/templates/prompt-for-vibe-coders-software-architecture


---

# 각 가이드북별 목차와 주요 챕터 제안해줘

각 가이드북을 “실제 한 권짜리 문서” 기준으로, 목차와 핵심 챕터만 촘촘히 제안합니다. 바이브 코딩/에이전트/워크플로우 관점에서 필요한 부분이 빠지지 않도록 구성했습니다.[^23_1][^23_2][^23_3]

***

## 1. 비전·요구사항 정의 가이드

1. 서론
1.1 이 문서의 목적
1.2 대상 독자(경영진, PM, Tech Lead)
2. 서비스 비전과 성공 지표
2.1 서비스 비전·미션
2.2 North Star Metric 정의
2.3 핵심 KPI 세트 (획득·활성·수익·리텐션)
3. 시장·경쟁·포지셔닝
3.1 글로벌 시장 분석
3.2 경쟁 서비스 맵 \& 차별점
4. 사용자 · 이해관계자 분석
4.1 주요 페르소나 프로파일
4.2 내부 이해관계자(운영·CS·영업) 니즈
5. 요구사항 정의 (기능)
5.1 유저스토리 \& Use Case 목록
5.2 기능 요구사항(Feature 리스트 + 우선순위)
5.3 워크플로우 기반 기능 정의(“사용자 행동 → 자동화 흐름”)
6. 요구사항 정의 (비기능)
6.1 성능·확장성·가용성 요구
6.2 보안·규제·프라이버시 요구
6.3 국제화(i18n), 로컬라이제이션(L10n), 접근성
7. 성공 기준 및 가설
7.1 출시 시점 성공 기준
7.2 실험/파일럿 가설(어떤 워크플로우가 어떤 KPI를 바꿀 것인가)
8. 바이브 코딩을 위한 요구사항 표현 템플릿
8.1 “의도 중심” 요구사항 작성 포맷
8.2 예시 프롬프트 (기능·워크플로우·화면)

***

## 2. 도메인 모델링 \& 페르소나·세그먼트 설계 가이드

1. 도메인 모델링 개요
2. 핵심 도메인 엔티티 정의
2.1 User / Organization / Workspace
2.2 Project / Workflow / Node / Execution / Log
2.3 Template / Integration / Credential
3. 관계 다이어그램 \& 제약
3.1 ERD / C4 Level 2
3.2 데이터 수명주기(Lifecycle)
4. 페르소나 설계
4.1 Primary 페르소나(예: 마케터, CS 리더, PM)
4.2 Secondary 페르소나(엔지니어, Admin 등)
4.3 페르소나별 주요 시나리오
5. 세그먼트 설계
5.1 회사 규모별(Tier1~3)
5.2 지역/언어별
5.3 유료/무료/트라이얼/엔터프라이즈 플랜
6. 도메인 이벤트 \& 워크플로우 연계
6.1 도메인 이벤트 카탈로그(예: NewLeadCreated, CampaignFinished)
6.2 각 이벤트와 워크플로우 Trigger 매핑
7. RAG·에이전트와 도메인 모델 연결
7.1 어떤 엔티티가 검색/요약/추천에 사용되는가
7.2 메타데이터 설계(템플릿/사용 이력 기반 추천)

***

## 3. 멀티에이전트 아키텍처 설계 가이드 (LangGraph)

1. LangGraph \& 멀티에이전트 개요[^23_3][^23_4]
2. 에이전트 역할 정의
2.1 Planner / Orchestrator
2.2 Researcher / Retriever
2.3 Coder / Tool Executor
2.4 Evaluator / Guardrail Agent
3. State \& Graph 설계
3.1 State 구조(메모리, 컨텍스트, 중간 결과)
3.2 노드(StateGraph node)와 에지(전이 조건)
4. 패턴별 아키텍처
4.1 Supervisor + Worker 에이전트 패턴[^23_4][^23_5]
4.2 Router 에이전트 패턴
4.3 Reflection/검증 루프 패턴
5. 서비스 도메인에 맵핑
5.1 마케팅 자동화 에이전트 구조
5.2 CS 지식 응답 에이전트 구조
6. 실패·안전·거버넌스
6.1 에이전트 폭주 방지(루프, 비용)
6.2 정책/Guardrail 에이전트 설계
7. 바이브 코딩용 멀티에이전트 설계 프롬프트 템플릿

***

## 4. 데이터 \& RAG 인프라(Qdrant + Supabase) 설계 가이드

1. 데이터 인프라 개요[^23_6]
2. OLTP(Supabase/Postgres) 설계
2.1 핵심 테이블 스키마
2.2 다국어/타임존/Soft Delete 전략
3. RAG 인프라 (Qdrant)
3.1 컬렉션 설계(문서, 템플릿, FAQ, 실행 로그)
3.2 인덱싱 파이프라인(분할, 임베딩, 메타데이터)
4. ETL/동기화 워크플로우
4.1 배치/스트리밍 패턴
4.2 에러 처리·재시도·관찰성
5. 데이터 등급과 보안
5.1 PII/비PII 분류
5.2 마스킹/토큰화·권한
6. RAG + 에이전트 통합 패턴
6.1 Retrieval → Planning → Generation 흐름
6.2 검색 품질 평가 루프

***

## 5. LLM 레이어 \& 프롬프트 엔지니어링 가이드

1. LLM 레이어 개요[^23_7]
2. 모델 전략
2.1 모델 선택 기준(가격·지연·품질)
2.2 모델 믹스 전략(가벼운 모델 vs 고성능 모델)
3. 프롬프트 아키텍처
3.1 시스템/역할/사용자/도구 프롬프트 구조
3.2 체인/에이전트 프롬프트 분리
4. 바이브 코딩 프롬프트 패턴[^23_8][^23_9][^23_1]
4.1 아키텍처 생성 프롬프트
4.2 컴포넌트/화면 생성 프롬프트
4.3 테스트/리팩토링 프롬프트
5. 프롬프트 버전 관리와 실험
5.1 프롬프트 카탈로그 구조
5.2 A/B 테스트 및 품질 평가
6. 안전·가드레일
6.1 정책 프롬프트
6.2 금칙어·조건 기반 필터링

***

## 6. 서비스 Workflow 설계 \& LangGraph 구현 가이드

1. 워크플로우 설계 원칙[^23_10][^23_11]
2. 비즈니스 시나리오별 워크플로우
2.1 온보딩 플로우
2.2 캠페인/자동화 플로우
2.3 리포트 생성 플로우
3. 워크플로우 → 그래프 변환
3.1 노드 정의(트리거, 액션, 코어)
3.2 데이터·자격 증명·에러 처리 설계[^23_12][^23_13]
4. LangGraph 구현
4.1 StateGraph 정의
4.2 노드 구현 패턴(도구 호출, 에이전트 호출)[^23_14][^23_4]
5. 테스트 \& 디버깅
5.1 단위 테스트, 시나리오 테스트
5.2 실행 로그·시각화·재실행 전략

***

## 7. 백엔드(FastAPI) API \& 통합 가이드

1. 전체 백엔드 아키텍처[^23_15][^23_6]
2. FastAPI 프로젝트 구조
2.1 모듈·레이어링(라우터, 서비스, 리포지토리, 스키마)
3. 도메인 API 설계
3.1 인증·권한(Workspace, Role-based)
3.2 워크플로우/노드/실행/로그 API
4. LangGraph 호출 엔드포인트
4.1 Sync/Async 호출 패턴
4.2 백그라운드 작업 처리
5. 외부 서비스 통합
5.1 ESP, Slack, Stripe, CRM 연동
5.2 공통 통합 모듈 설계
6. 테스트 \& Observability
6.1 유닛/통합 테스트 구조
6.2 로깅·메트릭·트레이싱 연동

***

## 8. 프론트엔드(Next.js PWA) 설계·구현 가이드

1. 프론트엔드 아키텍처[^23_16][^23_17]
2. Next.js 구조
2.1 app router, layout, route group 설계
2.2 국제화, SEO, PWA 설정
3. 상태·데이터 패턴
3.1 RSC vs Client Components
3.2 TanStack Query 또는 SWR 정책
4. UI 컴포넌트 시스템
4.1 shadcn/ui 기반 디자인 시스템
4.2 Tailwind 유틸 규칙
4.3 컴포넌트 트리·스토리북 구성
5. 워크플로우 에디터 구현
5.1 노드 그래프 UI, 드래그·줌·선 연결
5.2 속성 패널, 데이터 미리보기, 실행 컨트롤
6. 성능·접근성 최적화

***

## 9. ESP(메일 발송 시스템) 연동 \& AB 테스트 가이드

1. ESP 선택·아키텍처
2. 템플릿·세그먼트 설계
3. Webhook/Events 처리 워크플로우
4. A/B 테스트 프레임워크
4.1 실험 설계
4.2 지표·기간·분석
5. 법적·스팸 정책 고려(Opt-in/Opt-out, Footer 등)

***

## 10. Observability/로깅/평가/거버넌스 가이드

1. Observability 개요[^23_18][^23_19]
2. 로깅 전략(구조화, PII 분리)
3. 메트릭·알람 설계
3.1 성공률, 지연, 오류 분류, LLM 비용
4. 트레이싱(분산 트레이싱)
5. AI 품질 평가·피드백 루프
5.1 유저 피드백 수집
5.2 자동·수동 평가
6. AI 거버넌스
6.1 프롬프트/모델 변경 관리
6.2 사용 정책·리스크 리뷰 프로세스

***

## 11. 배포·운영·CI/CD \& 비용 최적화 가이드

1. 배포 전략(환경·리전)[^23_20][^23_6]
2. Monorepo CI/CD 파이프라인
2.1 빌드 캐시, 테스트 단계, 프론트/백 분리 배포
3. 인프라 as Code
4. 비용 모니터링 \& 최적화
4.1 LLM 호출·스토리지·트래픽 비용
4.2 FinOps 대시보드·알람
5. 롤백·릴리즈 전략

***

## 12. 운영 Runbook \& 확장(고도화) 시나리오 가이드

1. Runbook 개요
2. 장애 유형별 대응 플로우
2.1 API 장애, LLM 장애, DB 장애, 외부 통합 장애
3. 인시던트 관리 프로세스
4. 확장 시나리오
4.1 기능 확장 (새 워크플로우/노드)
4.2 성능 확장(멀티리전·샤딩·캐싱)
4.3 조직 확장(엔터프라이즈 플랜, 멀티테넌시)

***

이 목차 세트를 기반으로 각 .md를 작성하면, “기획 → 도메인 → 에이전트 → 데이터/RAG → LLM/프롬프트 → 워크플로우 → 백/프론트 → ESP → Observability → 배포/운영 → Runbook”까지 전체 라이프사이클을 바이브 코딩 친화적으로 완전히 덮을 수 있습니다.[^23_2][^23_1][^23_3]

<div align="center">⁂</div>

[^23_1]: https://dev.to/wasp/a-structured-workflow-for-vibe-coding-full-stack-apps-352l

[^23_2]: https://vfunction.com/blog/vibe-coding-architecture-ai-agents/

[^23_3]: https://blog.langchain.com/langgraph-multi-agent-workflows/

[^23_4]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^23_5]: https://dev.to/hulk-pham/building-a-multi-agent-ai-with-langgraph-a-comprehensive-guide-57nj

[^23_6]: https://buymeacoffee.com/afgarabote/building-modern-full-stack-applications-next-js-fastapi-supabase-vercel

[^23_7]: https://supabase.com/blog/vibe-coding-best-practices-for-prompting

[^23_8]: https://strapi.io/blog/vibe-coding-prompt-techniques

[^23_9]: https://github.com/cpjet64/vibecoding/blob/main/prompt-engineering-guide.md

[^23_10]: https://docs.n8n.io/workflows/

[^23_11]: https://deepwiki.com/n8n-io/n8n-docs/2.1-workflows-and-data-flow

[^23_12]: https://wikidocs.net/290941

[^23_13]: https://docs.n8n.io/flow-logic/error-handling/

[^23_14]: https://dev.to/jamiu__tijani/implementing-langgraph-for-multi-agent-ai-systems-4fck

[^23_15]: https://forum.cursor.com/t/best-practices-for-structuring-a-next-js-fastapi-supabase-project/49706

[^23_16]: https://www.pronextjs.dev/workshops/next-js-react-server-component-rsc-architecture-jbvxk/understanding-the-example-monorepo-structure-4gpny

[^23_17]: https://elementor.com/blog/what-is-n8n/

[^23_18]: https://www.futuremarketinsights.com/reports/ai-platform-market

[^23_19]: https://www.reco.ai/hub/secure-n8n-workflows

[^23_20]: https://github.com/belgattitude/nextjs-monorepo-example/blob/main/README.md


---

# [관련성 체커(Relevance Checker) 모듈 추가](https://wikidocs.net/267810)  포함하여

그리고 비용적인 부분에 부담으로 인해 open router를 기반으로 구축합니다.
langchain과 langgraph를 혼합하여 구성합니다.
바이브 코딩을 위해 필요한 system, user, assistant, developer, tool 프롬프트는 “메시지의 역할(role)” 기준으로 나뉘는 5가지 프롬프트 구분에 대한 내용도 요구됩니다.

질문에 추가된 세 가지 축을 반영해서, 기존 설계에 **무엇을 어떻게 더해야 완전해지는지**만 딱 짚어 정리하겠습니다.[^24_1][^24_2][^24_3]

***

## 1. Relevance Checker 모듈 편입: 어디에 넣을 것인가

관련성 체커(Relevance Checker)는 **RAG + LangGraph 워크플로우의 “검색 결과 검증 루프”**입니다.[^24_1]

### 편입 위치

- 디렉터리 3의 **`04-data-rag-infra.md`**와 **`06-service-workflows-and-langgraph.md`**에 다음 챕터를 추가합니다.

1) `04-data-rag-infra.md`에 추가

- “4.x 관련성 체커(Relevance Checker) 모듈”
    - 역할:
        - `question, context`를 입력받아 “이 context가 질문에 실제로 관련 있는가?”를 yes/no 또는 score로 평가.[^24_1]
    - 구현 패턴:
        - LangChain Runnable/Chain으로 `question_answer_relevant` 정의
        - 프롬프트 예시(groundedness / relevance 체크용 템플릿)
    - 설정 항목:
        - 기준 임계값(threshold), 재검색 회수 제한, 로그/모니터링(얼마나 자주 no가 나오는지).[^24_1]

2) `06-service-workflows-and-langgraph.md`에 추가

- “3.x Relevance Check 라우팅 패턴”
    - retrieve → relevance_check → (yes → llm_answer, no → retrieve) 구조를 LangGraph 예제로 포함.[^24_1]
    - `GraphState`에 `question, context, relevance` 필드 정의, `is_relevant` 라우터 함수와 재귀 한도(recursion_limit) 설정을 예시로 명시.[^24_4][^24_1]
    - GraphRecursionError 방지 전략(재시도 횟수, fallback 응답 정책)까지 포함.

***

## 2. OpenRouter + LangChain + LangGraph 혼합: 아키텍처·가이드 반영

### 2-1. OpenRouter 기반 LLM 인프라

다음 문서에 OpenRouter 전용 챕터를 추가합니다.

1) `05-llm-and-prompt-engineering.md`

- “2.x LLM Provider 전략 – OpenRouter 중심”
    - OpenRouter를 기본 LLM 게이트웨이로 두고, 모델 선택을 config 기반으로 하는 구조.[^24_2]
    - 장점: 다수 모델 / 비용 최적화 / 지역 제약 우회.
    - 구현 가이드:
        - LangChain에서 OpenRouter Chat 모델 래퍼 사용
        - 모델 이름·max_tokens·temperature를 환경변수로 주입.

2) `monorepo-structure-and-env.md`

- OpenRouter 관련 환경변수: `OPENROUTER_API_KEY`, `OPENROUTER_BASE_URL`, 모델 기본값.
- 환경별(Dev/Stage/Prod) 다른 모델/가격대 구성.


### 2-2. LangChain + LangGraph 혼합 패턴

아키텍처 상에서 제1원칙은 **“LangChain은 빌딩블록, LangGraph는 오케스트레이션 런타임”**입니다.[^24_5][^24_2]

1) `03-multi-agent-architecture.md`

- “3.x LangChain 컴포넌트 재사용 전략”
    - Retriever, PromptTemplate, Tool, Chains는 LangChain으로 정의.
    - 이들을 LangGraph의 Node 함수 안에서 호출하는 패턴 정리.[^24_2][^24_5]
    - 예:
        - `pdf_retriever = …` (LangChain)
        - `def retrieve(state: GraphState): retriever.invoke(state["question"])` (LangGraph node).[^24_5][^24_1]

2) `06-service-workflows-and-langgraph.md`

- “4.x LangChain → LangGraph 마이그레이션 체크리스트”[^24_2]
    - 1단계: LangChain으로 체인/RAG/프롬프트 검증
    - 2단계: 검증된 컴포넌트를 LangGraph 노드로 감싸 그래프로 조립
    - 3단계: 상태/체크포인트/에러 핸들링 추가.

***

## 3. 5가지 role(system / user / assistant / developer / tool) 프롬프트 가이드 추가

바이브 코딩을 안정적으로 쓰려면, **메시지 role별 책임을 정교하게 분리**해야 합니다.[^24_6][^24_7][^24_3]

### 3-1. 전용 가이드북 챕터

`05-llm-and-prompt-engineering.md`에 아래 챕터 추가:

- “3. 메시지 역할(role)별 프롬프트 설계”


#### (1) developer (구 system) 역할

- 목적: 모델의 **장기적 행동 규칙, 스타일, 금칙사항, 도메인 정책** 정의.[^24_7][^24_8][^24_3]
- 특징:
    - 가장 높은 우선순위, 잘 변하지 않는 “헌법/규칙서”에 가까운 내용.
- 예:
    - “너는 글로벌 워크플로우 빌더 SaaS의 아키텍트 어시스턴트이다. 항상 보안·비용·거버넌스를 고려해 답한다.”
    - “프롬프트 예시는 JSON 코드블록으로만 답하고, 한국어 설명을 함께 제공한다.”


#### (2) system 역할

- 목적: **런타임 컨텍스트·툴 응답·상태 요약** 제공.[^24_7]
- 예:
    - 이전 대화 요약, 현재 워크플로우 상태, 관련성 체크 결과(예: “현재 검색 결과는 질문과의 관련성이 낮음”)를 system 메시지로 공급.
    - Tool 호출 결과를 system으로 제공해 모델이 “이건 도구가 준 정보”임을 알게 하는 패턴.[^24_7]


#### (3) user 역할

- 목적: 인간 사용자의 **의도·요구사항·질문·명령** 전달.[^24_9][^24_6]
- 바이브 코딩용 user 패턴:
    - “이런 기능을 가진 글로벌 서비스 화면을 설계해줘”,
    - “아래 요구사항을 만족하는 LangGraph 그래프 정의 코드를 생성해줘” 등.


#### (4) assistant 역할

- 목적: LLM **응답을 표현**하는 채널; 모델이 만든 코드·설계·설명을 여기에 기록.[^24_6][^24_9]
- 전략:
    - assistant 응답 중 일부를 다시 system 또는 developer로 승격시켜 “새로운 규칙/패턴”으로 재사용하는 메커니즘도 포함(예: 프롬프트 라이브러리 업데이트).[^24_4]


#### (5) tool 역할

- 목적: **외부 도구 호출·결과**를 표현하는 전용 역할.[^24_6]
- 예:
    - LangChain의 Tools, LangGraph ToolNode, n8n HTTP Request 결과 등을 tool 메시지로 싱크.
    - 모델이 “지금은 내 추론이 아니라 도구 결과를 읽는 단계”임을 명확히 알도록 설계.


### 3-2. 역할별 템플릿·모듈화

동일 문서에 다음 섹션을 추가:

- “3.x 역할별 프롬프트 템플릿 모듈”
    - `/prompts/developer/*.md`: 제품 전역 규칙, 보안/거버넌스, 톤/스타일.
    - `/prompts/system/*.md`: 각 워크플로우/에이전트별 상태·컨텍스트 요약 템플릿.
    - `/prompts/user/*.md`: 기획/설계/코드 생성/리팩토링/테스트용 바이브 코딩 유저 프롬프트 템플릿.
    - `/prompts/tool/*.md`: 도구 응답 포맷, LLM이 해석하기 쉬운 JSON 스키마.[^24_3][^24_10]

***

## 4. 전체 설계에 대한 “누락 여부” 점검 요약

질문에서 추가하신 요구까지 반영하면, 다음이 모두 커버됩니다.

- Relevance Checker 모듈: RAG/워크플로우/에이전트 레벨에서의 관련성·Groundedness 검증 + 재검색 루프.[^24_1]
- OpenRouter 기반 LLM 인프라: 비용·모델 선택 전략, LangChain 래퍼, 환경변수 설계.[^24_2]
- LangChain + LangGraph 혼합 구조: LangChain=컴포넌트, LangGraph=그래프 및 상태·에러 런타임.[^24_5][^24_2]
- 5 role 프롬프트 체계: developer/system/user/assistant/tool 각각의 책임·예시·템플릿 구조.[^24_3][^24_7]

이 추가 챕터들을 각 가이드북에 삽입하면, **바이브 코딩으로 글로벌 서비스를 설계·생성·운영하는데 필요한 구조적 요소는 빠진 것이 없다고 봐도 될 수준**까지 올라갑니다.
<span style="display:none">[^24_11][^24_12][^24_13][^24_14][^24_15][^24_16][^24_17][^24_18][^24_19][^24_20][^24_21]</span>

<div align="center">⁂</div>

[^24_1]: https://wikidocs.net/267810

[^24_2]: https://peliqan.io/blog/langchain-vs-langgraph/

[^24_3]: https://danbibibi.tistory.com/321

[^24_4]: https://www.swarnendu.de/blog/langgraph-best-practices/

[^24_5]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^24_6]: https://www.youtube.com/watch?v=xbpdMkTz8L4

[^24_7]: https://www.reddit.com/r/OpenAIDev/comments/1kotbif/in_the_chat_completions_api_when_should_you_use/

[^24_8]: https://glasslego.tistory.com/52

[^24_9]: https://community.openai.com/t/prompts-for-system-assistant-roles/85605

[^24_10]: https://github.com/cpjet64/vibecoding/blob/main/prompt-engineering-guide.md

[^24_11]: https://wikidocs.net/186245

[^24_12]: https://wikidocs.net

[^24_13]: https://www.egovframe.go.kr/wiki/doku.php?id=egovframework%3Acompa

[^24_14]: https://www.kieuns.com/doku.php?id=wiki%3Aplugin-syntax

[^24_15]: https://github.com/ychoi-kr/wikidocs-chobo-python/actions

[^24_16]: https://www.kieuns.com/wiki:plugin-syntax

[^24_17]: https://blog.langchain.com/building-langgraph/

[^24_18]: https://wikidocs.com

[^24_19]: https://atomic.snu.ac.kr/api.php?action=help\&recursivesubmodules=1

[^24_20]: https://www.langchain.com/langgraph

[^24_21]: http://wiki1.kr/api.php?action=help\&recursivesubmodules=1


---

```
# <q>이 추가 챕터들을 각 가이드북에 삽입하면, 바이브 코딩으로 글로벌 서비스를 설계·생성·운영하는데 필요한 구조적 요소는 빠진 것이 없다고 봐도 될 수준까지 올라갑니다.</q> 모든 내용을 포함하는 가이드 북을 단계별로 하나하나 제 1원칙 사고에 의거하여 모든 내용을 순차적으로 모두 작성하세요.
```

요청하신 수준으로 “모든 내용을 실제 가이드북 전체”로 쓰면, 단일 답변에서 수용 가능한 분량을 훨씬 초과합니다. 그래서 여기서는 **제1원칙 구조를 그대로 유지하면서도, 바로 .md로 복사해 확장 가능한 “완전한 뼈대 + 핵심 문장/예시가 포함된 초안”**까지 제공합니다. 이 틀 위에 챕터별로 세부 내용을 추가하면, 전체 백서 세트를 완성할 수 있습니다.

아래는 **1번 가이드부터 12번 가이드까지를 순서대로**, 각 문서를 그대로 `*.md` 파일로 저장해 사용할 수 있는 형태로 정리한 것입니다.

***

## 01_vision-requirements.md

**비전·요구사항 정의 가이드**

### 1. 서론

- 목적: 이 문서는 “무엇을 만들 것인가?”를 제1원칙 수준까지 분해해, 모든 설계·구현·바이브 코딩 프롬프트의 기준점을 제공한다.
- 대상: 경영진, PM, 아키텍트, 리드 엔지니어, UX 리드.


### 2. 서비스 비전과 성공 지표

2.1 비전·미션

- 비전: “비개발자도 글로벌 수준의 AI 워크플로우 서비스를 설계·실행할 수 있는 노코드 바이브 코딩 플랫폼을 제공한다.”
- 미션: “자연어(의도) → 노드 그래프(워크플로우) → 실행 가능한 글로벌 서비스”까지의 거리를 최소화한다.

2.2 North Star Metric

- NSM 예: “월간 활성 워크플로우 실행 수(Monthly Active Executions)” 또는 “활성 워크스페이스 당 월간 자동화 작업 수”.

2.3 핵심 KPI

- 유입: 신규 워크스페이스 생성 수.
- 활성: 첫 워크플로우를 만들고 실행한 사용자 비율.
- 유지: 4주 후 재실행 비율.
- 수익: 유료 플랜 전환률, 워크스페이스 당 ARPA.


### 3. 시장·경쟁·포지셔닝

3.1 시장

- 노코드/로우코드 + AI 오케스트레이션 + 멀티에이전트 워크플로우 시장 개요.
- 글로벌/로컬 경쟁자 맵(Opal, Zapier/Make/n8n, Power Platform, Bubble 등) 요약.

3.2 포지셔닝

- “Prompt-to-Workflow + 멀티에이전트 + RAG + 글로벌 UX”가 결합된 플랫폼.
- 차별점:
    - 바이브 코딩 최적화(프롬프트 템플릿과 아키텍처 가이드 내장).
    - 엔터프라이즈 급 거버넌스·관찰성·FinOps 프레임 포함.


### 4. 사용자·이해관계자 분석

4.1 페르소나(예)

- Growth 마케터, CS 리더, PM, 솔루션 컨설턴트, 엔터프라이즈 IT 관리자.

4.2 내부 이해관계자

- 운영/지원팀: 알림·로그·권한·리포팅 요구.
- 영업팀: 데모/PoC를 빠르게 구성하는 템플릿 필요.


### 5. 기능 요구사항 정의 (What)

5.1 유저스토리

- “나는 마케터로서, 신규 리드를 자동 분류·스코어링·후속 이메일 발송 워크플로우를 코드 없이 만들고 싶다.”
- “나는 CS 리더로서, 티켓 요약·분류·답장 초안을 자동화하고 싶다.”

5.2 기능 요구사항

- 워크플로우 에디터(노드·연결·데이터 미리보기).
- 실행 로그·디버깅·재실행.
- 멀티에이전트/LLM·RAG 통합.
- 통합(ESP, Slack, Stripe, CRM 등) 관리.

5.3 워크플로우 관점 요구사항

- 모든 주요 기능은 “트리거 → 노드 체인 → 결과/알림” 구조로 표현 가능해야 한다.
- 각 기능은 LangGraph 그래프로도 표현 가능해야 한다.


### 6. 비기능 요구사항 정의 (How well)

- 성능: P95 API 응답 ≤ Xms, 워크플로우 실행 지연 ≤ Y초.
- 가용성: 월 가용성 99.9% 이상(핵심 API 기준).
- 보안·규제: RBAC, 감사 로그, PII 처리, 데이터 레지던시 고려.
- 글로벌: 다국어 UI, 타임존 안전성, 통화/날짜 표현.


### 7. 성공 기준 및 실험 가설

- “파일럿 8주 내에, 기존 수동 작업 대비 평균 30% 이상의 시간 절감” 등.
- 기능별 실험 가설: 예) 관련성 체커 도입 → RAG 응답의 사용자 만족도 +20%.


### 8. 바이브 코딩 요구사항 표현 템플릿

- “다음 요구사항을 만족하는 백엔드/프론트/에이전트/워크플로우 코드를 생성해줘” 템플릿.
- 프롬프트 구조:
    - Context(비전, 목표)
    - Constraints(성능, 보안, 비용, 스택)
    - Deliverables(파일 구조, 코드 스타일, 테스트 요건)

***

## 02_domain-personas-segmentation.md

**도메인 모델링 \& 페르소나·세그먼트 설계 가이드**

### 1. 도메인 모델링 원칙

- “엔티티·관계·이벤트 수준에서 먼저 정의 → 그 다음 LLM/에이전트/워크플로우에 맵핑.”
- RAG·관찰성·과금·권한을 모두 고려.


### 2. 핵심 엔티티

- User, Organization, Workspace, Project
- Workflow, Node, Connection, Execution, Log
- Template, Integration, Credential, Agent, Dataset, VectorIndex.

각 엔티티에 대해: 필수 필드, 식별자, 수명주기, 권한 범위 정의.

### 3. 관계 및 이벤트

- Workspace ↔ User (역할: Owner/Admin/Member)
- Workspace ↔ Workflow (1:N)
- Workflow ↔ Execution (1:N)
- 주요 도메인 이벤트: `WorkflowCreated`, `ExecutionFailed`, `AgentCostExceeded`, `RelevanceCheckFailed`.


### 4. 페르소나 및 세그먼트

- 페르소나별 주요 워크플로우·화면·알림 요구를 표로 정리.

***

## 03_multi-agent-architecture.md

**멀티에이전트 아키텍처 설계 가이드 (LangGraph)**

### 1. 제1원칙: 왜 에이전트인가

- 단일 LLM 호출로는 복잡한 다단계 업무(검색→계획→실행→검증)를 안정적으로 처리하기 어렵다.
- 에이전트 = 역할과 책임이 명확한 LLM + 툴/정책 조합.


### 2. LangGraph 개념

- StateGraph: 상태(메모리)를 가진 그래프 런타임.
- 노드 = 상태를 읽고/쓰고/도구를 호출하는 함수.
- 엣지 = 상태/조건에 따른 전이.


### 3. 에이전트 역할 설계

- Planner: 전체 플랜·서브태스크 분해.
- Retriever: RAG 검색, 관련성 체커와 연계.
- ToolExecutor: API/DB/외부 서비스 호출.
- Evaluator/Guardrail: 응답 품질·정책 위반 검사.


### 4. GraphState 설계

- 필수 키: `question, context, plan, result, cost, steps, errors, relevance_score 등`.


### 5. 패턴별 그래프

- Supervisor + Worker 패턴.
- Router 패턴(입력에 따라 다른 에이전트 경로 선택).
- Reflection 패턴(초안 → 평가 → 수정 루프).

***

## 04_data-rag-infra.md

**데이터 \& RAG(Qdrant + Supabase) 설계 가이드**

### 1. 데이터 계층 구조

- OLTP(Supabase) vs Vector(RAG: Qdrant) vs 로그/메트릭(Observability).


### 2. Supabase 스키마

- 워크플로우/실행/사용자/통합/결제 테이블 설계.


### 3. Qdrant 인덱스

- 컬렉션: `docs`, `templates`, `faq`, `execution_summaries`.
- 벡터 필드, 메타데이터 필드(tenant, language, tags).


### 4. ETL/동기화 워크플로우

- n8n/Opal/LangChain 기반 인덱싱 파이프라인.


### 5. Relevance Checker 모듈

- 입력: `{question, context_chunk}`
- 출력: `{is_relevant: bool, score: float, rationale: str}`
- LangChain Runnable로 구현, LangGraph에서 노드로 사용.
- 사용 위치: RAG 단계에서 `retrieve → relevance_check → (필터/재검색)`.

***

## 05_llm-and-prompt-engineering.md

**LLM 레이어 \& 프롬프트 엔지니어링 가이드**

### 1. LLM 레이어 원칙

- 모델-불가지론: OpenRouter를 통해 다양한 모델을 사용하되, 인터페이스는 통일.
- 비용·지연·품질의 균형.


### 2. OpenRouter 전략

- 기본 모델 세트: 경량(초안/도우미), 고성능(리포트/복잡 추론)
- 환경별 설정(Dev=저렴한 모델, Prod=안정 모델).


### 3. 메시지 역할(role)별 프롬프트 설계

3.1 developer (구 system)

- 전역 규칙·정책·톤·보안·금칙사항 정의.
- 문서로 관리, 코드/에이전트 생성 시 항상 포함.

3.2 system

- 런타임 상태·컨텍스트·툴 결과 요약 제공.
- LangGraph의 state/툴 호출 결과를 system에 반영.

3.3 user

- 실제 사용자·기획자의 의도/요구사항/지시.
- 바이브 코딩 프롬프트 템플릿.

3.4 assistant

- 모델 응답 채널, 코드·설계·결과 반환.

3.5 tool

- 외부 툴/노드/에이전트 결과를 구조화된 JSON으로 표현.


### 4. 프롬프트 패턴

- 아키텍처 생성, 컴포넌트/화면 생성, 테스트 코드 생성, 리팩토링, 평가용 템플릿.

***

## 06_service-workflows-and-langgraph.md

**서비스 Workflow 설계 \& LangGraph 구현 가이드**

### 1. 워크플로우 설계 원칙

- 모든 기능을 “트리거→노드 체인→결과/알림”으로 표현.
- 각 노드는 입력/출력/에러/비용을 명확히 정의.


### 2. 대표 워크플로우 정의

- 온보딩, 리드 자동화, 리포트 생성, 알림/에러 핸들링.


### 3. Relevance Check 포함 RAG 워크플로우

- `Trigger → Retrieve → RelevanceCheck → (관련 없음 → 재검색 / 관련 있음 → LLMAnswer)`
- LangGraph 노드 코드 스케치.


### 4. LangGraph 구현

- GraphState, 노드 함수, 에지 조건, 체크포인트 설정.

***

## 07_fastapi-api-integration.md

**백엔드(FastAPI) API \& 통합 가이드**

- FastAPI 프로젝트 구조, 도메인 모듈, 인증/권한, LangGraph 호출 엔드포인트, 통합 모듈(ESP, Slack, Stripe 등), 로그/메트릭/테스트 패턴.

***

## 08_nextjs-pwa-frontend.md

**프론트엔드(Next.js PWA) 설계·구현 가이드**

- app router 구조, 다국어, PWA 세팅, shadcn/ui + Tailwind 컴포넌트 시스템, 워크플로우 에디터 UI, 실행 로그 뷰, 상태 관리 전략.

***

## 09_esp-and-ab-test.md

**ESP 연동 \& A/B 테스트 가이드**

- ESP 선택 기준, 템플릿/세그먼트 설계, Webhook 연동, 실험 설계·분석 방법.

***

## 10_observability-logging-governance.md

**Observability/로깅/평가/거버넌스 가이드**

- 구조화 로깅, 메트릭(워크플로우 성공률·지연·비용), 트레이싱, LLM 품질 평가 루프, AI 거버넌스 프로세스.

***

## 11_ci-cd-deployment-cost-optimization.md

**배포·운영·CI/CD \& 비용 최적화 가이드**

- Monorepo 구조(`apps/`, `packages/`, `infra/`), CI 파이프라인, 배포 전략, FinOps(모델 호출·스토리지·트래픽 비용 관리).

***

## 12_runbook-and-evolution-scenarios.md

**운영 Runbook \& 확장(고도화) 시나리오 가이드**

- 장애 유형별 대응 플로우(LLM 장애, RAG 장애, 외부 통합 장애 등), 인시던트 관리, 확장 시나리오(기능·성능·조직 확장).

***

이 12개 문서는 이미 **모든 축(서비스 기획, 도메인, 에이전트/LangGraph, RAG+Relevance Checker, OpenRouter+프롬프트 롤, 워크플로우/노드 구조, 백/프론트, ESP, Observability, CI/CD, Runbook)**을 포함하도록 설계되어 있습니다.[^25_1][^25_2][^25_3][^25_4]

실제 완성본을 만들고 싶다면:

- 지금 제안한 각 .md 파일에 대해,

1) “원칙·목적 문단”
2) “표/리스트로 된 구체 항목”
3) “바이브 코딩용 샘플 프롬프트·코드 스케치”
를 채워 넣는 식으로, 한 챕터씩 확장해 나가면 됩니다.

<div align="center">⁂</div>

[^25_1]: https://wikidocs.net/267810

[^25_2]: https://peliqan.io/blog/langchain-vs-langgraph/

[^25_3]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^25_4]: https://danbibibi.tistory.com/321


---

# 이어서 계속

지금까지는 12권 각각의 골격과 핵심 챕터를 제시했습니다. 이어서, **바이브 코딩에 실제로 바로 쓸 수 있는 수준으로** 각 가이드북에 공통적으로 들어가야 할 “실행 가능한 내용”을 더 구체화하겠습니다.

아래는 **각 문서에 공통으로 추가하면 좋은 3가지 레이어**입니다.

***

## A. 각 가이드북에 공통으로 추가할 섹션 1: “체크리스트”

각 문서 마지막에 `## 체크리스트`를 두고, 제1원칙 기준으로 “이게 채워져야 다음 단계로 넘어갈 수 있다”를 명시합니다.

예시 – `01_vision-requirements.md` 끝부분:

- 비전·미션이 한 문장씩 정의되어 있는가?
- NSM, 핵심 KPI가 숫자/단위 기준으로 정의되었는가?
- 주요 페르소나와 각 페르소나별 대표 워크플로우가 문서화되었는가?
- 기능 요구사항이 유저스토리 형태로 정리되어 있는가?
- 비기능 요구사항(성능, 보안, 글로벌)이 표 형태로 정리되어 있는가?
- “바이브 코딩 요구사항 프롬프트 템플릿”이 최소 3개 이상 준비되었는가?

이 패턴을 02~12번 문서에 동일하게 맞춰서 두면, **문서가 단순 설명서가 아니라 “게이트” 역할**을 합니다.

***

## B. 공통 섹션 2: “바이브 코딩용 샘플 프롬프트”

각 가이드북의 마지막 챕터에 `## 바이브 코딩 샘플 프롬프트`를 추가합니다.

예시 – `05_llm-and-prompt-engineering.md` 일부:

- developer role 예시:
> “너는 글로벌 AI 워크플로우 플랫폼의 아키텍트 어시스턴트이다. 아래 정책을 항상 따른다:
> 1) 보안과 비용·거버넌스를 최우선으로 고려한다.
> 2) 워크플로우는 항상 트리거–노드–실행–로깅–에러 처리 구조로 설계한다.
> 3) 코드 예시는 FastAPI + LangGraph + OpenRouter 조합을 기본으로 한다.
> …”
- system role 예시:
> “현재 사용자는 [마케터] 페르소나이고, 아래와 같은 워크플로우를 이미 보유하고 있다: …
> 현재 질문: …
> 최근 RAG 관련성 체커 결과: is_relevant=false 3회 연속 발생.
> 이 상황을 고려해 답변을 수정하라.”
- user role 예시:
> “위 비전·요구사항 정의를 기반으로, 멀티에이전트 아키텍처(LangGraph)를 설계하고, 다음 조건을 만족하는 Python 코드 스캐폴드를 생성해줘: …”

각 문서마다 이 식의 프롬프트를 3~5개 넣어두면, **실질적으로 “문서=프롬프트 라이브러리의 구조화 버전”**이 됩니다.

***

## C. 공통 섹션 3: “아티팩트(산출물) 템플릿”

각 가이드북에 `## 산출물 템플릿` 섹션을 두고, 이 문서를 읽고 나면 최소한 어떤 파일/표/코드가 나와야 하는지 정의합니다.

예시 – `06_service-workflows-and-langgraph.md`:

- 산출물:
    - `workflows/` 폴더에 비즈니스 워크플로우별 `.md` (시퀀스 다이어그램 + 설명).
    - `graphs/` 폴더에 LangGraph 그래프 정의 코드(`*.py`) 및 다이어그램 이미지.
    - “Relevance Checker 포함 RAG 플로우”의 예제 그래프(StateGraph 정의, 노드/엣지, 테스트 케이스).

마찬가지로:

- 03번 멀티에이전트 가이드는 `agents/` 폴더에 역할별 에이전트 정의 파일(설명 + 코드 스켈레톤).
- 04번 데이터·RAG 가이드는 `schemas/`, `embeddings/`, `etl/` 폴더에 SQL DDL, 인덱싱 파이프라인 코드 초안.
- 07/08번 백/프론트 가이드는 `apps/api/`, `apps/web/` 아래 예제 디렉터리 구조와 최소 엔드포인트/페이지 스켈레톤.

***

## 다음 단계 제안

이제 구조와 핵심 내용은 모두 잡힌 상태라서, 다음을 바로 하시면 됩니다:

1. 실제 리포 구조 만들기
    - `/docs/01_planning_design/01_vision-requirements.md`
    - `/docs/02_workflow_engine/…`
    - `/docs/03_service_guides/01~12.md`
    - `/docs/04_ux_ui_wireframes/…`
2. 위에 정리한 목차·핵심 문장·체크리스트·샘플 프롬프트·산출물 템플릿을 그대로 복사해 초기 버전 작성.
3. 이후에는 **가장 우선순위 높은 2~3권**부터 세부 내용을 채우면서, 병행해서 그 내용을 그대로 OpenRouter + LangChain + LangGraph에 먹이는 “메타 프롬프트”를 작성하시면 됩니다.
    - 예: `vision-requirements.md`를 context로 주고, “여기에 맞는 LangGraph 스캐폴드 생성” 같은 식.

원하시면, 다음 턴에서 특정 가이드북 하나(예: 05 LLM/프롬프트 가이드 또는 06 워크플로우 \& LangGraph 가이드)를 골라 **실제 본문까지 꽤 자세하게 써 드릴 수 있습니다**.

---

# 요청하신 구조를 기준으로, 글로벌 바이브 코딩 기반 서비스를 처음 기획 → 설계·구현 → 운영·확장까지 커버하는 “4개 디렉터리 · 백서 세트”에 필요한 항목을 빠짐없이 나열하겠습니다. 각 항목은 .md 한 파일 또는 섹션 수준으로 설계할 수 있습니다.​

디렉터리 1: 서비스 개발 기획·설계 가이드 (/01_planning_design)
목표: “무엇을 만들 것인지(What)”를 바이브 코딩에 적합한 형태로 완전히 구조화.​
1-1. Vision \& 요구사항 정의
vision-and-goals.md
서비스 비전, 미션, 성공 지표(North Star, 핵심 KPI).
글로벌 타깃 시장, 언어/지역 범위, 브랜딩 톤.
requirements-functional-nonfunctional.md
기능 요구사항(Feature 목록, 유저스토리, 우선순위 MoSCoW).
비기능 요구사항: 성능, 보안, 가용성, 다국어, 접근성, 규제 요구사항 등.​
personas-and-segments.md
대표 유저 페르소나(2~5개), 국내/글로벌 세그먼트 정의.
유저 여정(Journey)와 주요 터치포인트.
1-2. 도메인 모델링 \& 정보 구조
domain-modeling.md
핵심 엔티티(예: User, Organization, Project, Workspace, Template, Automation, Event, Log).
엔티티 간 관계 다이어그램, 다국어/통화/타임존 처리 규칙.​
information-architecture.md
IA: 메뉴 구조, 네비게이션, 정보 계층(프로젝트 > 워크플로우 > 실행 등).
URL 설계, 글로벌 URL 전략(언어 코드, 리전 필드 등).
1-3. 기술 스택 \& 아키텍처 방향
tech-stack-and-constraints.md
프론트: Next.js 14 PWA, shadcn/ui, Tailwind, LangGraph 클라이언트 사용 여부 등.​
백엔드: FastAPI, LangGraph(멀티에이전트), Supabase(Postgres+Auth+Storage), Qdrant(RAG).​
인프라: Vercel/Cloud Run/쿠버네티스, CDN, 이미지 처리, 메일 발송(ESP) 등.
제약: 예산, 팀 스킬, 타임라인.
architecture-overview.md
전체 시스템 C4 수준 다이어그램(사용자 ↔ 프론트 ↔ BFF/API ↔ DB/RAG/외부 서비스).
모놀리식 vs 모듈러 모놀리포 vs 마이크로서비스 전략 및 선택 이유.​
1-4. 개발기획서 \& 개발 플로우
development-plan.md
단계별 마일스톤: PoC → 베타 → GA → 글로벌 롤아웃.
도메인별 태스크 맵(에이전트, 데이터, API, UI).
dev-flow-and-vibe-coding-patterns.md
바이브 코딩용 프롬프트 템플릿(아키텍처/컴포넌트/테스트/리팩토링용).​
“One prompt → 스캐폴드 → 개선 프롬프트” 반복 구조 설명.​​
1-5. 화면/컴포넌트 설계
screens-and-user-flows.md
핵심 플로우별 화면: 온보딩, Workspace/Project 대시보드, Workflow 편집기, 실행 로그, 설정(Workspace/사용자/통합), 결제/플랜 등.
component-trees-and-ui-mapping.md
각 화면별 컴포넌트 트리: Layout → Header/Sidebar → PageSections → Controls.​
각 노드에 대해 shadcn/ui 또는 Tailwind 유틸/컴포넌트 매핑 테이블.
상태 관리 전략(React Server Components vs Client, tanstack-query 등) 메모.
디렉터리 2: 워크플로우 \& 노드 구조 가이드 (/02_workflow_engine)
목표: “어떻게 흐르게 만들 것인지(Flow)”를 n8n/Opal/LangGraph식 워크플로우 개념으로 표준화.​
2-1. 워크플로우 개념·레이어 모델
workflow-concepts-and-layers.md
레이어: Presentation(에디터) / Workflow Runtime / Nodes / Connections / Data / Credentials / Executions / Debugging.​
“미니앱 = 그래프(노드/엣지 + 상태)” 개념 정의.
2-2. 노드(Node) 정의 \& 카탈로그
node-basics.md
노드 타입:
트리거(웹훅, 스케줄, 이벤트)
액션(API 호출, 이메일, DB, AI 호출)
코어 로직(IF, Switch, Merge, Split, Loop, Wait)
서브그래프/에이전트(LangGraph 노드 대응).​
node-catalog.md
비즈니스 기능별 노드 카탈로그:
유저·워크스페이스 관리 노드
통합(ESP, Slack, Stripe, CRM 등) 노드
AI 노드(OpenAI/Gemini, RAG 쿼리 노드).
각 노드 정의: 입력 스키마, 출력 스키마, 옵션, 실패 시 동작.
2-3. 연결(Connection) \& 데이터(Data) 흐름
connections-and-flow-control.md
단일/병렬 경로, 브랜치, 합류(Merge), 의존관계, 순서 결정 규칙.​
LangGraph StateGraph와의 맵핑(노드 간 edge, 메시지/상태 전달).​
data-model-in-workflows.md
워크플로우 내 데이터 구조: items[] 배열, JSON 구조, 멀티모달(텍스트+파일) 취급.​
각 단계에서 데이터 변환·검증 규칙(타입, required, validation error 핸들링).
2-4. 자격 증명(Credentials) \& 시크릿
credentials-and-secrets.md
API 키·OAuth·서비스 계정 구조, 암호화 저장, 로테이션 전략.​
워크플로우에서 크리덴셜 참조 방식(스코프, 권한 최소화).​
2-5. 실행(Executions) \& 디버깅
executions-and-logging.md
실행 단위(run), 상태(대기/성공/실패), 리트라이 정책, 멱등성 설계.​
debugging-and-data-pinning.md
실행 로그 확인, 노드별 입력/출력 확인, Pin Data/Mocking 사용법 및 제약(바이너리 제한 등).​
에러 유형별 패턴(JSON Parse Error, Expression Error, 외부 API 타임아웃 등)과 대응 룰.​
2-6. PTG/Opal·LangGraph 통합 관점 (선택)
prompt-to-graph-strategy.md
Opal/유사 PTW 도구에서 자연어 → 노드 그래프 생성 전략.
그래프 품질 검증 체크리스트(루프, 에러 경로, 자격 증명, 비용).​
디렉터리 3: 서비스 개발·운영 가이드 시리즈 (/03_service_guides)
목표: 번호별 “문서 한 권” 구조를, .md 세트로 구현할 수 있게 세분화.
3-1. 1~2: 비전·요구사항·도메인·페르소나
01-vision-requirements.md → 디렉터리 1의 내용을 확장(실제 템플릿, 예시 포함).
02-domain-personas-segmentation.md → 도메인 모델링, 세그먼트별 유저스토리·기능 우선순위.
3-2. 3: 멀티에이전트 아키텍처 (LangGraph)
03-multi-agent-architecture.md
LangGraph StateGraph, 노드=에이전트, Supervisor 패턴, 서브그래프 패턴.​
역할별 에이전트 정의(Researcher, Planner, Coder, Evaluator, Router 등)와 서비스 도메인 맵핑.
3-3. 4: 데이터 \& RAG 인프라 (Qdrant + Supabase)
04-data-rag-infra.md
OLTP(Supabase Postgres) 스키마 설계, Qdrant 벡터 인덱스 구조, 인덱싱 파이프라인, 수명주기 관리.​
데이터 분류(PII/비PII), 보존 정책, 백업/복구.
3-4. 5: LLM 레이어 \& 프롬프트
05-llm-and-prompt-engineering.md
모델 선택 전략(가격/지연/품질), 시스템 프롬프트, 역할 프롬프트, 체인/에이전트용 프롬프트 패턴.​
바이브 코딩용 아키텍처 프롬프트/테스트 프롬프트 템플릿.​
3-5. 6: 서비스 Workflow \& LangGraph 구현
06-service-workflows-and-langgraph.md
비즈니스 시나리오별 워크플로우 정의(예: 캠페인 자동화, 온보딩, 리포트 생성).
각 워크플로우를 LangGraph 그래프로 표현(노드/엣지 다이어그램, 상태 스키마).​
3-6. 7~8: 백엔드(FastAPI) \& 프론트엔드(Next.js PWA)
07-fastapi-api-integration.md
API 설계(REST/GraphQL), 인증(JWT/Session), LangGraph 호출 API, 백그라운드 작업 구조.​
08-nextjs-pwa-frontend.md
앱 구조(app router, 레이아웃, 다국어, Suspense/Streaming), 상태 관리, API 통신 규칙.​
워크플로우 에디터 UI(노드 그래프, 속성 패널, 실행 로그 패널) 설계.
3-7. 9: ESP \& A/B 테스트
09-esp-and-ab-test.md
Mailgun/SendGrid 등 ESP 연동 패턴, 템플릿/세그먼트 관리.
A/B 테스트 설계(트래픽 분배, 메트릭, 실험 기간, 분석).
3-8. 10~12: Observability·배포·Runbook
10-observability-logging-governance.md
로깅(구조화 로그), 트레이싱(OpenTelemetry), 메트릭(성공률, 지연, 비용), LLM 품질 평가.​
AI 거버넌스(프롬프트·모델 변경 관리, 데이터 사용 정책).
11-ci-cd-deployment-cost-optimization.md
Monorepo 빌드 파이프라인, 환경별 배포(Dev/Staging/Prod), Canary/Blue-Green, 비용 모니터링.​
12-runbook-and-evolution-scenarios.md
운영 Runbook(장애 유형별 대응, 온콜, 롤백 절차).
확장 시나리오: 기능 추가, 리팩터링, 멀티리전, 멀티테넌시, 에이전트 확장.
monorepo-structure-and-env.md
Monorepo 디렉토리 구조(apps/, packages/, infra/), 공통 라이브러리, 테스트 전략, 환경변수/Secret 관리(.env, Vault, CI secrets).​
디렉터리 4: UX/UI \& 화면 설계 가이드 (/04_ux_ui_wireframes)
목표: 바이브 코딩 시 “레이아웃·컴포넌트·상태”까지 자연어로 명확히 표현할 수 있도록, 화면 설계를 표준화.
4-1. UX 원칙 \& 네비게이션
ux-principles-and-navigation.md
글로벌 UX 원칙(일관성, 피드백, 오류 복구, 접근성).
네비게이션 모델: 메인 레이아웃, 워크플로우 편집 모드, 설정 모드, 분석/리포트 모드.
4-2. Hi-Fi Wireframe 세트
wireframes-dashboard.md
로그인 후 대시보드 화면(프로젝트 리스트, 최근 실행, 알림).
wireframes-workflow-editor.md
캔버스/노드 목록/속성 패널/실행 로그/버전 히스토리 영역 분할.
wireframes-execution-logs-and-debugging.md
실행 이력 리스트, 상세 화면(타임라인, 노드별 입출력, 에러, 재실행 버튼).​
wireframes-settings-and-integrations.md
Workspace 설정, 멤버/권한, 통합(ESP, Slack, Stripe 등) 설정 화면.
각 wireframe 문서에는
컴포넌트 트리
shadcn/ui 컴포넌트 매핑
상태/이벤트 목록(예: 클릭, 드래그, 저장, 실패 시 토스트)
를 포함해, “이 문서만으로도 바이브 코딩 프롬프트를 쓸 수 있도록” 설계합니다.​​
빠진 부분 체크 및 추가 제안
위 4개 디렉터리 구성을 통해, 다음 축은 모두 커버됩니다.
서비스 기획·도메인·요구사항
워크플로우/노드/연결/데이터/실행/디버깅 구조
멀티에이전트/데이터/RAG/LLM/백엔드/프론트/운영 전체 가이드
Monorepo·환경변수·CI/CD·Runbook
UX/UI·컴포넌트 트리·Wireframe
추가로 고려하면 좋은 항목:
보안·프라이버시 별도 섹션: 데이터 분류, DPA/GDPR, 권한 모델 문서.
Prompt Library 디렉터리:
/prompts/architecture, /prompts/components, /prompts/tests, /prompts-refactor 등 바이브 코딩용 프롬프트 자산.​
Playbook/Checklist:
“새 기능 추가 시 체크리스트”, “릴리즈 전 체크리스트”, “AI 기능 위험성 평가 체크리스트”.
이 구조대로 .md 파일과 폴더를 만들면, 서비스 설계→구현→운영→확장 전 구간을 바이브 코딩에 최적화된 아키텍처 문서 세트로 덮을 수 있습니다.

각 가이드북을 “실제 한 권짜리 문서” 기준으로, 목차와 핵심 챕터만 촘촘히 제안합니다. 바이브 코딩/에이전트/워크플로우 관점에서 필요한 부분이 빠지지 않도록 구성했습니다.​

1. 비전·요구사항 정의 가이드
서론
1.1 이 문서의 목적
1.2 대상 독자(경영진, PM, Tech Lead)
서비스 비전과 성공 지표
2.1 서비스 비전·미션
2.2 North Star Metric 정의
2.3 핵심 KPI 세트 (획득·활성·수익·리텐션)
시장·경쟁·포지셔닝
3.1 글로벌 시장 분석
3.2 경쟁 서비스 맵 \& 차별점
사용자 · 이해관계자 분석
4.1 주요 페르소나 프로파일
4.2 내부 이해관계자(운영·CS·영업) 니즈
요구사항 정의 (기능)
5.1 유저스토리 \& Use Case 목록
5.2 기능 요구사항(Feature 리스트 + 우선순위)
5.3 워크플로우 기반 기능 정의(“사용자 행동 → 자동화 흐름”)
요구사항 정의 (비기능)
6.1 성능·확장성·가용성 요구
6.2 보안·규제·프라이버시 요구
6.3 국제화(i18n), 로컬라이제이션(L10n), 접근성
성공 기준 및 가설
7.1 출시 시점 성공 기준
7.2 실험/파일럿 가설(어떤 워크플로우가 어떤 KPI를 바꿀 것인가)
바이브 코딩을 위한 요구사항 표현 템플릿
8.1 “의도 중심” 요구사항 작성 포맷
8.2 예시 프롬프트 (기능·워크플로우·화면)
2. 도메인 모델링 \& 페르소나·세그먼트 설계 가이드
도메인 모델링 개요
핵심 도메인 엔티티 정의
2.1 User / Organization / Workspace
2.2 Project / Workflow / Node / Execution / Log
2.3 Template / Integration / Credential
관계 다이어그램 \& 제약
3.1 ERD / C4 Level 2
3.2 데이터 수명주기(Lifecycle)
페르소나 설계
4.1 Primary 페르소나(예: 마케터, CS 리더, PM)
4.2 Secondary 페르소나(엔지니어, Admin 등)
4.3 페르소나별 주요 시나리오
세그먼트 설계
5.1 회사 규모별(Tier1~3)
5.2 지역/언어별
5.3 유료/무료/트라이얼/엔터프라이즈 플랜
도메인 이벤트 \& 워크플로우 연계
6.1 도메인 이벤트 카탈로그(예: NewLeadCreated, CampaignFinished)
6.2 각 이벤트와 워크플로우 Trigger 매핑
RAG·에이전트와 도메인 모델 연결
7.1 어떤 엔티티가 검색/요약/추천에 사용되는가
7.2 메타데이터 설계(템플릿/사용 이력 기반 추천)
3. 멀티에이전트 아키텍처 설계 가이드 (LangGraph)
LangGraph \& 멀티에이전트 개요​
에이전트 역할 정의
2.1 Planner / Orchestrator
2.2 Researcher / Retriever
2.3 Coder / Tool Executor
2.4 Evaluator / Guardrail Agent
State \& Graph 설계
3.1 State 구조(메모리, 컨텍스트, 중간 결과)
3.2 노드(StateGraph node)와 에지(전이 조건)
패턴별 아키텍처
4.1 Supervisor + Worker 에이전트 패턴​
4.2 Router 에이전트 패턴
4.3 Reflection/검증 루프 패턴
서비스 도메인에 맵핑
5.1 마케팅 자동화 에이전트 구조
5.2 CS 지식 응답 에이전트 구조
실패·안전·거버넌스
6.1 에이전트 폭주 방지(루프, 비용)
6.2 정책/Guardrail 에이전트 설계
바이브 코딩용 멀티에이전트 설계 프롬프트 템플릿
4. 데이터 \& RAG 인프라(Qdrant + Supabase) 설계 가이드
데이터 인프라 개요​
OLTP(Supabase/Postgres) 설계
2.1 핵심 테이블 스키마
2.2 다국어/타임존/Soft Delete 전략
RAG 인프라 (Qdrant)
3.1 컬렉션 설계(문서, 템플릿, FAQ, 실행 로그)
3.2 인덱싱 파이프라인(분할, 임베딩, 메타데이터)
ETL/동기화 워크플로우
4.1 배치/스트리밍 패턴
4.2 에러 처리·재시도·관찰성
데이터 등급과 보안
5.1 PII/비PII 분류
5.2 마스킹/토큰화·권한
RAG + 에이전트 통합 패턴
6.1 Retrieval → Planning → Generation 흐름
6.2 검색 품질 평가 루프
5. LLM 레이어 \& 프롬프트 엔지니어링 가이드
LLM 레이어 개요​
모델 전략
2.1 모델 선택 기준(가격·지연·품질)
2.2 모델 믹스 전략(가벼운 모델 vs 고성능 모델)
프롬프트 아키텍처
3.1 시스템/역할/사용자/도구 프롬프트 구조
3.2 체인/에이전트 프롬프트 분리
바이브 코딩 프롬프트 패턴​
4.1 아키텍처 생성 프롬프트
4.2 컴포넌트/화면 생성 프롬프트
4.3 테스트/리팩토링 프롬프트
프롬프트 버전 관리와 실험
5.1 프롬프트 카탈로그 구조
5.2 A/B 테스트 및 품질 평가
안전·가드레일
6.1 정책 프롬프트
6.2 금칙어·조건 기반 필터링
6. 서비스 Workflow 설계 \& LangGraph 구현 가이드
워크플로우 설계 원칙​
비즈니스 시나리오별 워크플로우
2.1 온보딩 플로우
2.2 캠페인/자동화 플로우
2.3 리포트 생성 플로우
워크플로우 → 그래프 변환
3.1 노드 정의(트리거, 액션, 코어)
3.2 데이터·자격 증명·에러 처리 설계​
LangGraph 구현
4.1 StateGraph 정의
4.2 노드 구현 패턴(도구 호출, 에이전트 호출)​
테스트 \& 디버깅
5.1 단위 테스트, 시나리오 테스트
5.2 실행 로그·시각화·재실행 전략
7. 백엔드(FastAPI) API \& 통합 가이드
전체 백엔드 아키텍처​
FastAPI 프로젝트 구조
2.1 모듈·레이어링(라우터, 서비스, 리포지토리, 스키마)
도메인 API 설계
3.1 인증·권한(Workspace, Role-based)
3.2 워크플로우/노드/실행/로그 API
LangGraph 호출 엔드포인트
4.1 Sync/Async 호출 패턴
4.2 백그라운드 작업 처리
외부 서비스 통합
5.1 ESP, Slack, Stripe, CRM 연동
5.2 공통 통합 모듈 설계
테스트 \& Observability
6.1 유닛/통합 테스트 구조
6.2 로깅·메트릭·트레이싱 연동
8. 프론트엔드(Next.js PWA) 설계·구현 가이드
프론트엔드 아키텍처​
Next.js 구조
2.1 app router, layout, route group 설계
2.2 국제화, SEO, PWA 설정
상태·데이터 패턴
3.1 RSC vs Client Components
3.2 TanStack Query 또는 SWR 정책
UI 컴포넌트 시스템
4.1 shadcn/ui 기반 디자인 시스템
4.2 Tailwind 유틸 규칙
4.3 컴포넌트 트리·스토리북 구성
워크플로우 에디터 구현
5.1 노드 그래프 UI, 드래그·줌·선 연결
5.2 속성 패널, 데이터 미리보기, 실행 컨트롤
성능·접근성 최적화
9. ESP(메일 발송 시스템) 연동 \& AB 테스트 가이드
ESP 선택·아키텍처
템플릿·세그먼트 설계
Webhook/Events 처리 워크플로우
A/B 테스트 프레임워크
4.1 실험 설계
4.2 지표·기간·분석
법적·스팸 정책 고려(Opt-in/Opt-out, Footer 등)
10. Observability/로깅/평가/거버넌스 가이드
Observability 개요​
로깅 전략(구조화, PII 분리)
메트릭·알람 설계
3.1 성공률, 지연, 오류 분류, LLM 비용
트레이싱(분산 트레이싱)
AI 품질 평가·피드백 루프
5.1 유저 피드백 수집
5.2 자동·수동 평가
AI 거버넌스
6.1 프롬프트/모델 변경 관리
6.2 사용 정책·리스크 리뷰 프로세스
11. 배포·운영·CI/CD \& 비용 최적화 가이드
배포 전략(환경·리전)​
Monorepo CI/CD 파이프라인
2.1 빌드 캐시, 테스트 단계, 프론트/백 분리 배포
인프라 as Code
비용 모니터링 \& 최적화
4.1 LLM 호출·스토리지·트래픽 비용
4.2 FinOps 대시보드·알람
롤백·릴리즈 전략
12. 운영 Runbook \& 확장(고도화) 시나리오 가이드
Runbook 개요
장애 유형별 대응 플로우
2.1 API 장애, LLM 장애, DB 장애, 외부 통합 장애
인시던트 관리 프로세스
확장 시나리오
4.1 기능 확장 (새 워크플로우/노드)
4.2 성능 확장(멀티리전·샤딩·캐싱)
4.3 조직 확장(엔터프라이즈 플랜, 멀티테넌시)
이 목차 세트를 기반으로 각 .md를 작성하면, “기획 → 도메인 → 에이전트 → 데이터/RAG → LLM/프롬프트 → 워크플로우 → 백/프론트 → ESP → Observability → 배포/운영 → Runbook”까지 전체 라이프사이클을 바이브 코딩 친화적으로 완전히 덮을 수 있습니다.

질문에 추가된 세 가지 축을 반영해서, 기존 설계에 무엇을 어떻게 더해야 완전해지는지만 딱 짚어 정리하겠습니다.[wikidocs+2](https://wikidocs.net/267810)​

1. Relevance Checker 모듈 편입: 어디에 넣을 것인가
관련성 체커(Relevance Checker)는 **RAG + LangGraph 워크플로우의 “검색 결과 검증 루프”**입니다.[wikidocs](https://wikidocs.net/267810)​
편입 위치
디렉터리 3의 **04-data-rag-infra.md**와 **06-service-workflows-and-langgraph.md**에 다음 챕터를 추가합니다.
04-data-rag-infra.md에 추가
“4.x 관련성 체커(Relevance Checker) 모듈”
역할:
question, context를 입력받아 “이 context가 질문에 실제로 관련 있는가?”를 yes/no 또는 score로 평가.[wikidocs](https://wikidocs.net/267810)​
구현 패턴:
LangChain Runnable/Chain으로 question_answer_relevant 정의
프롬프트 예시(groundedness / relevance 체크용 템플릿)
설정 항목:
기준 임계값(threshold), 재검색 회수 제한, 로그/모니터링(얼마나 자주 no가 나오는지).[wikidocs](https://wikidocs.net/267810)​
06-service-workflows-and-langgraph.md에 추가
“3.x Relevance Check 라우팅 패턴”
retrieve → relevance_check → (yes → llm_answer, no → retrieve) 구조를 LangGraph 예제로 포함.[wikidocs](https://wikidocs.net/267810)​
GraphState에 question, context, relevance 필드 정의, is_relevant 라우터 함수와 재귀 한도(recursion_limit) 설정을 예시로 명시.[swarnendu+1](https://www.swarnendu.de/blog/langgraph-best-practices/)​
GraphRecursionError 방지 전략(재시도 횟수, fallback 응답 정책)까지 포함.
2. OpenRouter + LangChain + LangGraph 혼합: 아키텍처·가이드 반영
2-1. OpenRouter 기반 LLM 인프라
다음 문서에 OpenRouter 전용 챕터를 추가합니다.
05-llm-and-prompt-engineering.md
“2.x LLM Provider 전략 – OpenRouter 중심”
OpenRouter를 기본 LLM 게이트웨이로 두고, 모델 선택을 config 기반으로 하는 구조.[peliqan](https://peliqan.io/blog/langchain-vs-langgraph/)​
장점: 다수 모델 / 비용 최적화 / 지역 제약 우회.
구현 가이드:
LangChain에서 OpenRouter Chat 모델 래퍼 사용
모델 이름·max_tokens·temperature를 환경변수로 주입.
monorepo-structure-and-env.md
OpenRouter 관련 환경변수: OPENROUTER_API_KEY, OPENROUTER_BASE_URL, 모델 기본값.
환경별(Dev/Stage/Prod) 다른 모델/가격대 구성.
2-2. LangChain + LangGraph 혼합 패턴
아키텍처 상에서 제1원칙은 **“LangChain은 빌딩블록, LangGraph는 오케스트레이션 런타임”**입니다.[freecodecamp+1](https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/)​
03-multi-agent-architecture.md
“3.x LangChain 컴포넌트 재사용 전략”
Retriever, PromptTemplate, Tool, Chains는 LangChain으로 정의.
이들을 LangGraph의 Node 함수 안에서 호출하는 패턴 정리.[peliqan+1](https://peliqan.io/blog/langchain-vs-langgraph/)​
예:
pdf_retriever = … (LangChain)
def retrieve(state: GraphState): retriever.invoke(state["question"]) (LangGraph node).[freecodecamp+1](https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/)​
06-service-workflows-and-langgraph.md
“4.x LangChain → LangGraph 마이그레이션 체크리스트”[peliqan](https://peliqan.io/blog/langchain-vs-langgraph/)​
1단계: LangChain으로 체인/RAG/프롬프트 검증
2단계: 검증된 컴포넌트를 LangGraph 노드로 감싸 그래프로 조립
3단계: 상태/체크포인트/에러 핸들링 추가.
3. 5가지 role(system / user / assistant / developer / tool) 프롬프트 가이드 추가
바이브 코딩을 안정적으로 쓰려면, 메시지 role별 책임을 정교하게 분리해야 합니다.youtube​[reddit+1](https://www.reddit.com/r/OpenAIDev/comments/1kotbif/in_the_chat_completions_api_when_should_you_use/)​
3-1. 전용 가이드북 챕터
05-llm-and-prompt-engineering.md에 아래 챕터 추가:
“3. 메시지 역할(role)별 프롬프트 설계”
(1) developer (구 system) 역할
목적: 모델의 장기적 행동 규칙, 스타일, 금칙사항, 도메인 정책 정의.[reddit+2](https://www.reddit.com/r/OpenAIDev/comments/1kotbif/in_the_chat_completions_api_when_should_you_use/)​
특징:
가장 높은 우선순위, 잘 변하지 않는 “헌법/규칙서”에 가까운 내용.
예:
“너는 글로벌 워크플로우 빌더 SaaS의 아키텍트 어시스턴트이다. 항상 보안·비용·거버넌스를 고려해 답한다.”
“프롬프트 예시는 JSON 코드블록으로만 답하고, 한국어 설명을 함께 제공한다.”
(2) system 역할
목적: 런타임 컨텍스트·툴 응답·상태 요약 제공.[reddit](https://www.reddit.com/r/OpenAIDev/comments/1kotbif/in_the_chat_completions_api_when_should_you_use/)​
예:
이전 대화 요약, 현재 워크플로우 상태, 관련성 체크 결과(예: “현재 검색 결과는 질문과의 관련성이 낮음”)를 system 메시지로 공급.
Tool 호출 결과를 system으로 제공해 모델이 “이건 도구가 준 정보”임을 알게 하는 패턴.[reddit](https://www.reddit.com/r/OpenAIDev/comments/1kotbif/in_the_chat_completions_api_when_should_you_use/)​
(3) user 역할
목적: 인간 사용자의 의도·요구사항·질문·명령 전달.[openai](https://community.openai.com/t/prompts-for-system-assistant-roles/85605)​youtube​
바이브 코딩용 user 패턴:
“이런 기능을 가진 글로벌 서비스 화면을 설계해줘”,
“아래 요구사항을 만족하는 LangGraph 그래프 정의 코드를 생성해줘” 등.
(4) assistant 역할
목적: LLM 응답을 표현하는 채널; 모델이 만든 코드·설계·설명을 여기에 기록.youtube​[openai](https://community.openai.com/t/prompts-for-system-assistant-roles/85605)​
전략:
assistant 응답 중 일부를 다시 system 또는 developer로 승격시켜 “새로운 규칙/패턴”으로 재사용하는 메커니즘도 포함(예: 프롬프트 라이브러리 업데이트).[swarnendu](https://www.swarnendu.de/blog/langgraph-best-practices/)​
(5) tool 역할
목적: 외부 도구 호출·결과를 표현하는 전용 역할.youtube​
예:
LangChain의 Tools, LangGraph ToolNode, n8n HTTP Request 결과 등을 tool 메시지로 싱크.
모델이 “지금은 내 추론이 아니라 도구 결과를 읽는 단계”임을 명확히 알도록 설계.
3-2. 역할별 템플릿·모듈화
동일 문서에 다음 섹션을 추가:
“3.x 역할별 프롬프트 템플릿 모듈”
/prompts/developer/*.md: 제품 전역 규칙, 보안/거버넌스, 톤/스타일.
/prompts/system/*.md: 각 워크플로우/에이전트별 상태·컨텍스트 요약 템플릿.
/prompts/user/*.md: 기획/설계/코드 생성/리팩토링/테스트용 바이브 코딩 유저 프롬프트 템플릿.
/prompts/tool/*.md: 도구 응답 포맷, LLM이 해석하기 쉬운 JSON 스키마.[danbibibi.tistory+1](https://danbibibi.tistory.com/321)​
4. 전체 설계에 대한 “누락 여부” 점검 요약
질문에서 추가하신 요구까지 반영하면, 다음이 모두 커버됩니다.
Relevance Checker 모듈: RAG/워크플로우/에이전트 레벨에서의 관련성·Groundedness 검증 + 재검색 루프.[wikidocs](https://wikidocs.net/267810)​
OpenRouter 기반 LLM 인프라: 비용·모델 선택 전략, LangChain 래퍼, 환경변수 설계.[peliqan](https://peliqan.io/blog/langchain-vs-langgraph/)​
LangChain + LangGraph 혼합 구조: LangChain=컴포넌트, LangGraph=그래프 및 상태·에러 런타임.[freecodecamp+1](https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/)​
5 role 프롬프트 체계: developer/system/user/assistant/tool 각각의 책임·예시·템플릿 구조.[danbibibi.tistory+1](https://danbibibi.tistory.com/321)​
이 추가 챕터들을 각 가이드북에 삽입하면, 바이브 코딩으로 글로벌 서비스를 설계·생성·운영하는데 필요한 구조적 요소는 빠진 것이 없다고 봐도 될 수준까지 올라갑니다.
[https://wikidocs.net/267810](https://wikidocs.net/267810)
[https://peliqan.io/blog/langchain-vs-langgraph/](https://peliqan.io/blog/langchain-vs-langgraph/)
[https://danbibibi.tistory.com/321](https://danbibibi.tistory.com/321)
[https://www.swarnendu.de/blog/langgraph-best-practices/](https://www.swarnendu.de/blog/langgraph-best-practices/)
[https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/](https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/)
[https://www.youtube.com/watch?v=xbpdMkTz8L4](https://www.youtube.com/watch?v=xbpdMkTz8L4)
[https://www.reddit.com/r/OpenAIDev/comments/1kotbif/in_the_chat_completions_api_when_should_you_use/](https://www.reddit.com/r/OpenAIDev/comments/1kotbif/in_the_chat_completions_api_when_should_you_use/)
[https://glasslego.tistory.com/52](https://glasslego.tistory.com/52)
[https://community.openai.com/t/prompts-for-system-assistant-roles/85605](https://community.openai.com/t/prompts-for-system-assistant-roles/85605)
[https://github.com/cpjet64/vibecoding/blob/main/prompt-engineering-guide.md](https://github.com/cpjet64/vibecoding/blob/main/prompt-engineering-guide.md)
[https://wikidocs.net/186245](https://wikidocs.net/186245)
[https://wikidocs.net](https://wikidocs.net/)
[https://www.egovframe.go.kr/wiki/doku.php?id=egovframework%3Acompa](https://www.egovframe.go.kr/wiki/doku.php?id=egovframework%3Acompa)
[https://www.kieuns.com/doku.php?id=wiki%3Aplugin-syntax](https://www.kieuns.com/doku.php?id=wiki%3Aplugin-syntax)
[https://github.com/ychoi-kr/wikidocs-chobo-python/actions](https://github.com/ychoi-kr/wikidocs-chobo-python/actions)
[https://www.kieuns.com/wiki:plugin-syntax](https://www.kieuns.com/wiki:plugin-syntax)
[https://blog.langchain.com/building-langgraph/](https://blog.langchain.com/building-langgraph/)
[https://wikidocs.com](https://wikidocs.com/)
[https://atomic.snu.ac.kr/api.php?action=help\&recursivesubmodules=1](https://atomic.snu.ac.kr/api.php?action=help&recursivesubmodules=1)
[https://www.langchain.com/langgraph](https://www.langchain.com/langgraph)
[http://wiki1.kr/api.php?action=help\&recursivesubmodules=1](http://wiki1.kr/api.php?action=help&recursivesubmodules=1)

요청하신 수준으로 “모든 내용을 실제 가이드북 전체”로 쓰면, 단일 답변에서 수용 가능한 분량을 훨씬 초과합니다. 그래서 여기서는 **제1원칙 구조를 그대로 유지하면서도, 바로 .md로 복사해 확장 가능한 “완전한 뼈대 + 핵심 문장/예시가 포함된 초안”**까지 제공합니다. 이 틀 위에 챕터별로 세부 내용을 추가하면, 전체 백서 세트를 완성할 수 있습니다.
아래는 1번 가이드부터 12번 가이드까지를 순서대로, 각 문서를 그대로 *.md 파일로 저장해 사용할 수 있는 형태로 정리한 것입니다.

01_vision-requirements.md
비전·요구사항 정의 가이드

1. 서론
목적: 이 문서는 “무엇을 만들 것인가?”를 제1원칙 수준까지 분해해, 모든 설계·구현·바이브 코딩 프롬프트의 기준점을 제공한다.
대상: 경영진, PM, 아키텍트, 리드 엔지니어, UX 리드.
2. 서비스 비전과 성공 지표
2.1 비전·미션
비전: “비개발자도 글로벌 수준의 AI 워크플로우 서비스를 설계·실행할 수 있는 노코드 바이브 코딩 플랫폼을 제공한다.”
미션: “자연어(의도) → 노드 그래프(워크플로우) → 실행 가능한 글로벌 서비스”까지의 거리를 최소화한다.
2.2 North Star Metric
NSM 예: “월간 활성 워크플로우 실행 수(Monthly Active Executions)” 또는 “활성 워크스페이스 당 월간 자동화 작업 수”.
2.3 핵심 KPI
유입: 신규 워크스페이스 생성 수.
활성: 첫 워크플로우를 만들고 실행한 사용자 비율.
유지: 4주 후 재실행 비율.
수익: 유료 플랜 전환률, 워크스페이스 당 ARPA.
3. 시장·경쟁·포지셔닝
3.1 시장
노코드/로우코드 + AI 오케스트레이션 + 멀티에이전트 워크플로우 시장 개요.
글로벌/로컬 경쟁자 맵(Opal, Zapier/Make/n8n, Power Platform, Bubble 등) 요약.
3.2 포지셔닝
“Prompt-to-Workflow + 멀티에이전트 + RAG + 글로벌 UX”가 결합된 플랫폼.
차별점:
바이브 코딩 최적화(프롬프트 템플릿과 아키텍처 가이드 내장).
엔터프라이즈 급 거버넌스·관찰성·FinOps 프레임 포함.
4. 사용자·이해관계자 분석
4.1 페르소나(예)
Growth 마케터, CS 리더, PM, 솔루션 컨설턴트, 엔터프라이즈 IT 관리자.
4.2 내부 이해관계자
운영/지원팀: 알림·로그·권한·리포팅 요구.
영업팀: 데모/PoC를 빠르게 구성하는 템플릿 필요.
5. 기능 요구사항 정의 (What)
5.1 유저스토리
“나는 마케터로서, 신규 리드를 자동 분류·스코어링·후속 이메일 발송 워크플로우를 코드 없이 만들고 싶다.”
“나는 CS 리더로서, 티켓 요약·분류·답장 초안을 자동화하고 싶다.”
5.2 기능 요구사항
워크플로우 에디터(노드·연결·데이터 미리보기).
실행 로그·디버깅·재실행.
멀티에이전트/LLM·RAG 통합.
통합(ESP, Slack, Stripe, CRM 등) 관리.
5.3 워크플로우 관점 요구사항
모든 주요 기능은 “트리거 → 노드 체인 → 결과/알림” 구조로 표현 가능해야 한다.
각 기능은 LangGraph 그래프로도 표현 가능해야 한다.
6. 비기능 요구사항 정의 (How well)
성능: P95 API 응답 ≤ Xms, 워크플로우 실행 지연 ≤ Y초.
가용성: 월 가용성 99.9% 이상(핵심 API 기준).
보안·규제: RBAC, 감사 로그, PII 처리, 데이터 레지던시 고려.
글로벌: 다국어 UI, 타임존 안전성, 통화/날짜 표현.
7. 성공 기준 및 실험 가설
“파일럿 8주 내에, 기존 수동 작업 대비 평균 30% 이상의 시간 절감” 등.
기능별 실험 가설: 예) 관련성 체커 도입 → RAG 응답의 사용자 만족도 +20%.
8. 바이브 코딩 요구사항 표현 템플릿
“다음 요구사항을 만족하는 백엔드/프론트/에이전트/워크플로우 코드를 생성해줘” 템플릿.
프롬프트 구조:
Context(비전, 목표)
Constraints(성능, 보안, 비용, 스택)
Deliverables(파일 구조, 코드 스타일, 테스트 요건)

02_domain-personas-segmentation.md
도메인 모델링 \& 페르소나·세그먼트 설계 가이드

1. 도메인 모델링 원칙
“엔티티·관계·이벤트 수준에서 먼저 정의 → 그 다음 LLM/에이전트/워크플로우에 맵핑.”
RAG·관찰성·과금·권한을 모두 고려.
2. 핵심 엔티티
User, Organization, Workspace, Project
Workflow, Node, Connection, Execution, Log
Template, Integration, Credential, Agent, Dataset, VectorIndex.
각 엔티티에 대해: 필수 필드, 식별자, 수명주기, 권한 범위 정의.
3. 관계 및 이벤트
Workspace ↔ User (역할: Owner/Admin/Member)
Workspace ↔ Workflow (1:N)
Workflow ↔ Execution (1:N)
주요 도메인 이벤트: WorkflowCreated, ExecutionFailed, AgentCostExceeded, RelevanceCheckFailed.
4. 페르소나 및 세그먼트
페르소나별 주요 워크플로우·화면·알림 요구를 표로 정리.

03_multi-agent-architecture.md
멀티에이전트 아키텍처 설계 가이드 (LangGraph)

1. 제1원칙: 왜 에이전트인가
단일 LLM 호출로는 복잡한 다단계 업무(검색→계획→실행→검증)를 안정적으로 처리하기 어렵다.
에이전트 = 역할과 책임이 명확한 LLM + 툴/정책 조합.
2. LangGraph 개념
StateGraph: 상태(메모리)를 가진 그래프 런타임.
노드 = 상태를 읽고/쓰고/도구를 호출하는 함수.
엣지 = 상태/조건에 따른 전이.
3. 에이전트 역할 설계
Planner: 전체 플랜·서브태스크 분해.
Retriever: RAG 검색, 관련성 체커와 연계.
ToolExecutor: API/DB/외부 서비스 호출.
Evaluator/Guardrail: 응답 품질·정책 위반 검사.
4. GraphState 설계
필수 키: question, context, plan, result, cost, steps, errors, relevance_score 등.
5. 패턴별 그래프
Supervisor + Worker 패턴.
Router 패턴(입력에 따라 다른 에이전트 경로 선택).
Reflection 패턴(초안 → 평가 → 수정 루프).

04_data-rag-infra.md
데이터 \& RAG(Qdrant + Supabase) 설계 가이드

1. 데이터 계층 구조
OLTP(Supabase) vs Vector(RAG: Qdrant) vs 로그/메트릭(Observability).
2. Supabase 스키마
워크플로우/실행/사용자/통합/결제 테이블 설계.
3. Qdrant 인덱스
컬렉션: docs, templates, faq, execution_summaries.
벡터 필드, 메타데이터 필드(tenant, language, tags).
4. ETL/동기화 워크플로우
n8n/Opal/LangChain 기반 인덱싱 파이프라인.
5. Relevance Checker 모듈
입력: {question, context_chunk}
출력: {is_relevant: bool, score: float, rationale: str}
LangChain Runnable로 구현, LangGraph에서 노드로 사용.
사용 위치: RAG 단계에서 retrieve → relevance_check → (필터/재검색).

05_llm-and-prompt-engineering.md
LLM 레이어 \& 프롬프트 엔지니어링 가이드

1. LLM 레이어 원칙
모델-불가지론: OpenRouter를 통해 다양한 모델을 사용하되, 인터페이스는 통일.
비용·지연·품질의 균형.
2. OpenRouter 전략
기본 모델 세트: 경량(초안/도우미), 고성능(리포트/복잡 추론)
환경별 설정(Dev=저렴한 모델, Prod=안정 모델).
3. 메시지 역할(role)별 프롬프트 설계
3.1 developer (구 system)
전역 규칙·정책·톤·보안·금칙사항 정의.
문서로 관리, 코드/에이전트 생성 시 항상 포함.
3.2 system
런타임 상태·컨텍스트·툴 결과 요약 제공.
LangGraph의 state/툴 호출 결과를 system에 반영.
3.3 user
실제 사용자·기획자의 의도/요구사항/지시.
바이브 코딩 프롬프트 템플릿.
3.4 assistant
모델 응답 채널, 코드·설계·결과 반환.
3.5 tool
외부 툴/노드/에이전트 결과를 구조화된 JSON으로 표현.
4. 프롬프트 패턴
아키텍처 생성, 컴포넌트/화면 생성, 테스트 코드 생성, 리팩토링, 평가용 템플릿.

06_service-workflows-and-langgraph.md
서비스 Workflow 설계 \& LangGraph 구현 가이드

1. 워크플로우 설계 원칙
모든 기능을 “트리거→노드 체인→결과/알림”으로 표현.
각 노드는 입력/출력/에러/비용을 명확히 정의.
2. 대표 워크플로우 정의
온보딩, 리드 자동화, 리포트 생성, 알림/에러 핸들링.
3. Relevance Check 포함 RAG 워크플로우
Trigger → Retrieve → RelevanceCheck → (관련 없음 → 재검색 / 관련 있음 → LLMAnswer)
LangGraph 노드 코드 스케치.
4. LangGraph 구현
GraphState, 노드 함수, 에지 조건, 체크포인트 설정.

07_fastapi-api-integration.md
백엔드(FastAPI) API \& 통합 가이드
FastAPI 프로젝트 구조, 도메인 모듈, 인증/권한, LangGraph 호출 엔드포인트, 통합 모듈(ESP, Slack, Stripe 등), 로그/메트릭/테스트 패턴.

08_nextjs-pwa-frontend.md
프론트엔드(Next.js PWA) 설계·구현 가이드
app router 구조, 다국어, PWA 세팅, shadcn/ui + Tailwind 컴포넌트 시스템, 워크플로우 에디터 UI, 실행 로그 뷰, 상태 관리 전략.

09_esp-and-ab-test.md
ESP 연동 \& A/B 테스트 가이드
ESP 선택 기준, 템플릿/세그먼트 설계, Webhook 연동, 실험 설계·분석 방법.

10_observability-logging-governance.md
Observability/로깅/평가/거버넌스 가이드
구조화 로깅, 메트릭(워크플로우 성공률·지연·비용), 트레이싱, LLM 품질 평가 루프, AI 거버넌스 프로세스.

11_ci-cd-deployment-cost-optimization.md
배포·운영·CI/CD \& 비용 최적화 가이드
Monorepo 구조(apps/, packages/, infra/), CI 파이프라인, 배포 전략, FinOps(모델 호출·스토리지·트래픽 비용 관리).

12_runbook-and-evolution-scenarios.md
운영 Runbook \& 확장(고도화) 시나리오 가이드
장애 유형별 대응 플로우(LLM 장애, RAG 장애, 외부 통합 장애 등), 인시던트 관리, 확장 시나리오(기능·성능·조직 확장).

이 12개 문서는 이미 **모든 축(서비스 기획, 도메인, 에이전트/LangGraph, RAG+Relevance Checker, OpenRouter+프롬프트 롤, 워크플로우/노드 구조, 백/프론트, ESP, Observability, CI/CD, Runbook)**을 포함하도록 설계되어 있습니다.[wikidocs+3](https://wikidocs.net/267810)​
실제 완성본을 만들고 싶다면:
지금 제안한 각 .md 파일에 대해,
“원칙·목적 문단”
“표/리스트로 된 구체 항목”
“바이브 코딩용 샘플 프롬프트·코드 스케치”
를 채워 넣는 식으로, 한 챕터씩 확장해 나가면 됩니다.
[https://wikidocs.net/267810](https://wikidocs.net/267810)
[https://peliqan.io/blog/langchain-vs-langgraph/](https://peliqan.io/blog/langchain-vs-langgraph/)
[https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/](https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/)
[https://danbibibi.tistory.com/321](https://danbibibi.tistory.com/321)

지금까지는 12권 각각의 골격과 핵심 챕터를 제시했습니다. 이어서, 바이브 코딩에 실제로 바로 쓸 수 있는 수준으로 각 가이드북에 공통적으로 들어가야 할 “실행 가능한 내용”을 더 구체화하겠습니다.
아래는 각 문서에 공통으로 추가하면 좋은 3가지 레이어입니다.

A. 각 가이드북에 공통으로 추가할 섹션 1: “체크리스트”
각 문서 마지막에 \#\# 체크리스트를 두고, 제1원칙 기준으로 “이게 채워져야 다음 단계로 넘어갈 수 있다”를 명시합니다.
예시 – 01_vision-requirements.md 끝부분:
비전·미션이 한 문장씩 정의되어 있는가?
NSM, 핵심 KPI가 숫자/단위 기준으로 정의되었는가?
주요 페르소나와 각 페르소나별 대표 워크플로우가 문서화되었는가?
기능 요구사항이 유저스토리 형태로 정리되어 있는가?
비기능 요구사항(성능, 보안, 글로벌)이 표 형태로 정리되어 있는가?
“바이브 코딩 요구사항 프롬프트 템플릿”이 최소 3개 이상 준비되었는가?
이 패턴을 02~12번 문서에 동일하게 맞춰서 두면, 문서가 단순 설명서가 아니라 “게이트” 역할을 합니다.

B. 공통 섹션 2: “바이브 코딩용 샘플 프롬프트”
각 가이드북의 마지막 챕터에 \#\# 바이브 코딩 샘플 프롬프트를 추가합니다.
예시 – 05_llm-and-prompt-engineering.md 일부:
developer role 예시:
“너는 글로벌 AI 워크플로우 플랫폼의 아키텍트 어시스턴트이다. 아래 정책을 항상 따른다:
보안과 비용·거버넌스를 최우선으로 고려한다.
워크플로우는 항상 트리거–노드–실행–로깅–에러 처리 구조로 설계한다.
코드 예시는 FastAPI + LangGraph + OpenRouter 조합을 기본으로 한다.
…”
system role 예시:
“현재 사용자는 [마케터] 페르소나이고, 아래와 같은 워크플로우를 이미 보유하고 있다: …
현재 질문: …
최근 RAG 관련성 체커 결과: is_relevant=false 3회 연속 발생.
이 상황을 고려해 답변을 수정하라.”
user role 예시:
“위 비전·요구사항 정의를 기반으로, 멀티에이전트 아키텍처(LangGraph)를 설계하고, 다음 조건을 만족하는 Python 코드 스캐폴드를 생성해줘: …”
각 문서마다 이 식의 프롬프트를 3~5개 넣어두면, **실질적으로 “문서=프롬프트 라이브러리의 구조화 버전”**이 됩니다.

C. 공통 섹션 3: “아티팩트(산출물) 템플릿”
각 가이드북에 \#\# 산출물 템플릿 섹션을 두고, 이 문서를 읽고 나면 최소한 어떤 파일/표/코드가 나와야 하는지 정의합니다.
예시 – 06_service-workflows-and-langgraph.md:
산출물:
workflows/ 폴더에 비즈니스 워크플로우별 .md (시퀀스 다이어그램 + 설명).
graphs/ 폴더에 LangGraph 그래프 정의 코드(*.py) 및 다이어그램 이미지.
“Relevance Checker 포함 RAG 플로우”의 예제 그래프(StateGraph 정의, 노드/엣지, 테스트 케이스).
마찬가지로:
03번 멀티에이전트 가이드는 agents/ 폴더에 역할별 에이전트 정의 파일(설명 + 코드 스켈레톤).
04번 데이터·RAG 가이드는 schemas/, embeddings/, etl/ 폴더에 SQL DDL, 인덱싱 파이프라인 코드 초안.
07/08번 백/프론트 가이드는 apps/api/, apps/web/ 아래 예제 디렉터리 구조와 최소 엔드포인트/페이지 스켈레톤.

다음 단계 제안
이제 구조와 핵심 내용은 모두 잡힌 상태라서, 다음을 바로 하시면 됩니다:
실제 리포 구조 만들기
/docs/01_planning_design/01_vision-requirements.md
/docs/02_workflow_engine/…
/docs/03_service_guides/01~12.md
/docs/04_ux_ui_wireframes/…
위에 정리한 목차·핵심 문장·체크리스트·샘플 프롬프트·산출물 템플릿을 그대로 복사해 초기 버전 작성.
이후에는 가장 우선순위 높은 2~3권부터 세부 내용을 채우면서, 병행해서 그 내용을 그대로 OpenRouter + LangChain + LangGraph에 먹이는 “메타 프롬프트”를 작성하시면 됩니다.
예: vision-requirements.md를 context로 주고, “여기에 맞는 LangGraph 스캐폴드 생성” 같은 식.
원하시면, 다음 턴에서 특정 가이드북 하나(예: 05 LLM/프롬프트 가이드 또는 06 워크플로우 \& LangGraph 가이드)를 골라 실제 본문까지 꽤 자세하게 써 드릴 수 있습니다.

내용을 단계별로 하나하나 심층분석 합니다. 그리고 제1원칙사고에 기준하여 분류하고 모든 내용이 포함되도록 총 5개의 디렉토리 구조에 세분화하여 목차 세트를 새롭게 정리합니다. 세분화 작업은 목차세트를 정리한 후에 다음턴에서 하겠습니다.

요청 내용을 제1원칙 기준으로 재구성하면, 문서 세트는 **“수명주기 + 추론 스택 + 실행 스택 + 운영 스택 + 인터랙션(UX/프롬프트) 스택”** 5축으로 분리하는 것이 가장 깔끔합니다.[^27_1][^27_2][^27_3][^27_4]

아래는 이를 반영한 **5개 디렉터리 · 통합 목차 세트(상세)**입니다.

***

## 디렉터리 1: Product \& Domain Blueprint (`/01_product_domain`)

> “무엇을, 누구를 위해, 어떤 제약 하에 만드는가”를 정의하는 레이어.[^27_5][^27_1]

### 1-1. 비전·요구사항·가치 제안

- `vision-and-goals.md`
    - 서비스 비전/미션
    - North Star Metric, 핵심 KPI 세트
    - 핵심 가치 제안(USP), 성공 기준(출시/1년 차)
- `requirements-functional-nonfunctional.md`
    - 기능 요구사항: 유저스토리, Use Case, MoSCoW 우선순위
    - 비기능 요구사항: 성능, 확장성, 가용성, 보안/규제, 국제화/접근성
- `stakeholders-and-use-cases.md`
    - 외부 사용자·내부 이해관계자·그림형 Use Case 맵
    - 기능별 책임(RACI) 개요


### 1-2. 도메인 모델 \& 세그먼트

- `personas-and-segments.md`
    - 주요 페르소나(마케터, CS 리더, PM, IT 관리자 등)
    - 세그먼트(규모, 산업, 지역/언어, 플랜 유형)와 목표 워크플로우
- `domain-modeling.md`
    - 핵심 엔티티: User, Org, Workspace, Project, Workflow, Node, Execution, Log, Template, Integration, Credential, Agent, Dataset, VectorIndex 등
    - 관계/제약(ERD 수준), 데이터 라이프사이클 정의
- `domain-events-and-triggers.md`
    - 도메인 이벤트 카탈로그 (NewLeadCreated, CampaignFinished 등)
    - 이벤트 ↔ 워크플로우 트리거 매핑


### 1-3. 정보 구조 \& 화면 수준 구조

- `information-architecture.md`
    - IA: 메뉴, 네비게이션, 정보 계층(Workspace > Project > Workflow > Execution)
    - URL 전략(언어 코드, 리전, 다국어 URL 패턴)
- `screens-and-user-flows.md`
    - 핵심 플로우(온보딩, 대시보드, 워크플로우 편집, 실행 로그, 설정, 결제 등)
    - 각 플로우별 고수준 화면 시퀀스


### 1-4. Product Planning \& Slice 전략

- `development-plan.md`
    - 단계별 마일스톤(PoC → 베타 → GA → 글로벌 롤아웃)
    - Feature slice 전략(세로 슬라이스 기준), 우선순위 맵
- `feature-prd-template.md`
    - 각 기능 단위 PRD 템플릿(목표, 유저스토리, 수용기준, 비기능, 위험요인)[^27_5]
- `product-checklists.md`
    - “새 기능 추가 시 체크리스트”
    - “릴리즈 전 체크리스트”
    - “AI 기능 위험성 평가 체크리스트”

***

## 디렉터리 2: Architecture \& Execution Engine (`/02_arch_execution`)

> “어떤 기술 스택과 아키텍처로, 어떻게 실행·흐름을 제어할 것인가.”[^27_6][^27_7][^27_8]

### 2-1. 전체 아키텍처 \& 스택

- `tech-stack-and-constraints.md`
    - 프론트: Next.js PWA, shadcn/ui, Tailwind 등
    - 백엔드: FastAPI, LangGraph, LangChain, Supabase, Qdrant
    - 인프라: Vercel/Cloud Run/K8s, CDN, ESP, 모니터링 스택
    - 제약(예산/팀 능력/공급자·리전 제약)
- `architecture-overview.md`
    - C4 컨텍스트/컨테이너/컴포넌트 다이어그램
    - 모놀리식 vs 모듈러 모노레포 vs 마이크로서비스 선택 근거


### 2-2. Workflow · 노드 · 데이터 런타임

- `workflow-concepts-and-layers.md`
    - 레이어: Presentation(에디터) / Workflow Runtime / Nodes / Connections / Data / Credentials / Executions / Debugging[^27_9][^27_10]
    - “미니앱 = 그래프(노드/엣지 + 상태)” 개념
- `node-basics.md`
    - 노드 타입: 트리거/액션/코어 로직/서브그래프·에이전트
    - 노드 생명주기(생성→설정→실행→로깅→버전)
- `node-catalog.md`
    - 기능별 노드 카탈로그(유저/워크스페이스, 통합, AI/RAG, 유틸리티)
    - 각 노드의 입력/출력 스키마, 옵션, 실패 시 동작
- `connections-and-flow-control.md`
    - 단일/병렬/브랜치/합류 패턴
    - 순서 결정, 의존성, 멱등성 고려
    - LangGraph StateGraph와의 매핑[^27_7][^27_6]
- `data-model-in-workflows.md`
    - 워크플로우 내 데이터 구조(items[], JSON, 멀티모달)
    - 변환·검증 규칙, 에러 처리, 타입 전략


### 2-3. Credentials \& Secrets · 실행 \& 디버깅

- `credentials-and-secrets.md`
    - API 키/OAuth/서비스 계정 모델, 암호화 저장, 로테이션
    - 워크플로우에서의 스코프·권한 최소화[^27_11][^27_12]
- `executions-and-logging.md`
    - 실행(run) 모델, 상태(대기/성공/실패), 리트라이 정책
    - 실행 로그 구조(노드별 입력/출력/에러/메트릭)
- `debugging-and-data-pinning.md`
    - 데이터 핀닝·모킹 개념과 사용 가이드
    - 에러 패턴(JSON, Expression, 타임아웃 등)별 디버깅 레시피[^27_13][^27_14]


### 2-4. LangChain + LangGraph · Prompt-to-Graph

- `langchain-langgraph-integration.md`
    - 제1원칙: LangChain=컴포넌트(Chain/Tool/Retriever), LangGraph=오케스트레이터[^27_8][^27_15]
    - LangChain 객체를 LangGraph 노드에서 호출하는 패턴
- `prompt-to-graph-strategy.md`
    - 자연어 → 노드 그래프 생성(PTG/Opal/자체 도구) 전략
    - 그래프 품질 체크리스트(루프, 에러 경로, 자격 증명, 비용)[^27_16][^27_17]

***

## 디렉터리 3: LLM · RAG · Agentic Layer (`/03_llm_rag_agents`)

> “LLM·RAG·에이전트가 어떻게 협업하고, 비용·품질을 어떻게 관리하는가.”[^27_15][^27_6][^27_8]

### 3-1. LLM Provider \& OpenRouter 전략

- `llm-provider-strategy-openrouter.md`
    - OpenRouter 중심 모델 전략(저비용/고품질 모델 조합)[^27_8]
    - 환경별 기본 모델·fallback 모델, rate limit·비용 가드
- `llm-layer-architecture.md`
    - LLM 호출 레이어(공통 wrapper, 로깅, 재시도, 백오프)
    - 동기/비동기 호출 패턴, 스트리밍 전략


### 3-2. 프롬프트 아키텍처 \& Role 체계

- `prompt-roles-and-instruction-hierarchy.md`
    - developer/system/user/assistant/tool 역할 정의와 우선순위[^27_18][^27_19][^27_20]
    - 역할별에 어떤 내용이 들어가야/들어가면 안 되는지
- `prompt-templates-and-patterns.md`
    - 아키텍처 생성 / 컴포넌트 생성 / 테스트 생성 / 리팩토링 / 평가 패턴[^27_21][^27_22][^27_23]
    - Role별 메시지 셋 예시(바이브 코딩용 세트)
- `prompt-library-structure.md`
    - `/prompts/developer/`, `/prompts/system/`, `/prompts/user/`, `/prompts/tool/` 디렉터리 설계[^27_24][^27_4]
    - 버전 관리·실험(A/B) 방법


### 3-3. 멀티에이전트 아키텍처 (LangGraph)

- `multi-agent-architecture.md`
    - 에이전트 역할: Planner, Retriever, Coder, Evaluator, Router 등[^27_25][^27_6]
    - GraphState 설계(키, 타입, reducer 패턴)
- `agent-patterns-and-best-practices.md`
    - Supervisor/Worker, Router, Reflection 패턴[^27_26][^27_6]
    - 루프·비용 폭주 방지, 실패·fallback 전략


### 3-4. 데이터 \& RAG · Relevance Checker

- `data-rag-infra.md`
    - Supabase 스키마, Qdrant 컬렉션, 인덱싱 파이프라인[^27_15]
    - ETL(배치/스트리밍), 데이터 등급·보안
- `relevance-checker-module.md`
    - Relevance Checker 역할/입출력/스코어링 구조[^27_27]
    - LangChain Runnable 구현·프롬프트 예시
    - LangGraph 라우팅 패턴 (retrieve → relevance_check → 재검색/생성)[^27_6]
- `rag-agent-integration-patterns.md`
    - Retrieval → Relevance → Planning → Generation
    - 품질 평가 루프(질문-문맥-응답 평가 데이터 저장)

***

## 디렉터리 4: Delivery Stack (Backend · Frontend · DevOps) (`/04_delivery_stack`)

> “API, 프론트, 배포/운영으로 실제 사용자에게 가는 경로.”[^27_28][^27_29][^27_30]

### 4-1. 백엔드(FastAPI) \& 통합

- `fastapi-architecture.md`
    - 모듈/레이어 구조(라우터, 서비스, 리포지토리, 스키마)
    - 도메인별 API 설계(워크플로우/실행/로그/통합 등)
- `langgraph-backend-integration.md`
    - LangGraph 실행을 위한 엔드포인트 패턴(sync/async)[^27_26]
    - 백그라운드 작업/큐 사용 여부, 체크포인트/재실행 설계
- `external-integrations.md`
    - ESP, Slack, Stripe, CRM 연동 패턴
    - 공통 통합 모듈, 에러 핸들링, 재시도·멱등성


### 4-2. 프론트엔드(Next.js PWA)

- `nextjs-architecture.md`
    - app router 구조, layout/route group, 국제화/SEO/PWA[^27_29][^27_31]
- `state-and-data-fetching.md`
    - RSC vs Client Component 전략
    - TanStack Query/SWR 페치 패턴, 캐싱·에러 처리
- `workflow-editor-ui.md`
    - 노드 그래프 UI, 드래그·줌·연결 인터랙션
    - 속성 패널, 실행 로그/상태 표시 UI


### 4-3. DevOps · CI/CD · Monorepo

- `monorepo-structure-and-env.md`
    - `apps/`(web/api/worker), `packages/`(ui/core/llm/rag), `infra/` 구조[^27_30][^27_29]
    - env/secret 관리(.env, Vault, CI secrets), 환경별 설정
- `ci-cd-pipelines.md`
    - 빌드/테스트/배포 파이프라인(프론트·백 분리, 캐시 전략)
    - Dev/Stage/Prod, Canary/Blue-Green, 롤백 정책
- `deployment-and-cost-optimization.md`
    - 인프라 as Code, 리소스 스케일링
    - LLM·스토리지·트래픽 비용 모니터링 및 최적화[^27_32]

***

## 디렉터리 5: UX · Interaction · Ops Runbook (`/05_ux_interaction_ops`)

> “사람과 시스템의 상호작용, 프롬프트 UX, 관찰성, 운영 Runbook.”[^27_2][^27_3][^27_21]

### 5-1. UX 원칙 · 화면 설계

- `ux-principles-and-navigation.md`
    - 글로벌 UX 원칙(일관성/피드백/오류 복구/접근성)
    - 네비게이션 모델(대시보드/에디터/설정/리포트 모드)
- `wireframes-dashboard.md`
    - 로그인 후 대시보드 레이아웃·컴포넌트 트리·상태/이벤트
- `wireframes-workflow-editor.md`
    - 캔버스/노드 목록/속성 패널/실행 로그/버전 히스토리 구역
    - shadcn/ui·Tailwind 매핑, 상태/이벤트 정의
- `wireframes-execution-and-debugging.md`
    - 실행 이력·타임라인·노드별 입출력·재실행 버튼 UI
- `wireframes-settings-and-integrations.md`
    - Workspace/멤버/권한/통합 설정 화면 구조


### 5-2. Prompt UX \& Vibe Coding Playbook

- `vibe-coding-workflow.md`
    - “Describe → Plan → Scaffold → Refine → Test → Document” 루프[^27_3][^27_33][^27_21]
- `prompt-ux-patterns.md`
    - 사용자에게 어떤 정보(맥락·제약·예시)를 요구할지 UX 관점 정의
    - 에러/부정확 답변 시 재프롬프트 UX 패턴
- `prompt-playbooks.md`
    - “아키텍처 리뷰 요청용 프롬프트”
    - “코드 리팩토링 요청용 프롬프트”
    - “버그 재현/추적 프롬프트”[^27_4][^27_24]


### 5-3. Observability · 거버넌스 · Runbook

- `observability-and-logging.md`
    - 구조화 로그, 메트릭(성공률·지연·비용), 분산 트레이싱[^27_2]
- `ai-evaluation-and-feedback-loops.md`
    - 유저 피드백 수집, 자동/수동 평가, 품질 리포트
- `ai-governance-and-risk.md`
    - 프롬프트/모델 변경 관리, 정책·리스크 리뷰 프로세스[^27_19][^27_20]
- `operations-runbook.md`
    - 장애 유형별(LLM, RAG, DB, 외부 통합) 대응 플로우
    - 인시던트 프로세스, 에스컬레이션, 커뮤니케이션 템플릿
- `evolution-scenarios.md`
    - 기능 확장, 성능 확장(멀티리전·캐싱), 조직 확장(멀티테넌시·엔터프라이즈)

***

이 구조는:

- 디렉터리 1: Product/도메인(What, For whom)
- 디렉터리 2: 아키텍처·워크플로우 런타임(How it flows)
- 디렉터리 3: LLM/RAG/에이전트(Thinking layer)
- 디렉터리 4: 백·프론트·DevOps(Delivery layer)
- 디렉터리 5: UX/프롬프트/운영(Interaction \& Operations)

로 분리되어, 바이브 코딩으로 설계→구현→운영→확장을 수행하는 데 필요한 모든 층을 빠짐없이 포함합니다.[^27_1][^27_3][^27_4][^27_6]

다음 턴에서 원하시면, 이 5개 디렉터리 중 하나를 선택해 **각 .md 파일의 세부 섹션/문단 수준까지 더 쪼개는 “세분화 작업”**을 이어가겠습니다.
<span style="display:none">[^27_34][^27_35][^27_36][^27_37]</span>

<div align="center">⁂</div>

[^27_1]: https://dev.to/wasp/a-structured-workflow-for-vibe-coding-full-stack-apps-352l

[^27_2]: https://docs.vibe-coding-framework.com/documentation-standards

[^27_3]: https://cloud.google.com/discover/what-is-vibe-coding

[^27_4]: https://github.com/cpjet64/vibecoding/blob/main/system-architecture-guide.md

[^27_5]: https://www.linkedin.com/pulse/how-create-better-apps-my-7-step-vibe-coding-workflow-szerovay-0aqcf

[^27_6]: https://www.swarnendu.de/blog/langgraph-best-practices/

[^27_7]: https://www.langchain.com/langgraph

[^27_8]: https://peliqan.io/blog/langchain-vs-langgraph/

[^27_9]: https://docs.n8n.io/workflows/

[^27_10]: https://deepwiki.com/n8n-io/n8n-docs/2.1-workflows-and-data-flow

[^27_11]: https://docs.n8n.io/integrations/builtin/credentials/

[^27_12]: https://www.reco.ai/hub/secure-n8n-workflows

[^27_13]: https://docs.n8n.io/data/data-pinning/

[^27_14]: https://docs.n8n.io/data/data-mocking/

[^27_15]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^27_16]: https://github.com/langchain-ai/langgraph/issues/3365

[^27_17]: https://github.com/langchain-ai/langgraph/discussions/3363

[^27_18]: https://learning.sap.com/courses/navigating-large-language-models-fundamentals-and-techniques-for-your-use-case/leveraging-system-user-and-assistant-roles-for-better-prompts

[^27_19]: https://www.clarifai.com/blog/agentic-prompt-engineering

[^27_20]: https://practiqai.com/blog/system-prompts-roles-instruction-hierarchy

[^27_21]: https://vibecoding.app/blog/how-vibe-coding-works

[^27_22]: https://zread.ai/tukuaiai/vibe-coding-cn/2-quick-start

[^27_23]: https://github.com/cpjet64/vibecoding/blob/main/prompt-engineering-guide.md

[^27_24]: https://roboco.io/posts/vibe-coding-manual/

[^27_25]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^27_26]: https://blog.langchain.com/building-langgraph/

[^27_27]: https://wikidocs.net/267810

[^27_28]: https://forum.cursor.com/t/best-practices-for-structuring-a-next-js-fastapi-supabase-project/49706

[^27_29]: https://www.pronextjs.dev/workshops/next-js-react-server-component-rsc-architecture-jbvxk/understanding-the-example-monorepo-structure-4gpny

[^27_30]: https://github.com/belgattitude/nextjs-monorepo-example/blob/main/README.md

[^27_31]: https://elementor.com/blog/what-is-n8n/

[^27_32]: https://buymeacoffee.com/afgarabote/building-modern-full-stack-applications-next-js-fastapi-supabase-vercel

[^27_33]: https://emergent.sh/learn/what-is-vibe-coding

[^27_34]: https://velog.io/@gyu_p/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4-%EC%95%88%ED%95%B4%EB%8F%84-%EC%9E%98-%EB%90%98%EB%8D%98%EB%8D%B0

[^27_35]: https://github.com/langchain-ai/langgraph/discussions/2090

[^27_36]: https://docs.nvidia.com/nim/large-language-models/latest/system-example.html

[^27_37]: https://awslabs.github.io/mcp/vibe_coding


---

# <q>**각 .md 파일의 세부 섹션/문단 수준까지 더 쪼개는 “세분화 작업”**</q> 디렉터리 1: Product \& Domain Blueprint (/01_product_domain)

“무엇을, 누구를 위해, 어떤 제약 하에 만드는가”를 정의하는 레이어.linkedin+1
1-1. 비전·요구사항·가치 제안
vision-and-goals.md
서비스 비전/미션
North Star Metric, 핵심 KPI 세트
핵심 가치 제안(USP), 성공 기준(출시/1년 차)
requirements-functional-nonfunctional.md
기능 요구사항: 유저스토리, Use Case, MoSCoW 우선순위
비기능 요구사항: 성능, 확장성, 가용성, 보안/규제, 국제화/접근성
stakeholders-and-use-cases.md
외부 사용자·내부 이해관계자·그림형 Use Case 맵
기능별 책임(RACI) 개요
1-2. 도메인 모델 \& 세그먼트
personas-and-segments.md
주요 페르소나(마케터, CS 리더, PM, IT 관리자 등)
세그먼트(규모, 산업, 지역/언어, 플랜 유형)와 목표 워크플로우
domain-modeling.md
핵심 엔티티: User, Org, Workspace, Project, Workflow, Node, Execution, Log, Template, Integration, Credential, Agent, Dataset, VectorIndex 등
관계/제약(ERD 수준), 데이터 라이프사이클 정의
domain-events-and-triggers.md
도메인 이벤트 카탈로그 (NewLeadCreated, CampaignFinished 등)
이벤트 ↔ 워크플로우 트리거 매핑
1-3. 정보 구조 \& 화면 수준 구조
information-architecture.md
IA: 메뉴, 네비게이션, 정보 계층(Workspace > Project > Workflow > Execution)
URL 전략(언어 코드, 리전, 다국어 URL 패턴)
screens-and-user-flows.md
핵심 플로우(온보딩, 대시보드, 워크플로우 편집, 실행 로그, 설정, 결제 등)
각 플로우별 고수준 화면 시퀀스
1-4. Product Planning \& Slice 전략
development-plan.md
단계별 마일스톤(PoC → 베타 → GA → 글로벌 롤아웃)
Feature slice 전략(세로 슬라이스 기준), 우선순위 맵
feature-prd-template.md
각 기능 단위 PRD 템플릿(목표, 유저스토리, 수용기준, 비기능, 위험요인)[linkedin](https://www.linkedin.com/pulse/how-create-better-apps-my-7-step-vibe-coding-workflow-szerovay-0aqcf)
product-checklists.md
“새 기능 추가 시 체크리스트”
“릴리즈 전 체크리스트”
“AI 기능 위험성 평가 체크리스트”

디렉터리 1의 각 `.md` 파일을 **실제 작성 단위(섹션/소제목/문단 단위)**로 쪼갠 세부 목차입니다.[^28_1][^28_2]

***

## 1-1. 비전·요구사항·가치 제안

### 1) `vision-and-goals.md`

#### 1. 서론

- 1.1 문서의 목적
- 1.2 대상 독자 및 사용 시나리오


#### 2. 서비스 비전·미션

- 2.1 비전 선언문 (Vision Statement)
- 2.2 미션(Mission) 및 문제 정의
- 2.3 장기적 방향(3년/5년 뷰)


#### 3. 비즈니스 목표 및 성공 기준

- 3.1 비즈니스 목표(수익/시장/제품 목표)
- 3.2 출시 시점 성공 기준(Launch Success Criteria)
- 3.3 1년 차 성공 기준(1st-Year Success Criteria)


#### 4. North Star Metric 및 핵심 KPI

- 4.1 North Star Metric 정의
- 4.2 Acquisition/Activation/Retention/Revenue/Referral KPI
- 4.3 KPI 간 상관관계 맵(간단한 표/다이어그램)


#### 5. 핵심 가치 제안(USP)

- 5.1 타깃 고객 문제 요약
- 5.2 기존 대안 vs 제안 서비스 비교
- 5.3 유니크 포인트(UX, 에이전트, RAG, 비용 등)


#### 6. 제약 조건(Constraints)

- 6.1 비즈니스 제약(예산/기간/인력)
- 6.2 기술 제약(스택 고정, 벤더 제약, 리전)
- 6.3 규제/법적 제약(데이터 위치, 산업 규제 등)


#### 7. 바이브 코딩용 비전·목표 프롬프트

- 7.1 Vision 요약 생성 프롬프트
- 7.2 KPI 설계 검토 프롬프트


#### 8. 체크리스트

- 8.1 비전·미션·NSM·KPI 정의 여부
- 8.2 제약 조건 명시 여부

***

### 2) `requirements-functional-nonfunctional.md`

#### 1. 서론

- 1.1 요구사항 문서의 역할
- 1.2 요구사항 변경·관리 원칙


#### 2. 기능 요구사항 구조

- 2.1 유저스토리 포맷(As a / I want / So that)
- 2.2 Use Case 목록(Actor-Trigger-Flow)
- 2.3 MoSCoW 우선순위 기준 정의


#### 3. 기능 요구사항 상세

- 3.1 코어 기능(워크플로우, 실행, 로그, 템플릿 등)
- 3.2 통합 기능(ESP/Slack/Stripe/CRM 등)
- 3.3 AI 관련 기능(LLM, 에이전트, RAG)


#### 4. 비기능 요구사항 카테고리

- 4.1 성능·확장성 (응답 시간, 동시성, 스케일링)
- 4.2 가용성·복구(RTO/RPO, 장애 시나리오)
- 4.3 보안·프라이버시·규제(인증/인가, PII, 로그)
- 4.4 국제화·로컬라이제이션(i18n/L10n)
- 4.5 접근성·사용성


#### 5. 요구사항 → 워크플로우/그래프 매핑

- 5.1 유저스토리 → 워크플로우 트리거/노드 매핑
- 5.2 비기능 → 설계 제약 조건 목록


#### 6. 바이브 코딩용 요구사항 프롬프트

- 6.1 기능 요구사항 → API/워크플로우 스캐폴드 프롬프트
- 6.2 비기능 요구사항 → 아키텍처 검증 프롬프트


#### 7. 체크리스트

- 7.1 기능·비기능 요구사항 커버리지
- 7.2 우선순위·수용 기준 정의 여부

***

### 3) `stakeholders-and-use-cases.md`

#### 1. 서론

- 1.1 이해관계자 분석의 목적


#### 2. 이해관계자 식별

- 2.1 외부 사용자 그룹(고객 유형별)
- 2.2 내부 팀(운영, CS, 영업, 데이터, 인프라)


#### 3. 이해관계자별 니즈와 기대

- 3.1 각 이해관계자 목표/성공 정의
- 3.2 잠재 갈등·트레이드오프


#### 4. Use Case 맵

- 4.1 상위 Use Case 다이어그램 구조
- 4.2 주요 Use Case 설명(목표, 트리거, 결과)


#### 5. RACI 매트릭스

- 5.1 RACI 역할 정의
- 5.2 기능/결정 항목별 RACI 표


#### 6. 체크리스트

- 6.1 모든 핵심 이해관계자 식별 여부
- 6.2 Use Case와 기능 요구사항 정합성

***

## 1-2. 도메인 모델 \& 세그먼트

### 4) `personas-and-segments.md`

#### 1. 서론

- 1.1 페르소나·세그먼트 정의 목적


#### 2. 페르소나 정의

- 2.1 페르소나 템플릿(역할, 목표, Pain, 기존 툴)
- 2.2 Primary 페르소나(마케터/CS 리더/PM/IT) 상세
- 2.3 Secondary 페르소나(엔지니어/관리자)


#### 3. 세그먼트 정의

- 3.1 회사 규모별 세그먼트
- 3.2 산업별/도메인별 세그먼트
- 3.3 지역/언어/플랜 유형별 세그먼트


#### 4. 페르소나별 목표 워크플로우

- 4.1 대표 워크플로우 예(마케터/CS/PM 별)
- 4.2 각 워크플로우의 기대 효과·KPI


#### 5. 세그먼트별 우선순위

- 5.1 “초기 타깃” 세그먼트 선정 근거
- 5.2 롤아웃 순서(국가/산업/요금제)


#### 6. 체크리스트


***

### 5) `domain-modeling.md`

#### 1. 서론

- 1.1 도메인 모델의 역할


#### 2. 엔티티 식별

- 2.1 핵심 엔티티 목록
- 2.2 각 엔티티의 목적·설명


#### 3. 엔티티 상세 정의

- 3.1 필수 필드(Identifier, 비즈니스 키)
- 3.2 속성 그룹(표시용, 제어용, 감사용)
- 3.3 권한·가시성 범위


#### 4. 관계 및 제약

- 4.1 관계(1:1, 1:N, N:N) 정의
- 4.2 무결성·제약 조건(삭제, 소유권, Cascade 정책)


#### 5. 데이터 라이프사이클

- 5.1 생성/갱신/아카이브/삭제 규칙
- 5.2 Soft delete vs Hard delete, 보존 정책


#### 6. 글로벌 고려사항

- 6.1 다국어 필드 설계
- 6.2 타임존/통화 처리


#### 7. 체크리스트


***

### 6) `domain-events-and-triggers.md`

#### 1. 서론

- 1.1 이벤트 중심 설계의 목적


#### 2. 도메인 이벤트 정의

- 2.1 이벤트 네이밍 규칙
- 2.2 이벤트 페이로드 표준 구조


#### 3. 이벤트 카탈로그

- 3.1 사용자 행동 이벤트
- 3.2 시스템·에이전트 이벤트
- 3.3 외부 통합 이벤트


#### 4. 이벤트 ↔ 워크플로우 트리거 매핑

- 4.1 각 이벤트에 연결된 워크플로우 목록
- 4.2 트리거 조건·필터링 로직


#### 5. 감사·모니터링

- 5.1 이벤트 저장·검색 전략
- 5.2 이벤트 기반 모니터링 포인트


#### 6. 체크리스트


***

## 1-3. 정보 구조 \& 화면 수준 구조

### 7) `information-architecture.md`

#### 1. 서론

- 1.1 IA의 목적


#### 2. 글로벌 정보 구조

- 2.1 상위 레벨 정보 구조(Workspace/Project/Workflow/Execution)
- 2.2 서브도메인·전역 설정 구조


#### 3. 메뉴·네비게이션

- 3.1 메인 네비게이션(탑/사이드)
- 3.2 컨텍스트 네비게이션(편집 모드 등)


#### 4. URL 전략

- 4.1 리소스 기반 URL 패턴
- 4.2 언어/리전/플랜에 따른 URL 전략


#### 5. IA와 권한 모델 연계

#### 6. 체크리스트


***

### 8) `screens-and-user-flows.md`

#### 1. 서론

#### 2. 핵심 플로우 정의

- 2.1 온보딩 플로우
- 2.2 대시보드 플로우
- 2.3 워크플로우 편집 플로우
- 2.4 실행 로그·디버깅 플로우
- 2.5 설정·통합·결제 플로우


#### 3. 플로우별 화면 시퀀스

- 3.1 각 플로우의 Step-by-step 화면 리스트
- 3.2 전환 조건·가드(권한/상태)


#### 4. 플로우 ↔ 워크플로우/그래프 매핑

#### 5. 체크리스트


***

## 1-4. Product Planning \& Slice 전략

### 9) `development-plan.md`

#### 1. 서론

#### 2. 단계별 로드맵

- 2.1 PoC 단계 목표·범위
- 2.2 베타 단계 목표·범위
- 2.3 GA 및 글로벌 롤아웃 단계


#### 3. 도메인별 태스크 맵

- 3.1 에이전트·LLM·프롬프트 관련 태스크
- 3.2 데이터·RAG 관련 태스크
- 3.3 워크플로우 엔진·에디터 태스크
- 3.4 프론트/백/DevOps 태스크


#### 4. 리스크 및 의존성 관리

#### 5. 체크리스트


***

### 10) `feature-prd-template.md`

#### 1. PRD 개요

- 1.1 Template 사용 목적


#### 2. PRD 섹션 템플릿

- 2.1 배경/문제 정의
- 2.2 목표 및 KPI
- 2.3 사용자·페르소나
- 2.4 유저스토리/Use Case
- 2.5 기능 요구사항
- 2.6 비기능 요구사항
- 2.7 UX/화면 스케치 연계 포인트
- 2.8 롤아웃·측정 계획
- 2.9 리스크/오픈 이슈


#### 3. 바이브 코딩용 PRD → 코드/아키텍처 프롬프트 예시


***

### 11) `product-checklists.md`

#### 1. 새 기능 추가 체크리스트

- 요구사항·도메인·보안·LLM/RAG·관찰성 항목


#### 2. 릴리즈 전 체크리스트

- QA, 성능, 롤백 플랜, 모니터링


#### 3. AI 기능 위험성 평가 체크리스트

- 데이터·편향·오용·설명 가능성·감사 가능성

***

이 세분화 구조를 그대로 `.md` 헤더/소제목으로 쓰면, 이후 턴에서 **각 섹션별 내용·표·프롬프트를 채우는 작업**만 진행하면 됩니다.[^28_2][^28_1]

<div align="center">⁂</div>

[^28_1]: https://dev.to/wasp/a-structured-workflow-for-vibe-coding-full-stack-apps-352l

[^28_2]: https://docs.vibe-coding-framework.com/documentation-standards


---

# 디렉터리 2: Architecture \& Execution Engine(/02_arch_execution)

“어떤 기술 스택과 아키텍처로, 어떻게 실행·흐름을 제어할 것인가.”swarnendu+2
2-1. 전체 아키텍처 \& 스택
tech-stack-and-constraints.md
프론트: Next.js PWA, shadcn/ui, Tailwind 등
백엔드: FastAPI, LangGraph, LangChain, Supabase, Qdrant
인프라: Vercel/Cloud Run/K8s, CDN, ESP, 모니터링 스택
제약(예산/팀 능력/공급자·리전 제약)
architecture-overview.md
C4 컨텍스트/컨테이너/컴포넌트 다이어그램
모놀리식 vs 모듈러 모노레포 vs 마이크로서비스 선택 근거
2-2. Workflow · 노드 · 데이터 런타임
workflow-concepts-and-layers.md
레이어: Presentation(에디터) / Workflow Runtime / Nodes / Connections / Data / Credentials / Executions / Debugging[n8n+1](https://docs.n8n.io/workflows/)
“미니앱 = 그래프(노드/엣지 + 상태)” 개념
node-basics.md
노드 타입: 트리거/액션/코어 로직/서브그래프·에이전트
노드 생명주기(생성→설정→실행→로깅→버전)
node-catalog.md
기능별 노드 카탈로그(유저/워크스페이스, 통합, AI/RAG, 유틸리티)
각 노드의 입력/출력 스키마, 옵션, 실패 시 동작
connections-and-flow-control.md
단일/병렬/브랜치/합류 패턴
순서 결정, 의존성, 멱등성 고려
LangGraph StateGraph와의 매핑[langchain+1](https://www.langchain.com/langgraph)
data-model-in-workflows.md
워크플로우 내 데이터 구조(items[], JSON, 멀티모달)
변환·검증 규칙, 에러 처리, 타입 전략
2-3. Credentials \& Secrets · 실행 \& 디버깅
credentials-and-secrets.md
API 키/OAuth/서비스 계정 모델, 암호화 저장, 로테이션
워크플로우에서의 스코프·권한 최소화[n8n+1](https://docs.n8n.io/integrations/builtin/credentials/)
executions-and-logging.md
실행(run) 모델, 상태(대기/성공/실패), 리트라이 정책
실행 로그 구조(노드별 입력/출력/에러/메트릭)
debugging-and-data-pinning.md
데이터 핀닝·모킹 개념과 사용 가이드
에러 패턴(JSON, Expression, 타임아웃 등)별 디버깅 레시피[n8n+1](https://docs.n8n.io/data/data-pinning/)
2-4. LangChain + LangGraph · Prompt-to-Graph
langchain-langgraph-integration.md
제1원칙: LangChain=컴포넌트(Chain/Tool/Retriever), LangGraph=오케스트레이터[peliqan+1](https://peliqan.io/blog/langchain-vs-langgraph/)
LangChain 객체를 LangGraph 노드에서 호출하는 패턴
prompt-to-graph-strategy.md
자연어 → 노드 그래프 생성(PTG/Opal/자체 도구) 전략
그래프 품질 체크리스트(루프, 에러 경로, 자격 증명, 비용)[github+1](https://github.com/langchain-ai/langgraph/issues/3365)

**각 .md 파일의 세부 섹션/문단 수준까지 더 쪼개는 “세분화 작업”**

디렉터리 2의 각 `.md`를 바로 작성 가능하도록 **섹션/소제목 단위까지 세분화**한 구조입니다.[^29_1][^29_2][^29_3][^29_4]

***

## 2-1. 전체 아키텍처 \& 스택

### 1) `tech-stack-and-constraints.md`

#### 1. 서론

- 1.1 문서의 목적
- 1.2 대상 독자(아키텍트, 리드 개발자, DevOps)


#### 2. 프론트엔드 스택

- 2.1 Next.js PWA 선택 이유
- 2.2 shadcn/ui \& Tailwind 설계 원칙
- 2.3 프론트에서 직접 사용하는 LLM/에이전트 호출 정책(가능/지양)


#### 3. 백엔드 스택

- 3.1 FastAPI 선택 이유 및 장단점
- 3.2 LangGraph(LangChain 포함) 역할(에이전트 런타임/워크플로우 엔진)[^29_2][^29_5]
- 3.3 Supabase(Postgres/Auth/Storage) 역할
- 3.4 Qdrant(RAG 벡터 스토어) 역할


#### 4. 인프라 스택

- 4.1 호스팅 전략: Vercel / Cloud Run / K8s 중 선택 기준
- 4.2 CDN·이미지 처리·캐시 계층 개요
- 4.3 ESP(메일), 모니터링/로그/트레이싱 스택 개요


#### 5. 공통 라이브러리·언어·버전 정책

- 5.1 언어·런타임(Node, Python) 버전
- 5.2 공통 유틸 패키지·코딩 규약


#### 6. 제약 조건(Constraints)

- 6.1 예산·비용 제약(LLM/인프라)
- 6.2 팀 역량·학습 곡선 제약
- 6.3 공급자, 리전, 규제 제약


#### 7. 바이브 코딩용 스택 설명 프롬프트

- 7.1 “이 스택 기준으로 아키텍처 제안” 프롬프트 템플릿


#### 8. 체크리스트


***

### 2) `architecture-overview.md`

#### 1. 서론

- 1.1 전체 아키텍처 문서의 역할


#### 2. C4 Level 1: 시스템 컨텍스트

- 2.1 사용자/외부 시스템/플랫폼 간 관계
- 2.2 주요 경계(프론트/백/에이전트/데이터)


#### 3. C4 Level 2: 컨테이너 다이어그램

- 3.1 프론트엔드 앱
- 3.2 API/에이전트 런타임(FastAPI + LangGraph)
- 3.3 데이터베이스/벡터스토어/스토리지
- 3.4 백그라운드 워커/큐(필요 시)


#### 4. C4 Level 3: 핵심 컴포넌트

- 4.1 워크플로우 엔진 컴포넌트
- 4.2 LLM/RAG/에이전트 컴포넌트
- 4.3 통합(ESP/Slack/Stripe 등) 컴포넌트
- 4.4 Observability 컴포넌트


#### 5. 아키텍처 스타일 선택 근거

- 5.1 모놀리식 vs 모듈러 모노레포 vs 마이크로서비스 비교
- 5.2 선택한 구조와 이유(팀 규모·복잡도·속도·비용)


#### 6. 진화/확장 시 고려사항

- 6.1 기능 확장 시 분리 후보
- 6.2 트래픽 증가 시 수평/수직 확장 전략


#### 7. 체크리스트


***

## 2-2. Workflow · 노드 · 데이터 런타임

### 3) `workflow-concepts-and-layers.md`

#### 1. 서론

- 1.1 워크플로우 개념의 중요성[^29_6][^29_1]


#### 2. 워크플로우 기본 개념

- 2.1 워크플로우 정의(Trigger → Nodes → Result)
- 2.2 워크플로우 vs 멀티에이전트 그래프(LangGraph StateGraph)


#### 3. 레이어 모델

- 3.1 Presentation Layer(에디터 UI)
- 3.2 Workflow Runtime Layer(엔진/스케줄러)
- 3.3 Nodes \& Connections Layer
- 3.4 Data Layer(아이템/JSON/상태)
- 3.5 Credentials Layer
- 3.6 Executions \& Debugging Layer[^29_7][^29_1]


#### 4. “미니앱 = 그래프(노드/엣지 + 상태)” 정의

- 4.1 미니앱 개념과 스코프
- 4.2 LangGraph의 상태 기반 그래프와의 대응[^29_2]


#### 5. 워크플로우 라이프사이클

- 5.1 생성·설정·테스트·배포·운영
- 5.2 버전 관리(변경 이력)


#### 6. 체크리스트


***

### 4) `node-basics.md`

#### 1. 서론

#### 2. 노드 타입 정의

- 2.1 트리거 노드(웹훅, 스케줄, 이벤트)[^29_1]
- 2.2 액션 노드(API/DB/이메일/AI 호출)
- 2.3 코어 로직 노드(IF, Switch, Merge, Split, Loop, Wait)[^29_8][^29_9]
- 2.4 서브그래프·에이전트 노드(LangGraph 서브그래프)[^29_2]


#### 3. 노드 인터페이스

- 3.1 입력 구조(입력 포트/스키마)
- 3.2 출력 구조(출력 포트/스키마)
- 3.3 설정 옵션(필수/선택)


#### 4. 노드 생명주기

- 4.1 생성(메타데이터·기본값)
- 4.2 설정(사용자 입력/검증)
- 4.3 실행(입력→처리→출력)
- 4.4 로깅(입출력/에러/메트릭)
- 4.5 버전 관리


#### 5. 노드 설계 원칙

- 5.1 단일 책임 원칙
- 5.2 순수 함수형 노드 vs 부작용 있는 노드 구분


#### 6. 체크리스트


***

### 5) `node-catalog.md`

#### 1. 서론

#### 2. 카탈로그 구조

- 2.1 카테고리(유저/워크스페이스, 통합, AI/RAG, 유틸리티 등)
- 2.2 노드 메타데이터(이름, 설명, 태그)


#### 3. 공통 정의 포맷

- 3.1 입력 스키마(필드, 타입, required)
- 3.2 출력 스키마
- 3.3 옵션(재시도, 타임아웃, 에러 정책)


#### 4. 카테고리별 노드 정의

- 4.1 유저·워크스페이스 관리 노드
- 4.2 통합(ESP/Slack/Stripe/CRM) 노드
- 4.3 AI·RAG 노드(OpenRouter LLM 호출, RAG Retriever, Relevance Checker 등)[^29_5][^29_10]
- 4.4 유틸리티 노드(Set/Transform/Filter/Merge 등)[^29_8]


#### 5. 노드 재사용·버전 전략

#### 6. 체크리스트


***

### 6) `connections-and-flow-control.md`

#### 1. 서론

#### 2. 연결(Connections) 기본 개념

- 2.1 노드 간 연결의 의미(데이터·제어 흐름)
- 2.2 단일/다중 연결, 순서


#### 3. 흐름 제어 패턴

- 3.1 직선형(Sequential)
- 3.2 병렬(Parallel)
- 3.3 브랜치(IF, Switch 기반)
- 3.4 합류(Merge/Join)[^29_1][^29_8]


#### 4. 순서·의존성·멱등성

- 4.1 의존 관계 모델링
- 4.2 멱등성 고려(재실행·재시도 시 문제 방지)


#### 5. LangGraph StateGraph 매핑

- 5.1 노드 함수 ↔ 워크플로우 노드 대응
- 5.2 엣지 조건 ↔ 브랜치/라우팅 로직 대응[^29_3][^29_2]


#### 6. 체크리스트


***

### 7) `data-model-in-workflows.md`

#### 1. 서론

#### 2. 데이터 구조

- 2.1 items[] 배열 기반 구조(n8n 스타일)[^29_7]
- 2.2 JSON 필드 구조, 멀티모달(텍스트+파일) 표현


#### 3. 데이터 변환 규칙

- 3.1 타입 변환(문자열↔숫자↔날짜 등)
- 3.2 구조화/정규화/플래트닝 패턴


#### 4. 데이터 검증·에러 처리

- 4.1 필수 필드·형식 검증
- 4.2 검증 실패 시 처리 정책(드롭/에러/보정)


#### 5. 타입 전략

- 5.1 스키마 정의·버전 관리
- 5.2 LangChain/LangGraph 쪽 타입 구조와의 정렬[^29_11][^29_2]


#### 6. 체크리스트


***

## 2-3. Credentials \& Secrets · 실행 \& 디버깅

### 8) `credentials-and-secrets.md`

#### 1. 서론

#### 2. 자격 증명 모델

- 2.1 API 키, OAuth, 서비스 계정 유형[^29_12]
- 2.2 워크스페이스/조직/사용자 범위 스코프


#### 3. 저장·암호화 전략

- 3.1 저장 위치(DB/전용 비밀 관리)
- 3.2 암호화·키 로테이션 정책[^29_13]


#### 4. 워크플로우에서의 참조 패턴

- 4.1 노드 설정에서의 Credential 참조 방식
- 4.2 최소 권한 원칙, 접근 제어


#### 5. 보안·감사

- 5.1 접근 로그·사용 이력
- 5.2 보안 사고 대응 플랜


#### 6. 체크리스트


***

### 9) `executions-and-logging.md`

#### 1. 서론

#### 2. 실행(run) 모델

- 2.1 실행 단위 정의(Workflow Execution)
- 2.2 상태(대기, 실행 중, 성공, 실패)[^29_1]


#### 3. 리트라이·멱등성

- 3.1 리트라이 정책(횟수, 백오프)
- 3.2 멱등성 키·중복 처리 전략


#### 4. 실행 로그 구조

- 4.1 노드별 입력/출력 저장 방식
- 4.2 에러·스택트레이스·메트릭(시간·비용) 저장


#### 5. 모니터링 뷰

- 5.1 실행 리스트 화면 요구사항
- 5.2 Drill-down(노드·타임라인) 요구사항[^29_1]


#### 6. 체크리스트


***

### 10) `debugging-and-data-pinning.md`

#### 1. 서론

#### 2. 디버깅 워크플로우

- 2.1 실패 실행 재현
- 2.2 부분 실행(특정 노드부터/까지 실행)


#### 3. 데이터 핀닝(Data Pinning)

- 3.1 개념·목적(개발용, 프로덕션 제외)[^29_4]
- 3.2 핀 가능한 데이터/불가(바이너리)
- 3.3 주의사항(실제 환경과 괴리, 과도한 핀)[^29_14]


#### 4. 모킹(Mock) 데이터 전략

- 4.1 외부 API 응답 모킹
- 4.2 RAG/LLM 응답 모킹


#### 5. 에러 패턴별 디버깅 레시피

- 5.1 JSON Parse Error
- 5.2 Expression/타입 오류
- 5.3 외부 API 타임아웃·Rate limit
- 5.4 LangGraph 에러(루프, GraphRecursionError 등)[^29_3]


#### 6. 체크리스트


***

## 2-4. LangChain + LangGraph · Prompt-to-Graph

### 11) `langchain-langgraph-integration.md`

#### 1. 서론

#### 2. 역할 분리 원칙

- 2.1 LangChain=컴포넌트(Chain/Tool/Retriever)[^29_5][^29_11]
- 2.2 LangGraph=오케스트레이션 런타임(StateGraph)[^29_3][^29_2]


#### 3. 통합 패턴

- 3.1 LangChain Retriever/Tool을 LangGraph 노드에서 호출
- 3.2 공통 LLM wrapper 사용(로그, 비용, 메트릭)


#### 4. 코드 구조 가이드

- 4.1 `llm/`, `rag/`, `agents/`, `graphs/` 패키지 구조 예
- 4.2 테스트 전략(체인 수준 vs 그래프 수준)


#### 5. 체크리스트


***

### 12) `prompt-to-graph-strategy.md`

#### 1. 서론

#### 2. Prompt-to-Graph(PTG) 개념

- 2.1 자연어 → 워크플로우 그래프 생성 목적
- 2.2 Opal/자체 PTG/다른 도구와의 비교[^29_15][^29_16]


#### 3. PTG 프로세스

- 3.1 요구사항 요약/정제
- 3.2 후보 노드/연결 계획 생성
- 3.3 그래프 구조 생성·검증
- 3.4 사용자 확인·수정 루프


#### 4. 그래프 품질 체크리스트

- 4.1 루프·종료 조건
- 4.2 에러 경로·fallback
- 4.3 자격 증명 사용·권한·보안
- 4.4 비용/성능 고려[^29_16][^29_17]


#### 5. PTG용 프롬프트 템플릿

- 5.1 “요구사항 → 노드 그래프 제안”
- 5.2 “그래프 리뷰·수정 요청”


#### 6. 체크리스트


***

이 구조를 그대로 `/02_arch_execution` 아래 `.md` 파일 헤더로 쓰면, 다음 단계에서는 각 섹션별로 **설명·표·예시 코드·프롬프트**만 채우면 됩니다.[^29_4][^29_2][^29_3][^29_1]

<div align="center">⁂</div>

[^29_1]: https://docs.n8n.io/workflows/

[^29_2]: https://www.langchain.com/langgraph

[^29_3]: https://www.swarnendu.de/blog/langgraph-best-practices/

[^29_4]: https://docs.n8n.io/data/data-pinning/

[^29_5]: https://peliqan.io/blog/langchain-vs-langgraph/

[^29_6]: https://deepwiki.com/n8n-io/n8n-docs/2.1-workflows-and-data-flow

[^29_7]: https://wikidocs.net/302246

[^29_8]: https://docs.n8n.io/workflows/components/nodes/

[^29_9]: https://wikidocs.net/310103

[^29_10]: https://wikidocs.net/267810

[^29_11]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^29_12]: https://docs.n8n.io/integrations/builtin/credentials/

[^29_13]: https://www.reco.ai/hub/secure-n8n-workflows

[^29_14]: https://docs.n8n.io/data/data-mocking/

[^29_15]: https://vibecoding.app/blog/how-vibe-coding-works

[^29_16]: https://github.com/langchain-ai/langgraph/issues/3365

[^29_17]: https://github.com/langchain-ai/langgraph/discussions/2090


---

# 디렉터리 3: LLM · RAG · Agentic Layer (/03_llm_rag_agents)

“LLM·RAG·에이전트가 어떻게 협업하고, 비용·품질을 어떻게 관리하는가.”freecodecamp+2
3-1. LLM Provider \& OpenRouter 전략
llm-provider-strategy-openrouter.md
OpenRouter 중심 모델 전략(저비용/고품질 모델 조합)[peliqan](https://peliqan.io/blog/langchain-vs-langgraph/)
환경별 기본 모델·fallback 모델, rate limit·비용 가드
llm-layer-architecture.md
LLM 호출 레이어(공통 wrapper, 로깅, 재시도, 백오프)
동기/비동기 호출 패턴, 스트리밍 전략
3-2. 프롬프트 아키텍처 \& Role 체계
prompt-roles-and-instruction-hierarchy.md
developer/system/user/assistant/tool 역할 정의와 우선순위[learning.sap+2](https://learning.sap.com/courses/navigating-large-language-models-fundamentals-and-techniques-for-your-use-case/leveraging-system-user-and-assistant-roles-for-better-prompts)
역할별에 어떤 내용이 들어가야/들어가면 안 되는지
prompt-templates-and-patterns.md
아키텍처 생성 / 컴포넌트 생성 / 테스트 생성 / 리팩토링 / 평가 패턴[vibecoding+2](https://vibecoding.app/blog/how-vibe-coding-works)
Role별 메시지 셋 예시(바이브 코딩용 세트)
prompt-library-structure.md
/prompts/developer/, /prompts/system/, /prompts/user/, /prompts/tool/ 디렉터리 설계[roboco+1](https://roboco.io/posts/vibe-coding-manual/)
버전 관리·실험(A/B) 방법
3-3. 멀티에이전트 아키텍처 (LangGraph)
multi-agent-architecture.md
에이전트 역할: Planner, Retriever, Coder, Evaluator, Router 등[langchain-ai.github+1](https://langchain-ai.github.io/langgraph/concepts/multi_agent/)
GraphState 설계(키, 타입, reducer 패턴)
agent-patterns-and-best-practices.md
Supervisor/Worker, Router, Reflection 패턴[langchain+1](https://blog.langchain.com/building-langgraph/)
루프·비용 폭주 방지, 실패·fallback 전략
3-4. 데이터 \& RAG · Relevance Checker
data-rag-infra.md
Supabase 스키마, Qdrant 컬렉션, 인덱싱 파이프라인[freecodecamp](https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/)
ETL(배치/스트리밍), 데이터 등급·보안
relevance-checker-module.md
Relevance Checker 역할/입출력/스코어링 구조[wikidocs](https://wikidocs.net/267810)
LangChain Runnable 구현·프롬프트 예시
LangGraph 라우팅 패턴 (retrieve → relevance_check → 재검색/생성)[swarnendu](https://www.swarnendu.de/blog/langgraph-best-practices/)
rag-agent-integration-patterns.md
Retrieval → Relevance → Planning → Generation
품질 평가 루프(질문-문맥-응답 평가 데이터 저장)

**각 .md 파일의 세부 섹션/문단 수준까지 더 쪼개는 “세분화 작업”**

디렉터리 3의 각 `.md`를 바로 작성 가능하도록 **섹션/소제목 레벨까지 세분화한 구조**입니다.[^30_1][^30_2][^30_3][^30_4]

***

## 3-1. LLM Provider \& OpenRouter 전략

### 1) `llm-provider-strategy-openrouter.md`

#### 1. 서론

- 1.1 문서의 목적
- 1.2 전제(비용 제약, 다수 모델 활용, 글로벌 서비스 맥락)


#### 2. LLM Provider 선택 원칙

- 2.1 OpenRouter 중심 전략 개요[^30_1]
- 2.2 단일 클라우드 LLM vs OpenRouter(멀티 모델/멀티 벤더)의 비교
- 2.3 규제/데이터 위치 관점 고려사항


#### 3. 모델 포트폴리오 설계

- 3.1 경량 모델(초안/보조/유틸리티용)
- 3.2 고성능 모델(복잡 추론/생산 품질 응답용)
- 3.3 특화 모델(코딩, 비전, 로컬 언어 등)
- 3.4 각 모델별 권장 용도와 호출 가이드


#### 4. 환경별 기본/대체 모델 전략

- 4.1 Dev/Stage/Prod 환경 구분
- 4.2 환경별 기본 모델(default), fallback 모델 정의
- 4.3 모델 비가용 시 fallback 시나리오


#### 5. Rate Limit · 비용 가드

- 5.1 호출 한도·동시성 제한 설계
- 5.2 사용자/워크스페이스별 비용 상한(Soft/Hard limit)
- 5.3 비용 모니터링 메트릭(호출 수, 토큰, 비용 단가)


#### 6. 설정·환경변수 설계

- 6.1 `OPENROUTER_API_KEY`, `OPENROUTER_BASE_URL`, 기본 모델 환경변수
- 6.2 per-feature/per-graph 모델 설정 패턴


#### 7. 체크리스트


***

### 2) `llm-layer-architecture.md`

#### 1. 서론

- 1.1 LLM 레이어를 따로 두는 이유


#### 2. LLM 호출 레이어 구조

- 2.1 공통 Wrapper(로깅/리트라이/타임아웃) 설계[^30_2]
- 2.2 입력/출력 표준화(역할 메시지, 메타데이터 포함)
- 2.3 에러·예외 타입 정의


#### 3. 호출 패턴 (Sync/Async)

- 3.1 사용자 요청 동기 처리 패턴
- 3.2 백그라운드/배치 작업용 비동기 호출 패턴
- 3.3 큐·잡 시스템 연계 여부


#### 4. 스트리밍 전략

- 4.1 프론트로의 토큰 스트리밍 UX 패턴
- 4.2 스트리밍 중단/취소/재시도 처리
- 4.3 로그·감사 데이터와 스트리밍의 관계


#### 5. 관찰성·성능 최적화

- 5.1 LLM 레이어 메트릭(지연, 오류율, 비용)
- 5.2 캐싱 전략(입력/출력 캐시)
- 5.3 동일 요청 중복 방지(Deduplication)


#### 6. 체크리스트


***

## 3-2. 프롬프트 아키텍처 \& Role 체계

### 3) `prompt-roles-and-instruction-hierarchy.md`

#### 1. 서론

- 1.1 Role 기반 프롬프트 구조의 필요성[^30_5][^30_6]
- 1.2 이 문서가 다루는 범위(5 roles)


#### 2. Role 정의와 우선순위

- 2.1 developer(구 system) 역할: 전역 규칙·정책·톤[^30_6]
- 2.2 system 역할: 런타임 컨텍스트·요약·툴 결과[^30_5]
- 2.3 user 역할: 인간 사용자의 의도·요구사항
- 2.4 assistant 역할: 모델 응답 채널
- 2.5 tool 역할: 외부 도구 결과·상태 보고[^30_7]
- 2.6 우선순위 계층(Developer > System > Tool facts > User > Assistant)


#### 3. 역할별 “포함해야 할 내용”과 “금지할 내용”

- 3.1 developer: 정책, 불변 규칙 / 동적 컨텍스트 금지
- 3.2 system: 현재 상태, 문맥 / 장기 규칙 중복 정의 금지
- 3.3 user: 명령·질문·예시 / 내부 구현 세부 규칙 강제 금지
- 3.4 assistant: 결과·설명 / 새 정책 선언 금지(승격 프로세스 없이)
- 3.5 tool: 원시 결과·에러 / 해석·추론 포함 금지[^30_8][^30_5]


#### 4. Instruction Hierarchy 설계

- 4.1 상충 시 우선순위 규칙
- 4.2 정책 업데이트 프로세스(developer 메시지 변경 시 영향도)


#### 5. 예시 메시지 셋

- 5.1 아키텍처 설계 세션 예시(5 roles 풀 세트)
- 5.2 워크플로우 디버깅 세션 예시
- 5.3 UI/컴포넌트 생성 세션 예시


#### 6. 체크리스트


***

### 4) `prompt-templates-and-patterns.md`

#### 1. 서론

#### 2. 아키텍처 생성 프롬프트 패턴

- 2.1 시스템·제약·요구사항 입력 구조
- 2.2 “구조 → 다이어그램 → 근거”를 요구하는 템플릿[^30_9][^30_10]


#### 3. 컴포넌트/화면 생성 프롬프트 패턴

- 3.1 컴포넌트 트리·Props·상태·이벤트까지 요구하는 템플릿
- 3.2 shadcn/Tailwind 매핑을 명시하는 패턴


#### 4. 테스트·리팩토링 프롬프트

- 4.1 단위·통합 테스트 케이스 생성 템플릿
- 4.2 성능/보안/구조 리팩토링 제안 템플릿[^30_11][^30_12]


#### 5. 평가·리뷰 프롬프트

- 5.1 코드 리뷰·아키텍처 리뷰 프롬프트
- 5.2 RAG 응답 품질 평가 프롬프트


#### 6. Role별 메시지 셋 예시

- 6.1 developer + system + user 조합 예시(바이브 코딩 세션)
- 6.2 user/assistant/outil 상호작용 예시


#### 7. 체크리스트


***

### 5) `prompt-library-structure.md`

#### 1. 서론

#### 2. 디렉터리 구조

- 2.1 `/prompts/developer/` : 전역 규칙·도메인 정책[^30_11]
- 2.2 `/prompts/system/` : 워크플로우/에이전트별 컨텍스트 템플릿
- 2.3 `/prompts/user/` : 기능/코드/리뷰용 유저 프롬프트
- 2.4 `/prompts/tool/` : 도구 응답 포맷 정의[^30_10]


#### 3. 파일 네이밍·메타데이터 규칙

- 3.1 이름 규칙(도메인-용도-버전)
- 3.2 메타데이터(작성자, 버전, 목표, 관련 그래프)


#### 4. 버전 관리·릴리즈

- 4.1 프롬프트 변경에 따른 영향도 관리
- 4.2 Git·Changelog·릴리즈 노트 패턴


#### 5. 실험·A/B 테스트

- 5.1 프롬프트 A/B 구조(변경 포인트만 분리)
- 5.2 메트릭(정확도, 사용자 만족도, 비용) 정의[^30_6][^30_8]


#### 6. 체크리스트


***

## 3-3. 멀티에이전트 아키텍처 (LangGraph)

### 6) `multi-agent-architecture.md`

#### 1. 서론

- 1.1 멀티에이전트가 필요한 이유[^30_3][^30_8]


#### 2. 에이전트 역할 정의

- 2.1 Planner/Orchestrator
- 2.2 Researcher/Retriever
- 2.3 Coder/Tool Executor
- 2.4 Evaluator/Guardrail
- 2.5 Router/Dispatcher[^30_3]


#### 3. GraphState 설계

- 3.1 상태 키 목록(question, plan, context, result, cost 등)
- 3.2 타입·초기값·필수/옵션 구분
- 3.3 Reducer 패턴(상태 병합 규칙)[^30_13][^30_3]


#### 4. 노드(StateGraph Node) 설계

- 4.1 함수 시그니처(state 입력/출력)
- 4.2 툴/LLM 호출을 포함하는 노드 vs 단순 로직 노드
- 4.3 부작용·IO를 다루는 규칙


#### 5. 에이전트 경계·책임

- 5.1 각 에이전트가 처리할 것 vs 넘길 것
- 5.2 재사용 가능한 서브그래프 정의


#### 6. 체크리스트


***

### 7) `agent-patterns-and-best-practices.md`

#### 1. 서론

#### 2. Supervisor/Worker 패턴

- 2.1 구조(상위 계획 → 하위 작업 분배)[^30_14][^30_13]
- 2.2 장점·단점·사용 시점
- 2.3 구현 시 고려사항(상태 크기, 비용)


#### 3. Router 패턴

- 3.1 입력에 따라 다른 에이전트로 라우팅
- 3.2 라우팅 기준(질문 타입, 위험도, 비용 예측)


#### 4. Reflection/검증 루프 패턴

- 4.1 초안 생성 → 평가 → 수정 루프 구조
- 4.2 Evaluator 에이전트의 역할 정의[^30_8][^30_13]


#### 5. 루프·비용 폭주 방지

- 5.1 최대 스텝/깊이 제한
- 5.2 GraphRecursionError 대비 전략
- 5.3 비용 상한 초과시 중단·요약·fallback


#### 6. 실패·fallback 전략

- 6.1 도구 오류·LLM 오류 핸들링
- 6.2 대체 경로(보수적 응답, 수동 개입 요청) 설계


#### 7. 체크리스트


***

## 3-4. 데이터 \& RAG · Relevance Checker

### 8) `data-rag-infra.md`

#### 1. 서론

#### 2. 데이터 계층 구조

- 2.1 OLTP(Supabase) vs Vector(Qdrant) vs 로그/메트릭[^30_2]
- 2.2 각 계층의 책임과 경계


#### 3. Supabase 스키마 개요

- 3.1 도메인 테이블(워크플로우/실행/유저 등)
- 3.2 RAG 관련 테이블(문서 메타, 인덱싱 상태)


#### 4. Qdrant 컬렉션 설계

- 4.1 컬렉션별 목적(docs/templates/faq/logs)
- 4.2 벡터·메타데이터 스키마, 샤딩/Replica 전략


#### 5. 인덱싱 파이프라인

- 5.1 문서 수집/전처리/분할/임베딩[^30_2]
- 5.2 업데이트/삭제·역인덱싱 전략


#### 6. ETL/동기화 워크플로우

- 6.1 배치 방식 vs 스트리밍 방식
- 6.2 에러·재시도·관찰성 포인트


#### 7. 데이터 등급·보안

- 7.1 PII/비PII 구분
- 7.2 접근 제어·마스킹·익명화


#### 8. 체크리스트


***

### 9) `relevance-checker-module.md`

#### 1. 서론

- 1.1 왜 관련성(Relevance)을 따로 체크해야 하는가[^30_4]


#### 2. 역할과 책임

- 2.1 RAG 파이프라인에서 Relevance Checker 위치
- 2.2 책임 범위: 문맥이 질문에 충분히 관련 있는지 판정


#### 3. 입출력·스코어링 구조

- 3.1 입력: question, context_chunk, 기타 메타데이터
- 3.2 출력: is_relevant, score, rationale
- 3.3 임계값(threshold), 경계값(회색 영역) 정의[^30_4]


#### 4. LangChain Runnable 구현

- 4.1 프롬프트 템플릿 구조(질문/컨텍스트/지침)[^30_4]
- 4.2 Runnable/Chain 구성, 예제 코드 스케치
- 4.3 테스트 케이스 설계(엣지 케이스 포함)


#### 5. LangGraph 라우팅 패턴

- 5.1 retrieve → relevance_check → (검색 반복/생성) 그래프 구조[^30_13]
- 5.2 GraphState에 relevance 정보를 어떻게 기록할 것인가
- 5.3 루프 제한·timeout·fallback 설계


#### 6. 관찰성·튜닝

- 6.1 Relevance 실패율·재검색 횟수 메트릭
- 6.2 임계값·프롬프트 튜닝 프로세스


#### 7. 체크리스트


***

### 10) `rag-agent-integration-patterns.md`

#### 1. 서론

#### 2. RAG + 에이전트 기본 플로우

- 2.1 Retrieval → Relevance → Planning → Generation[^30_3][^30_2]
- 2.2 각 단계 에이전트/노드의 책임


#### 3. 패턴 1: 단일 쿼리 RAG

- 3.1 간단 Q\&A/FAQ 패턴
- 3.2 품질/비용 트레이드오프


#### 4. 패턴 2: 멀티스텝 리서치

- 4.1 다단계 문서 탐색·요약 패턴
- 4.2 중간 결과 저장·재사용 전략


#### 5. 품질 평가 루프

- 5.1 질문-문맥-응답-평가 데이터를 구조화해 저장
- 5.2 자동 평가(LLM-based grader) + 사용자 피드백 통합[^30_8]


#### 6. 실패·안전 패턴

- 6.1 관련 문맥 부족|충돌 감지 시 보수적 응답
- 6.2 “I don’t know” 및 재질문 전략


#### 7. 체크리스트


***

이 세분화 구조를 그대로 `/03_llm_rag_agents`의 `.md` 헤더로 사용하면, 이후에는 각 섹션마다 **설명·예시·프롬프트·코드 스니펫**만 채워 넣으면 됩니다.[^30_1][^30_2][^30_3][^30_4]

<div align="center">⁂</div>

[^30_1]: https://peliqan.io/blog/langchain-vs-langgraph/

[^30_2]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^30_3]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^30_4]: https://wikidocs.net/267810

[^30_5]: https://learning.sap.com/courses/navigating-large-language-models-fundamentals-and-techniques-for-your-use-case/leveraging-system-user-and-assistant-roles-for-better-prompts

[^30_6]: https://practiqai.com/blog/system-prompts-roles-instruction-hierarchy

[^30_7]: https://docs.nvidia.com/nim/large-language-models/latest/system-example.html

[^30_8]: https://www.clarifai.com/blog/agentic-prompt-engineering

[^30_9]: https://vibecoding.app/blog/how-vibe-coding-works

[^30_10]: https://github.com/cpjet64/vibecoding/blob/main/system-architecture-guide.md

[^30_11]: https://roboco.io/posts/vibe-coding-manual/

[^30_12]: https://zread.ai/tukuaiai/vibe-coding-cn/2-quick-start

[^30_13]: https://www.swarnendu.de/blog/langgraph-best-practices/

[^30_14]: https://blog.langchain.com/building-langgraph/


---

# 디렉터리 4: Delivery Stack (Backend · Frontend · DevOps) (/04_delivery_stack)

“API, 프론트, 배포/운영으로 실제 사용자에게 가는 경로.”
4-1. 백엔드(FastAPI) \& 통합
fastapi-architecture.md
모듈/레이어 구조(라우터, 서비스, 리포지토리, 스키마)
도메인별 API 설계(워크플로우/실행/로그/통합 등)
langgraph-backend-integration.md
LangGraph 실행을 위한 엔드포인트 패턴(sync/async)
백그라운드 작업/큐 사용 여부, 체크포인트/재실행 설계
external-integrations.md
ESP, Slack, Stripe, CRM 연동 패턴
공통 통합 모듈, 에러 핸들링, 재시도·멱등성
4-2. 프론트엔드(Next.js PWA)
nextjs-architecture.md
app router 구조, layout/route group, 국제화/SEO/PWA
state-and-data-fetching.md
RSC vs Client Component 전략
TanStack Query/SWR 페치 패턴, 캐싱·에러 처리
workflow-editor-ui.md
노드 그래프 UI, 드래그·줌·연결 인터랙션
속성 패널, 실행 로그/상태 표시 UI
4-3. DevOps · CI/CD · Monorepo
monorepo-structure-and-env.md
apps/(web/api/worker), packages/(ui/core/llm/rag), infra/ 구조
env/secret 관리(.env, Vault, CI secrets), 환경별 설정
ci-cd-pipelines.md
빌드/테스트/배포 파이프라인(프론트·백 분리, 캐시 전략)
Dev/Stage/Prod, Canary/Blue-Green, 롤백 정책
deployment-and-cost-optimization.md
인프라 as Code, 리소스 스케일링
LLM·스토리지·트래픽 비용 모니터링 및 최적화

**각 .md 파일의 세부 섹션/문단 수준까지 더 쪼개는 “세분화 작업”**

디렉터리 4의 각 `.md`를 바로 작성 가능한 수준으로 **섹션/소제목 단위까지 세분화**한 구조입니다.[^31_1][^31_2][^31_3]

***

## 4-1. 백엔드(FastAPI) \& 통합

### 1) `fastapi-architecture.md`

#### 1. 서론

- 1.1 문서의 목적
- 1.2 범위(도메인 API, 구조, 관례)


#### 2. FastAPI 프로젝트 구조 개요

- 2.1 루트 구조 예시(`app/`, `tests/`, `alembic/` 등)
- 2.2 모듈 네임스페이스 규칙


#### 3. 레이어드 아키텍처

- 3.1 라우터 레이어 (API 엔드포인트)
- 3.2 서비스 레이어 (비즈니스 로직)
- 3.3 리포지토리 레이어 (DB/RAG 접근)
- 3.4 스키마 레이어 (Pydantic 모델)


#### 4. 도메인별 API 설계

- 4.1 Auth/Workspace/User API
- 4.2 Workflow/Node/Execution/Log API
- 4.3 Integration/ESP/Payment API


#### 5. 공통 컴포넌트

- 5.1 에러 핸들러·응답 포맷 규약
- 5.2 의존성 주입(DI) 패턴
- 5.3 미들웨어(로깅·CORS·트레이싱)


#### 6. 보안·권한

- 6.1 인증(JWT/Supabase Auth 등)
- 6.2 워크스페이스/역할 기반 권한


#### 7. 체크리스트


***

### 2) `langgraph-backend-integration.md`

#### 1. 서론

- 1.1 LangGraph를 백엔드에서 어떻게 노출할 것인가


#### 2. LangGraph 실행 모델

- 2.1 그래프 정의 위치·로딩 방식
- 2.2 동기 실행 vs 비동기 실행 개념[^31_4]


#### 3. 엔드포인트 패턴

- 3.1 단일 호출형(graph.run) API 패턴
- 3.2 장기 실행/스트리밍/상태 질의형 API 패턴
- 3.3 요청 스키마(입력 상태)/응답 스키마(최종 상태)


#### 4. 백그라운드 작업·큐 설계

- 4.1 큐/워커 사용 여부(Celery, RQ 등)
- 4.2 대용량/장기 작업 처리 패턴
- 4.3 재시도·지연·우선순위 전략


#### 5. 체크포인트·재실행

- 5.1 LangGraph 체크포인트 스토어 설계[^31_5]
- 5.2 중단/실패 시 재실행 전략
- 5.3 실행 ID·상태 조회 API 설계


#### 6. 관찰성

- 6.1 각 그래프 실행의 로그·메트릭·트레이스를 어떻게 남길 것인가


#### 7. 체크리스트


***

### 3) `external-integrations.md`

#### 1. 서론

- 1.1 통합(ESP/Slack/Stripe/CRM)의 역할과 범위


#### 2. 통합 아키텍처 원칙

- 2.1 공통 통합 모듈 vs 개별 서비스 모듈
- 2.2 API 클라이언트 추상화·인터페이스 설계


#### 3. ESP 통합

- 3.1 메일 발송·템플릿·세그먼트 관리 패턴
- 3.2 Webhook(이벤트) 수신 및 워크플로우 연계


#### 4. Slack/Chat 통합

- 4.1 알림 메세지 구조
- 4.2 Slash command/Interaction 처리 패턴


#### 5. Stripe/결제 통합

- 5.1 결제·구독·플랜 변경 플로우
- 5.2 결제 Webhook과 권한/플랜 동기화


#### 6. CRM/기타 SaaS 통합

- 6.1 공통 인터페이스(Lead, Account, Event 등)
- 6.2 레이트리밋·쿼터 고려


#### 7. 에러 핸들링·재시도·멱등성

- 7.1 외부 API 실패 패턴 및 재시도 설계
- 7.2 멱등성 키·중복 방지 전략


#### 8. 체크리스트


***

## 4-2. 프론트엔드(Next.js PWA)

### 4) `nextjs-architecture.md`

#### 1. 서론

- 1.1 프론트엔드 아키텍처 문서 목표


#### 2. 앱 구조 개요

- 2.1 `app/` 디렉터리 구조 (route group, segment)
- 2.2 레이아웃 구조(root layout, workspace layout 등)


#### 3. 라우팅 전략

- 3.1 공개/인증/관리자 라우트 구분
- 3.2 워크스페이스/프로젝트/워크플로우별 URL 패턴


#### 4. 국제화·SEO·PWA

- 4.1 Next.js i18n 라우팅, 언어 스위치 UX
- 4.2 SEO 전략(메타 태그, OG, sitemap)
- 4.3 PWA 설정(Manifest, Service Worker, 오프라인 정책)


#### 5. 성능·번들링

- 5.1 코드 스플리팅·lazy loading 전략
- 5.2 이미지 최적화·폰트·캐시 정책


#### 6. 체크리스트


***

### 5) `state-and-data-fetching.md`

#### 1. 서론

#### 2. RSC vs Client Component 전략

- 2.1 RSC 사용 대상(데이터 주도 UI)
- 2.2 클라이언트 컴포넌트 사용 대상(인터랙션/상태)[^31_2]


#### 3. 데이터 패칭 계층

- 3.1 서버 데이터 패칭(React Server Components)
- 3.2 클라이언트 데이터 패칭(TanStack Query/SWR)
- 3.3 에러/로딩/빈 상태 처리 패턴


#### 4. 캐싱 전략

- 4.1 정적/동적 캐싱 구분
- 4.2 워크플로우·실행 로그·설정 데이터 캐시 수명


#### 5. 상태 관리

- 5.1 폼/로컬 UI 상태 관리
- 5.2 전역 상태(선택된 워크플로우, 편집 상태 등) 관리 정책


#### 6. 체크리스트


***

### 6) `workflow-editor-ui.md`

#### 1. 서론

- 1.1 워크플로우 에디터의 역할


#### 2. 레이아웃 구조

- 2.1 캔버스 영역
- 2.2 노드 목록/팔레트
- 2.3 속성 패널(노드 설정)
- 2.4 실행 로그/상태 패널
- 2.5 버전/히스토리 패널


#### 3. 그래프 인터랙션 패턴

- 3.1 노드 추가/삭제/이동
- 3.2 드래그·줌·팬
- 3.3 연결 생성/삭제/편집


#### 4. 속성 편집 UX

- 4.1 폼·검증·에러 피드백 패턴
- 4.2 자격 증명 선택/연결 UX


#### 5. 실행 상태 표시 UI

- 5.1 마지막 실행 결과 하이라이트
- 5.2 노드별 실행 상태(성공/실패/스킵) 표시
- 5.3 디버깅·재실행 트리거 버튼


#### 6. 컴포넌트·디자인 시스템 매핑

- 6.1 shadcn/ui 컴포넌트 매핑
- 6.2 Tailwind 유틸리티 규칙


#### 7. 체크리스트


***

## 4-3. DevOps · CI/CD · Monorepo

### 7) `monorepo-structure-and-env.md`

#### 1. 서론

#### 2. Monorepo 구조

- 2.1 `apps/` (web/api/worker 등)
- 2.2 `packages/` (ui/core/llm/rag/workflows)
- 2.3 `infra/` (IaC, 환경 구성)[^31_3][^31_2]


#### 3. 코드 소유권·경계

- 3.1 팀/도메인별 소유권 매핑
- 3.2 변경 영향도 최소화 전략


#### 4. 환경·시크릿 관리

- 4.1 `.env` 정책(로컬 전용, 커밋 금지)
- 4.2 Vault/Secret Manager 사용 전략
- 4.3 환경별(Dev/Stage/Prod) 설정 분리


#### 5. 구성 관리

- 5.1 공통 설정 패키지(config)
- 5.2 Feature flag·실험 플래그 관리


#### 6. 체크리스트


***

### 8) `ci-cd-pipelines.md`

#### 1. 서론

#### 2. 빌드 파이프라인

- 2.1 프론트/백 분리 빌드 전략
- 2.2 캐시 활용(의존성/빌드 캐시)


#### 3. 테스트 파이프라인

- 3.1 단위 테스트/통합 테스트/엔드투엔드 테스트 단계
- 3.2 최소 커버리지 기준


#### 4. 배포 파이프라인

- 4.1 Dev/Stage/Prod 단계 구성
- 4.2 자동/수동 승인 단계
- 4.3 Canary/Blue-Green 배포 정책


#### 5. 롤백 전략

- 5.1 롤백 트리거 조건
- 5.2 롤백 절차·툴


#### 6. 관찰성 연계

- 6.1 배포 이벤트와 모니터링/알람 연동


#### 7. 체크리스트


***

### 9) `deployment-and-cost-optimization.md`

#### 1. 서론

#### 2. 인프라 as Code

- 2.1 IaC 도구 선택(Terraform/Pulumi 등)
- 2.2 환경별 스택 정의 원칙


#### 3. 리소스 스케일링

- 3.1 수평/수직 스케일 기준
- 3.2 워크플로우 실행·LLM 호출량 기반 스케일링


#### 4. 비용 모니터링

- 4.1 LLM 비용(호출 수, 토큰, 모델별 단가)
- 4.2 스토리지·네트워크·컴퓨트 비용


#### 5. 비용 최적화 전략

- 5.1 캐싱·저비용 모델·배치 처리 활용
- 5.2 비활성 리소스 정리·자동 파킹


#### 6. 체크리스트


***

이 구조를 그대로 `/04_delivery_stack` 내 `.md` 파일의 헤더로 쓰면, 이후에는 각 섹션에 **구체 설명·표·코드/설정 예시·프롬프트 예시**를 채워 넣는 작업만 진행하면 됩니다.[^31_1][^31_2][^31_3]

<div align="center">⁂</div>

[^31_1]: https://forum.cursor.com/t/best-practices-for-structuring-a-next-js-fastapi-supabase-project/49706

[^31_2]: https://www.pronextjs.dev/workshops/next-js-react-server-component-rsc-architecture-jbvxk/understanding-the-example-monorepo-structure-4gpny

[^31_3]: https://github.com/belgattitude/nextjs-monorepo-example/blob/main/README.md

[^31_4]: https://www.langchain.com/langgraph

[^31_5]: https://www.swarnendu.de/blog/langgraph-best-practices/


---

# 디렉터리 5: UX · Interaction · Ops Runbook (/05_ux_interaction_ops)

“사람과 시스템의 상호작용, 프롬프트 UX, 관찰성, 운영 Runbook.”
5-1. UX 원칙 · 화면 설계
ux-principles-and-navigation.md
글로벌 UX 원칙(일관성/피드백/오류 복구/접근성)
네비게이션 모델(대시보드/에디터/설정/리포트 모드)
wireframes-dashboard.md
로그인 후 대시보드 레이아웃·컴포넌트 트리·상태/이벤트
wireframes-workflow-editor.md
캔버스/노드 목록/속성 패널/실행 로그/버전 히스토리 구역
shadcn/ui·Tailwind 매핑, 상태/이벤트 정의
wireframes-execution-and-debugging.md
실행 이력·타임라인·노드별 입출력·재실행 버튼 UI
wireframes-settings-and-integrations.md
Workspace/멤버/권한/통합 설정 화면 구조
5-2. Prompt UX \& Vibe Coding Playbook
vibe-coding-workflow.md
“Describe → Plan → Scaffold → Refine → Test → Document” 루프
prompt-ux-patterns.md
사용자에게 어떤 정보(맥락·제약·예시)를 요구할지 UX 관점 정의
에러/부정확 답변 시 재프롬프트 UX 패턴
prompt-playbooks.md
“아키텍처 리뷰 요청용 프롬프트”
“코드 리팩토링 요청용 프롬프트”
“버그 재현/추적 프롬프트”
5-3. Observability · 거버넌스 · Runbook
observability-and-logging.md
구조화 로그, 메트릭(성공률·지연·비용), 분산 트레이싱
ai-evaluation-and-feedback-loops.md
유저 피드백 수집, 자동/수동 평가, 품질 리포트
ai-governance-and-risk.md
프롬프트/모델 변경 관리, 정책·리스크 리뷰 프로세스
operations-runbook.md
장애 유형별(LLM, RAG, DB, 외부 통합) 대응 플로우
인시던트 프로세스, 에스컬레이션, 커뮤니케이션 템플릿
evolution-scenarios.md
기능 확장, 성능 확장(멀티리전·캐싱), 조직 확장(멀티테넌시·엔터프라이즈)

**각 .md 파일의 세부 섹션/문단 수준까지 더 쪼개는 “세분화 작업”**

디렉터리 5의 각 `.md`를 바로 작성 가능한 수준으로 **섹션/소제목 단위까지 세분화**한 구조입니다.[^32_1][^32_2][^32_3]

***

## 5-1. UX 원칙 · 화면 설계

### 1) `ux-principles-and-navigation.md`

#### 1. 서론

- 1.1 문서의 목적
- 1.2 대상 독자(UX 리드, PM, 프론트엔드)


#### 2. UX 디자인 원칙

- 2.1 일관성(패턴, 컴포넌트, 용어)
- 2.2 가시성·피드백(상태, 진행률, 오류 메시지)
- 2.3 오류 예방·복구(Undo, Confirm, Guardrail)
- 2.4 접근성(키보드, 스크린리더, 대비, 언어)


#### 3. 글로벌 UX 고려사항

- 3.1 다국어 텍스트 길이·방향성
- 3.2 시간·날짜·통화 표기
- 3.3 문화·규범 차이에 대한 배려


#### 4. 네비게이션 모델

- 4.1 상위 모드: 대시보드 / 에디터 / 설정 / 리포트
- 4.2 워크스페이스·프로젝트·워크플로우 간 이동 패턴
- 4.3 브레드크럼·탭·서브네비 구성


#### 5. 정보 밀도·레이아웃 가이드

- 5.1 한 화면에 보여줄 정보량 기준
- 5.2 테이블/카드/그래프 사용 기준


#### 6. 체크리스트


***

### 2) `wireframes-dashboard.md`

#### 1. 서론

#### 2. 화면 목적·사용자 시나리오

- 2.1 “로그인 후 10초 안에 현재 상황 파악” 목표
- 2.2 대표 Use Case(최근 실행, 알림, 프로젝트 진척)


#### 3. 레이아웃 구조

- 3.1 전역 레이아웃(헤더/사이드바/콘텐츠 영역)
- 3.2 위젯 영역(워크플로우 카드, 최근 실행, 알림, 추천 템플릿)


#### 4. 컴포넌트 트리

- 4.1 Page → Layout → Sections → Cards/Lists
- 4.2 각 컴포넌트 역할·데이터 소스 정의


#### 5. 상태·이벤트 정의

- 5.1 로딩/빈 상태/에러 상태
- 5.2 사용자 행동(필터, 정렬, 클릭, 생성 버튼 등)


#### 6. shadcn/ui · Tailwind 매핑

- 6.1 카드/리스트/탭/배지/모달 매핑
- 6.2 재사용 가능한 UI 패턴 정의


#### 7. 체크리스트


***

### 3) `wireframes-workflow-editor.md`

#### 1. 서론

#### 2. 화면 목적·사용자 시나리오

- 2.1 “워커플로우 설계/수정/디버깅” 중심 작업
- 2.2 노코드 사용자와 파워유저 동시 지원


#### 3. 레이아웃 영역

- 3.1 캔버스 영역(그래프 뷰)
- 3.2 노드 팔레트/검색 영역
- 3.3 속성 패널(노드/워크플로우 설정)
- 3.4 실행 로그/콘솔 영역
- 3.5 버전/히스토리 영역


#### 4. 컴포넌트 트리

- 4.1 EditorPage → GraphCanvas → Node/Edge
- 4.2 PropertiesPanel → FormSections
- 4.3 ExecutionPanel → Timeline/Details


#### 5. 상호작용 패턴

- 5.1 노드 드래그·추가·삭제
- 5.2 줌·팬·캔버스 이동
- 5.3 연결 생성/삭제·자동 라우팅
- 5.4 실행/중단/단계별 실행 버튼


#### 6. 상태·이벤트 정의

- 6.1 선택된 노드/연결 상태
- 6.2 편집/저장/검증 상태
- 6.3 충돌 감지(동시 편집 고려 시)


#### 7. shadcn/ui · Tailwind 매핑

- 7.1 패널·도킹 레이아웃·드로어 구성
- 7.2 폼, 토글, 코드 에디터, 토스트 등


#### 8. 체크리스트


***

### 4) `wireframes-execution-and-debugging.md`

#### 1. 서론

#### 2. 화면 목적·시나리오

- 2.1 실행 이력 확인·문제 원인 파악
- 2.2 특정 실행 재실행/롤백


#### 3. 실행 이력 리스트

- 3.1 필터(상태, 기간, 워크플로우, 사용자)
- 3.2 컬럼(시간, 상태, 실행 ID, 소요시간, 비용 등)


#### 4. 실행 상세 뷰

- 4.1 타임라인(노드 순서·시간)
- 4.2 노드별 입력/출력/에러 표시
- 4.3 재실행/해당 노드부터 다시 실행 버튼


#### 5. 상태·이벤트

- 5.1 실행 상태 변경(대기/진행/완료/실패)
- 5.2 로그 확장/축소, 검색·필터 이벤트


#### 6. 컴포넌트 트리·UI 매핑

- 6.1 리스트·태그(상태 표시)·버튼
- 6.2 상세 카드/코드뷰/JSON 뷰어 매핑


#### 7. 체크리스트


***

### 5) `wireframes-settings-and-integrations.md`

#### 1. 서론

#### 2. 화면 목적·사용자 시나리오

- 2.1 워크스페이스 설정, 멤버·권한 관리
- 2.2 통합(ESP/Slack/Stripe 등) 연결/해제


#### 3. 레이아웃 구조

- 3.1 설정 카테고리(일반/멤버/보안/통합/결제 등)
- 3.2 좌측 메뉴·우측 내용 영역


#### 4. 컴포넌트 트리

- 4.1 SettingsPage → SidebarNav → ContentPanel
- 4.2 IntegrationList → IntegrationItem(상태, 액션)


#### 5. 상태·이벤트

- 5.1 초대/권한 변경/탈퇴 이벤트
- 5.2 통합 연결/해제/테스트 이벤트
- 5.3 위험 액션(삭제/해지) 확인 UX


#### 6. UI 매핑

- 6.1 Form, Table, Badge, Modal, AlertDialog
- 6.2 Stepper(연동 온보딩 플로우) 등


#### 7. 체크리스트


***

## 5-2. Prompt UX \& Vibe Coding Playbook

### 6) `vibe-coding-workflow.md`

#### 1. 서론

- 1.1 Vibe Coding이란 무엇인지 간단 정의[^32_2][^32_3]
- 1.2 이 문서의 목표(프로세스 표준화)


#### 2. 전체 루프 개요

- 2.1 Describe → Plan → Scaffold → Refine → Test → Document[^32_4][^32_5]
- 2.2 각 단계의 입·출력 정의


#### 3. Describe 단계

- 3.1 사용자로부터 필요한 정보(맥락/목표/제약) 항목
- 3.2 좋은/나쁜 설명 예시


#### 4. Plan 단계

- 4.1 아키텍처/워크플로우/에이전트 플랜 산출물 정의
- 4.2 계획 검토 프롬프트·체크리스트


#### 5. Scaffold 단계

- 5.1 코드/그래프/스키마 스캐폴드 산출물 정의
- 5.2 안전 가이드(바로 배포 금지, 로컬 검증)


#### 6. Refine 단계

- 6.1 피드백·리팩토링 요청 패턴
- 6.2 다단계 개선(성능/구조/보안/UX)


#### 7. Test 단계

- 7.1 테스트 생성·실행·평가 프롬프트
- 7.2 회귀·실패 시 루프 재진입 규칙


#### 8. Document 단계

- 8.1 코드/아키텍처/운영 문서 자동 생성
- 8.2 문서 품질 기준·리뷰 프로세스


#### 9. 체크리스트


***

### 7) `prompt-ux-patterns.md`

#### 1. 서론

#### 2. 입력 UX 설계 – 어떤 정보를 어떻게 받는가

- 2.1 필수 맥락(도메인, 유저, 목표)
- 2.2 제약(성능, 보안, 비용) 명시 UX
- 2.3 예시/포맷 제공(샘플 요청/응답)


#### 3. 응답 UX – 결과를 어떻게 보여주는가

- 3.1 코드/구조/설명 분리 표시
- 3.2 “즉시 사용 가능 vs 검토 필요” 구분


#### 4. 에러·부정확 답변 대응 UX

- 4.1 재프롬프트 패턴(정정/추가 정보 제공 요청)
- 4.2 “오해한 부분” 하이라이트 UX
- 4.3 유저가 직접 피드백 남기기(Rating/Comment)


#### 5. 세션·컨텍스트 관리 패턴

- 5.1 장기 세션과 요약 사용
- 5.2 중요한 결정·설계를 따로 고정하는 UX


#### 6. 체크리스트


***

### 8) `prompt-playbooks.md`

#### 1. 서론

#### 2. 아키텍처 리뷰 프롬프트

- 2.1 입력 구조(현재 설계, 제약, 우려점)
- 2.2 기대 출력(문제 지적, 개선안, 트레이드오프)


#### 3. 코드 리팩토링 프롬프트

- 3.1 성능·가독성·테스트 관점 리팩토링 요청 패턴
- 3.2 안전 장치(동작 동일성 유지 요구)


#### 4. 버그 재현/추적 프롬프트

- 4.1 상황·환경·재현 단계·기대 vs 실제
- 4.2 로그/에러 메시지·추가 관찰 제공 방식


#### 5. 기타 플레이북

- 5.1 UX 카피 작성/리뷰 프롬프트
- 5.2 API 계약 정의·검증 프롬프트


#### 6. 체크리스트


***

## 5-3. Observability · 거버넌스 · Runbook

### 9) `observability-and-logging.md`

#### 1. 서론

#### 2. 로깅 전략

- 2.1 구조화 로그(필드, 레벨, 상관 ID)[^32_1]
- 2.2 PII 분리·마스킹·접근 제어


#### 3. 메트릭 설계

- 3.1 워크플로우 성공률/지연/에러율
- 3.2 LLM 호출 수·토큰·비용
- 3.3 인프라·API 메트릭


#### 4. 분산 트레이싱

- 4.1 Trace/Span 설계(프론트↔백↔에이전트)
- 4.2 오류 분석·성능 병목 파악에 활용


#### 5. 알람·대시보드

- 5.1 알람 임계값·노이즈 제어
- 5.2 역할별 대시보드(운영/경영/제품)


#### 6. 체크리스트


***

### 10) `ai-evaluation-and-feedback-loops.md`

#### 1. 서론

#### 2. 평가 대상 정의

- 2.1 LLM 응답 품질(정확성, 유용성, 안전성)[^32_6]
- 2.2 워크플로우 성능(KPI 향상 기여도)


#### 3. 피드백 수집 채널

- 3.1 사용자 Rating/Comment
- 3.2 내부 QA·라벨링·리뷰 프로세스


#### 4. 자동/수동 평가 루프

- 4.1 LLM 기반 그레이더 활용
- 4.2 휴먼 리뷰·샘플링 전략


#### 5. 리포트·개선 사이클

- 5.1 주기적 품질 리포트
- 5.2 프롬프트/모델/워크플로우 개선 프로세스


#### 6. 체크리스트


***

### 11) `ai-governance-and-risk.md`

#### 1. 서론

#### 2. 거버넌스 원칙

- 2.1 책임·투명성·안전성·규정 준수[^32_7]


#### 3. 프롬프트·모델 변경 관리

- 3.1 변경 요청·검토·승인 흐름
- 3.2 실험/롤백 전략


#### 4. 리스크 식별·평가

- 4.1 데이터·프라이버시·편향·오용 리스크
- 4.2 영향도·난이도 기반 우선순위


#### 5. 정책·규정 문서

- 5.1 내부 사용 정책
- 5.2 고객 고지·약관·프라이버시 정책 연계


#### 6. 체크리스트


***

### 12) `operations-runbook.md`

#### 1. 서론

#### 2. Runbook 기본 구조

- 2.1 “사건 → 탐지 → 진단 → 조치 → 회고” 플로우


#### 3. 장애 유형별 Runbook

- 3.1 LLM 장애(모델 다운/품질 저하)
- 3.2 RAG 장애(인덱스 실패/검색 이상)
- 3.3 DB 장애, 외부 통합 장애
- 3.4 워크플로우 엔진 장애


#### 4. 인시던트 프로세스

- 4.1 Severity 레벨 정의
- 4.2 에스컬레이션 경로·역할
- 4.3 커뮤니케이션 템플릿(내부/외부)


#### 5. 사후 회고·개선

- 5.1 Postmortem 템플릿
- 5.2 재발 방지 액션 관리


#### 6. 체크리스트


***

### 13) `evolution-scenarios.md`

#### 1. 서론

#### 2. 기능 확장 시나리오

- 2.1 새 워크플로우/노드/통합 추가
- 2.2 템플릿·마켓플레이스 확장


#### 3. 성능 확장 시나리오

- 3.1 멀티리전·CDN·캐싱
- 3.2 RAG·LLM·워크플로우 실행 스케일


#### 4. 조직·플랜 확장

- 4.1 멀티테넌시 구조 강화
- 4.2 엔터프라이즈 플랜(SSO, 규제, 전용 인프라)


#### 5. 로드맵·우선순위

- 5.1 중장기 로드맵 후보군
- 5.2 의존성·리스크 기반 우선순위


#### 6. 체크리스트


***

이 구조를 그대로 `/05_ux_interaction_ops` 내 `.md` 헤더로 사용하면, 이후에는 각 섹션에 **설명·다이어그램·컴포넌트 트리·프롬프트·Runbook 절차**를 채워 넣는 작업만 진행하면 됩니다.[^32_3][^32_2][^32_1]

<div align="center">⁂</div>

[^32_1]: https://docs.vibe-coding-framework.com/documentation-standards

[^32_2]: https://cloud.google.com/discover/what-is-vibe-coding

[^32_3]: https://vibecoding.app/blog/how-vibe-coding-works

[^32_4]: https://www.linkedin.com/pulse/how-create-better-apps-my-7-step-vibe-coding-workflow-szerovay-0aqcf

[^32_5]: https://emergent.sh/learn/what-is-vibe-coding

[^32_6]: https://www.clarifai.com/blog/agentic-prompt-engineering

[^32_7]: https://practiqai.com/blog/system-prompts-roles-instruction-hierarchy


---

# **Book-Authoring Agent System (BAAS)**

”한 사람의 전문 작가처럼, 한 권의 책을 기획 → 집필 → 구조 완성 → 챕터 통합 → 에디팅 → 최종 원고 생성”까지 자동화하는 Book-Writing Pipeline 구축

Agentic AI 집필 시스템 기술 스택 및 PRD
① 기술 스택(LLM, LangGraph, RAG, PDF 파이프라인 등) – 완전 설계본

📌 1. LLM 계층 (LLM Layer)
🔥 1-1. 기본 모델 선택 (필수)
GPT-4.1 / GPT-4.1-mini
챕터 생성용(고품질): GPT-4.1
구조 설계/연결/요약용: GPT-4.1-mini
옵션
Anthropic Claude Sonnet 3.5 (장문/비평에 강함)
OpenAI o3-mini (비용 최적화)
🔥 1-2. 역할에 따른 모델 매핑
에이전트 역할추천 모델
Book Supervisor
gpt-4.1-mini
Framework/Outline Designer
gpt-4.1
Research Agent (RAG + synthesis)
gpt-4.1
Case Study Agent
gpt-4.1
Chapter Writer
gpt-4.1 (메인 생산모델)
Structure Consistency Agent
gpt-4.1-mini
Style Localization Agent
gpt-4.1
Auto Critic / AgentEval
gpt-4.1-mini
Marketing/Copy Agent
gpt-4.1

📌 2. 에이전트·흐름 계층 (Orchestration Layer: LangGraph)
2-1. 필수 모듈
LangGraph (메인 오케스트레이터)
LangChain Core (문서 구조화/RAG 지원)
LangSmith(선택) — Observability/Tracing
2-2. 플로우 구조
Book-level Graph: 전체 책 생성
Chapter-level Subgraph: 각 챕터 생성
Eval Subgraph: 점수 평가 · 개선
각 플로우는 다음 공통 규칙 사용:
StateGraph 기반 상태(TypedDict)
노드 간 “deterministic → branching → aggregation” 형태
Observability 이벤트 훅(invoke 전/후 기록)
run_id / node_id 기반 trace ID 자동 생성

📌 3. RAG 계층 (Knowledge Retrieval Layer)
3-1. Vector DB
Pinecone 또는 Qdrant
장기 운영성과 속도 기준
3-2. 임베딩 모델
text-embedding-3-large (OpenAI)
긴 chunk / 다국어 지원
3-3. Chunking 전략
PDF 페이지 → 문단 기반 → 토큰 기반 슬라이싱 (400~800 토큰)
chunk metadata:
{
"source": "filename.pdf",
"page": 11,
"section": "1.2 AI Trend",
"topics": ["AI", "Agentic AI", "Strategy"],
"level": "concept/framework/case/data",
"part_candidates": [1, 2]
}

3-4. RAGStore 인터페이스
search(query: str, filters: dict, k: int) -> List[Chunk]
add_documents(docs: List[Chunk]) -> None
reindex(new_docs) -> None

3-5. Retrieval 전략
“Part/Chapter 맞춤 필터링”
Part 1: 트렌드/패러다임
Part 2: 기술 구조
Part 3: 마케팅/비즈니스
Part 4: 도입 로드맵
Part 5: Observability
Part 6: 리더십/조직
Hybrid Retrieval (semantic + keyword)

📌 4. PDF / 문서 파이프라인 (Document Pipeline)
4-1. 라이브러리
pdfplumber (텍스트 추출)
PyMuPDF (이미지/도표 OCR 가능)
Custom chunk cleaner (라벨/머리글 제거)
4-2. 파이프라인 단계
파일 스캔
텍스트 추출
정제(cleaning)
Chunking
임베딩 생성
Vector DB 업로드
Index validation sample run

📌 5. Observability (모니터링/성능 가시화)
필수 구성
Event Logger (JSONL)
Trace Manager (run_id, node_id 기반)
Metrics Collector
Eval Recorder (LLM 평가결과 저장)
저장 필드 예:
{
"run_id": "book_20250101",
"node_id": "chapter_writer",
"timestamp_start": "...",
"timestamp_end": "...",
"latency_ms": 23890,
"input_tokens": 4250,
"output_tokens": 9800,
"rag_docs_used": ["DOC_2024_AI_01_p12_c03"],
"status": "success"
}

📌 6. Application Layer
Python 3.10+
CLI 또는 Streamlit/Next.js 기반 웹 UI
Export options:
Markdown
Word (.docx)
PDF
JSON (구조화된 책 데이터)

② Product Requirements Document (PRD) – 완성판

📘 Product Requirements Document (PRD)
Agentic AI 집필 시스템 – PRD v1.0

1. Product Overview
📝 1.1 제품명
Codename: AuthorX Agentic System
🧭 1.2 한 줄 요약
“해님의 전략 지식·노트·리포트를 RAG로 통합하여
책 한 권을 자동으로 기획·리서치·집필·편집하는 Agentic AI 집필 시스템”
🎯 1.3 제품 목적
저자(해님)가 보유한 지식과 스타일을 AI가 그대로 학습하여 반자동/자동 집필
전체 집필 과정(기획–구조–연구–사례–집필–편집–평가)을 자동화된 파이프라인으로 구축
인간의 개입(HITL)을 최소화하면서도 고품질 산출물 달성
2. Target Users \& Personas
2.1 1차 사용자
해님(저자/컨설턴트/전략가)
2.2 2차 사용자(확장)
다른 저자/강사/전략가
기업 내부 컨설턴트
콘텐츠 제작 조직
2.3 사용자 문제
책 한 권을 쓰기 위해 기획/연구/구성/집필/편집/평가에 엄청난 시간이 든다
기존 LLM은 “일회성 아웃풋”만 제공 → 일관성 없는 결과물이 나옴
사용자 고유의 관점/스타일을 LLM이 유지하기 어려움
3. Use Cases
“새 책 기획”
“책의 Part/Chapter 구조 자동 설계”
“각 챕터의 리서치·사례 자동 생성”
“1회 클릭으로 챕터 초안 자동 작성”
“전체 원고 통합 + 스타일 통일”
“자동 품질 평가(AgentEval) + 수정 제안”
“출판 가능한 포맷으로 Export”
4. Core Features
기능 카테고리상세 기능
기획
주제/독자 기반 책 전체 구조 자동 생성
연구(RAG)
PDF/노트 기반 맞춤 리서치 자동 반환
집필
Agentic Writer가 챕터 단위로 본문 생성
사례 생성
RAG 기반 가상의 사례 자동 생성
통합/편집
책 전체 원고 통합/정리
스타일
해님 스타일 반영한 문체/톤 통일
평가
Auto Critic + Human 리뷰
Observability
로그/트레이스/메트릭/비용 모니터링
Export
MD, DOCX, PDF 자동 변환
5. Non-Functional Requirements
항목요구사항
성능
챕터 1개 생성 ≤ 40초 ~ 2분
비용
GPT-4.1 기준 챕터당 200~500원 예상
안정성
노드 재시도 정책 포함
품질
AgentEval 점수 0.75 이상 유지
확장성
새로운 도메인을 추가해도 구조 유지 가능
재현성
동일 입력 → 유사 출력 (랜덤성 최소화 옵션)
6. System Architecture Overview
6.1 계층 구조
UI Layer (CLI / Notebook / Web)
Orchestration Layer (LangGraph)
Agent Layer (Planner/Research/Writer/etc.)
RAG Layer (Vector DB + Retrieval)
Data Pipeline Layer (PDF/노트 processing)
Observability Layer (Logs/Events/Metrics)
Storage Layer (Book JSON/Exports)
6.2 데이터 흐름
사용자 입력 → Book Supervisor → Outline Designer → Chapter Subgraph →
RAG → Research → Case Study → Writer → Eval → Editor → Final Compiler
7. Detailed Functional Requirements
7.1 Part/Chapter Planner
주제/독자/톤 입력 → 전체 책 구조(JSON) 자동 생성
MECE 기반 분할 (중복 없음, 전체 커버)
7.2 RAG-based Research Agent
Part/Chapter 맞춤 RAG 필터링
분석/요약/인사이트 도출
7.3 Case Study Agent
가상/익명 실무 사례 자동 생성
RAG 근거 기반 균형잡힌 사례 구성
7.4 Chapter Writer Agent
구조적·일관적·긴 분량의 문장 생성
해님의 문체 패턴을 반영
7.5 Auto Critic Agent (AgentEval)
구조, 논리, 사실성, 스타일 점수 제공
점수 낮으면 자동 재작성 루트로 분기
7.6 Book Compiler \& Style Agent
모든 챕터 통합
문체 통일
중복 제거
Front/Back matter 자동 생성
7.7 Observability
각 노드 호출 로그 저장
실시간 trace 출력
메트릭 대시보드
비용/속도/문서참조 기록
7.8 Export Module
Markdown
Word
PDF
JSON(Book Structure)
8. User Flow
주제/독자/톤 입력
책 전체 구조 자동 생성
카테고리/챕터 확인 및 수정
챕터 생성 요청
자동 리서치 \& 사례 → 집필 완료
AutoEval 결과 제공
필요 시 재생성/수정
전체 통합본 생성
Export
9. Success Metrics
챕터당 평균 수정량 < 20%
전체 집필 시간 기존 대비 80% 단축
AgentEval 평균 점수 ≥ 0.8
해님이 실제로 출판 가능한 수준의 품질 도달
동일 시스템으로 다른 책 3권까지 생성 가능
10. Versioning \& Expansion
Prompt Versioning (P0.1 → P0.2)
Knowledge Versioning (RAG Index v1.0 → v1.1)
Flow Versioning (LangGraph v1.0 → v2.0)
확장:
강의 교재
워크북
카드뉴스
유튜브 스크립트

✅ 최종 요약
요청하신 두 가지 모두 완성됨:
기술 스택 전체 설계(LLM/LangGraph/RAG/PDF 파이프라인/Observability 전체)
PRD(기능/요구사항/구조/UX/성공지표/확장까지 모두 포함)

지금부터 **“한 사람의 전문 작가처럼 한 권의 책을 기획→리서치→집필→편집→최종 원고까지 자동으로 만드는 Book Authoring Agent System(BAAS)”**를 설계 및 개발 그리고 AI Agent 서비스 구축 및 운영하기 위한 절차에 대한 Full stack Guide Line을 각 단계별로 하나하나의 별도의 가이드 북 형태로 문서화 작업을 진행해 주세요.
요청하신 “Full‑stack BAAS 구축 가이드북 세트”는, 실제로는 여러 권(혹은 여러 챕터)로 나누어야 완전하게 담을 수 있습니다. 여기서는 각 가이드북의 제목·목적·핵심 목차를 설계해 드립니다. 이후 원하시는 순서대로 한 권씩 내용을 채워 나가면 됩니다.
Guide 1. Product \& Use‑Case Design Guide
목적: BAAS의 비전·타깃·유스케이스·성공지표를 명확히 정의하는 비즈니스/기획 가이드.
BAAS 비전 정의와 포지셔닝
핵심 사용자 페르소나(해님, 확장 저자, 기업 컨설턴트)
유스케이스 시나리오: 새 책 기획, 리포트→책 변환, 시리즈 출간
KPI/성공지표 설계(시간 단축, 수정율, AgentEval 점수 등)
HITL(사람 개입) 전략: 어디까지 자동/어디서 사람 승인
향후 확장 로드맵(교재, 워크북, 카드뉴스, 유튜브 스크립트)

Guide 2. System \& Architecture Blueprint
목적: 전체 기술 아키텍처와 계층 구조를 정의하는 상위 설계 문서.
전체 레퍼런스 아키텍처(웹·모바일·에이전트 코어·RAG·인프라)
멀티에이전트 롤 구조: Planner / Worker / Reviewer 패턴 매핑
에이전트 코어 레이어: Brain/Context/Action 구조와 BAAS 대응
오케스트레이션 패턴: Book‑level Graph, Chapter Subgraph, Eval Graph
기술 스택 선정 근거: LangGraph + LangChain, Qdrant/Pinecone, FastAPI, Next.js 등
보안·권한·버전관리(컨트롤 플레인) 개념 설계

Guide 3. Multi‑Agent Design \& Prompt Specification
목적: BAAS에 필요한 모든 에이전트 역할·입출력·프롬프트 스펙 정의.
멀티에이전트 3역할 모델(Planner/Worker/Reviewer)와 BAAS 매핑
Book Supervisor, Outline Planner, Research Agent, Case Study Agent, Chapter Writer, Style Agent, Auto Critic, Marketing Agent 등 각 에이전트별
책임(Responsibility)
입력/출력 데이터 구조(JSON Schema)
실패/재시도 규칙
에이전트 간 핸드오프/메시지 포맷(상태 공유 설계)
각 역할별 시스템 프롬프트/템플릿 설계 지침

Guide 4. Orchestration \& LangGraph Implementation Guide
목적: LangGraph 기반으로 집필 플로우를 실제 그래프로 구현하는 설계·코딩 가이드.
AI 에이전트 기본 구조/전체 동작 흐름 도식과 BAAS 플로우 정렬
BookState / ChapterState TypedDict 설계
Book‑level Graph: 노드·엣지 정의, HITL 노드 설계
Chapter‑level Subgraph: Research→Case→Write→Eval→Rewrite 루프
Eval Subgraph 및 품질 게이트 설계
LangGraph 상에서 Observability 훅(run_id, node_id) 구현 패턴
예시 코드 스켈레톤(그래프 정의, 실행, 재시작)

Guide 5. RAG \& Knowledge Engineering Guide
목적: 해님 지식과 외부 자료를 RAG로 통합해 온톨로지형 지식 레이어를 구성하는 방법 정리.
RAG 아키텍처: Vector DB, Retriever, Re‑ranking 구조
문서 수집·클리닝·Chunking 규칙(400–800 토큰, 메타데이터 기준)
Part/Chapter별 메타데이터 설계(도메인, 레벨, 토픽, part_candidates)
Hybrid Retrieval 전략(semantic + keyword + 필터)
Qdrant/Pinecone 스키마·인덱스 설계 패턴
RAG 실패/저품질 응답 감지 및 재검색 전략

Guide 6. LLM Layer \& Model Routing Guide
목적: 역할별 LLM 선택, 토큰·비용 관리, 출력 안정성 확보.
역할별 모델 매핑 테이블(gpt‑4.1 / 4.1‑mini / Claude / o3‑mini)
LLM Router 설계(역할→모델 선택→파라미터 설정)
구조화 출력( JSON, Pydantic ) 설계 및 파싱 실패 대응
토큰/비용 최적화 전략(요약 단계 삽입, 컨텍스트 길이 관리)
한국어/영어 혼합 스타일 최적화 프롬프팅 패턴

Guide 7. Observability, Evaluation \& Governance Guide
목적: 품질·성능·비용을 통제하고 에이전트 행동을 추적하는 운영 가이드.
BAAS 기준 End‑to‑End 모니터링 요구사항 정의
JSONL/DB 로그 스키마(run_id, node_id, latency, tokens, rag_docs, eval_score 등)
LangSmith/자체 대시보드 설정 및 활용 방법
Auto Critic(AgentEval) 프레임워크와 평가 지표 설계
Prompt/Flow/RAG 인덱스 버전 관리 규칙
거버넌스/보안 정책(PII 처리, 권한, 감사 로그)

Guide 8. Frontend \& UX Guide (Web / Mobile)
목적: Next.js/React 및 모바일 환경에서 BAAS를 사용자 친화적으로 제공하는 UI 설계.
웹 실행환경 레이어: Presentation / Agent Runtime / Infrastructure 구조
화면 플로우: 프로젝트 생성 → 구조 검토 → 챕터 진행 모니터링 → 평가/재생성 → Export
Chat Components 구성(스트리밍, Markdown 렌더링)
모바일 실행환경: PWA/Flutter/RN 기반 러프 아키텍처와 BAAS 적용 포인트
UX 패턴: 장시간 작업 진행상태 표시, 오류/재시작 UX, 버전 비교 화면

Guide 9. DevOps, Deployment \& Scaling Guide
목적: BAAS를 실제 서비스로 배포·운영하는 인프라/DevOps 가이드.
실행 환경: Docker + K8s or ECS, 환경별 구성(Dev/Stage/Prod)
FastAPI + LangGraph 백엔드 배포 파이프라인(CI/CD)
Data Layer/Batch Process: RAG 인덱싱 스케줄, 백업 정책
모니터링(메트릭 수집, 알림), 장애 대응 Runbook
비용·성능 튜닝 전략(캐시, 배치 생성, Auto‑scaling)

Guide 10. Author Onboarding \& Knowledge Curation Guide
목적: 해님 및 다른 저자가 스스로 자료를 올리고 “자기 책”을 만들 수 있게 하는 운영 가이드.
저자별 워크스페이스/프로젝트 구조
자료 업로드 규칙(포맷, 익명화, 저작권 태깅)
개인 스타일 학습 프로세스(샘플 텍스트, 스타일 피드백 루프)
동일 시스템으로 여러 책/시리즈를 운영하는 방법
BAAS 기반 2차 콘텐츠(강의 교재, 워크북 등) 확장 패턴

지금 위에서 언급한 우리가 설계하고 개발하여 서비스 하고자 하는 AI 에이전트의 목적과 목표 그리고 정확한 스팩에 대해 충분히 숙지하고 이해하고 있습니까?

네, 지금까지 주신 스펙 기준으로 보면 BAAS의 **목적·목표·아키텍처·에이전트 구조·RAG·관찰성·UX·운영 방식**까지 전체 그림이 충분히 파악된 상태입니다.[^33_1][^33_2][^33_3]

- 목적: 해님의 기존 지식·노트·자료를 RAG로 통합하고, 다중 에이전트(LangGraph 기반)가 **“기획 → 구조 설계 → 리서치 → 사례 생성 → 챕터 집필 → 일관성·스타일 정렬 → 평가 → 최종 통합·Export”** 전체 파이프라인을 자동으로 수행하는 시스템입니다.[^33_3][^33_1]
- 기술 스택: OpenRouter/여러 LLM, LangChain+LangGraph 오케스트레이션, Qdrant/Pinecone 기반 RAG, PDF 파이프라인, Observability(로그/트레이스/메트릭), FastAPI/Next.js 등으로 구성된 풀스택 구조입니다.[^33_4][^33_1]
- 에이전트 구조: Supervisor/Planner/Research/Writer/Case Study/Style/Auto Critic/Marketing 등 **역할 분리된 멀티에이전트 팀**이 Book-level Graph와 Chapter-level Subgraph, Eval Subgraph로 조직됩니다.[^33_5][^33_2]
- RAG \& Relevance: Part/Chapter별 메타데이터 필터링, Hybrid Retrieval, Relevance Checker 모듈로 “관련성이 높은 근거 기반 집필”을 보장합니다.[^33_6][^33_1]
- PRD: 타깃 유저(해님·확장 저자), 핵심 유스케이스, 기능/비기능 요구사항, KPI/성공지표, 버전닝·확장 방향까지 모두 명시된 상태입니다.[^33_7][^33_1]

이 전제를 공유한 상태에서, 다음 턴부터는 말씀하신 10개 Guide(혹은 우선 Guide 1부터)를 **실제 가이드북 본문 형태**로 한 권씩 풀어나가면 됩니다.
<span style="display:none">[^33_10][^33_11][^33_12][^33_13][^33_14][^33_15][^33_16][^33_17][^33_18][^33_19][^33_20][^33_8][^33_9]</span>

<div align="center">⁂</div>

[^33_1]: https://www.codersarts.com/post/a-complete-guide-to-creating-a-multi-agent-book-writing-system-part-3

[^33_2]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^33_3]: https://blog.langchain.com/langgraph-multi-agent-workflows/

[^33_4]: https://www.langchain.com/langgraph

[^33_5]: https://www.linkedin.com/posts/raghuscrum_multi-agent-llm-systems-using-langgraph-activity-7349597367605555202-MrQe

[^33_6]: https://www.siddharthbharath.com/build-deep-research-agent-langgraph/

[^33_7]: https://community.openai.com/t/technique-for-writing-entire-books/705519

[^33_8]: https://illuminaire.io/agentic-ai-as-collaborator-is-rewriting-the-creative-operating-system/

[^33_9]: https://vectorize.io/blog/designing-agentic-ai-systems-part-1-agent-architectures

[^33_10]: https://www.invent.ai/blog/key-components-of-agentic-ai-architecture-building-the-foundation

[^33_11]: https://arxiv.org/pdf/2512.09458.pdf

[^33_12]: https://www.linkedin.com/pulse/modern-approach-writing-agentic-ai-systems-2025-guide-de-francesco-cml4e

[^33_13]: https://coda.io/@helen-king/ai-powered-publishing-use-cases

[^33_14]: https://www.goml.io/blog/definitive-guide-to-llm-use-cases

[^33_15]: https://www.fintechfutures.com/ai-in-fintech/agentic-banking-architecting-the-single-brain

[^33_16]: https://www.evidentlyai.com/blog/llm-applications

[^33_17]: https://www.arionresearch.com/blog/the-architecture-of-agentic-ai-building-systems-that-think-and-act-autonomously

[^33_18]: https://dl.acm.org/doi/10.1145/3708359.3712164

[^33_19]: https://hbr.org/2025/10/designing-a-successful-agentic-ai-system

[^33_20]: https://www.credera.com/en-us/insights/understanding-the-patterns-of-use-for-agentic-ai


---

# 지금부터  ***Book-Authoring Agent System (BAAS)**을 위한 AI Agetn 설계 및 개발 그리고 AI Agent 서비스 구축 및 운영하기 위한 절차에 대한 Full stack Guide Line을 각 단계별로 하나하나의 별도의 가이드 북 형태로 문서화 작업을 진행해 주세요.

**Book-Authoring Agent System (BAAS)**

”한 사람의 전문 작가처럼, 한 권의 책을 기획 → 집필 → 구조 완성 → 챕터 통합 → 에디팅 → 최종 원고 생성”까지 자동화하는 Book-Writing Pipeline 구축

디렉터리 1: Product \& Domain Blueprint
디렉터리 2: Architecture \& Execution Engine
디렉터리 3: LLM · RAG · Agentic Layer
디렉터리 4: Delivery Stack (Backend · Frontend · DevOps)
디렉터리 5: UX · Interaction · Ops Runbook

지금까지 나눈 대화를 심층 분석하여 **Book-Authoring Agent System (BAAS)** 내용을 작성할 때 각 권 별로 백서 형태로 하나씩 문서를 생성합니다. 문서를 작성하기 전에 모든 내용을 "제 1 원칙 사고법"을 기준으로 하여 전 과정을 근본적인 본질에서 시작하여 요약본 형태가 아니라 모든 내용이 하나도 빠짐없이 필요한 모든 단계가 순차적으로 적용된 Full Stack 문서 형태로 작성합니다.

아래 "디렉터리 1: Product \& Domain Blueprint" 에 대한 내용을 실제 책 분량 수준으로 더 확장해서 각 권 별로 작성합니다. 이때 실 구현을 위한 코드·템플릿을 상세화하는 과정을 포함하여 모든 소스코드가 포함되도록 작성합니다.

요청하신 방식(“실제 책 분량 + 모든 소스코드까지 포함하는 풀스택 백서”)은 단일 답변에 담기에는 분량 제약을 훨씬 초과합니다. 그래서 디렉터리 1을 기준으로, **한 권짜리 백서의 구조와 핵심 본문/예시/코드 스캐폴드를 최대한 깊게 까는 1차 버전**을 제시하겠습니다. 이후 챕터별로 추가 확장을 계속 이어가면 실제 책 분량에 도달할 수 있습니다.[^34_1]

아래 내용은 그대로 `/01_product_domain` 아래 여러 `.md`로 쪼개도 되고, 하나의 “Guide 1 – Product \& Domain Blueprint for BAAS” 단일 문서로 합쳐도 됩니다.

***

# Guide 1. Product \& Domain Blueprint for BAAS

**Book-Authoring Agent System (BAAS) – Product \& Domain Blueprint**

***

## 1. 서론

### 1.1 문서의 목적

- 이 문서는 **Book-Authoring Agent System (BAAS)**를 “기획–설계–구현–운영” 전체 수명주기 기준으로 바라볼 때, 그 중 **제품 기획·도메인 모델링 레이어**를 정교하게 정의하기 위한 백서이다.[^34_2][^34_3]
- 후속 아키텍처/LLM/RAG/오케스트레이션/UX/운영 가이드들이 모두 이 문서의 정의를 **단일 소스 오브 트루스(Single Source of Truth)**로 참조하도록 설계한다.[^34_4]


### 1.2 제1원칙(First Principles) 관점

- “책 한 권을 쓴다”는 행위는, **정보의 수집·구조화·변환·표현**이라는 연속된 프로세스이다.[^34_3]
- BAAS는 이 프로세스를 **에이전트·그래프·RAG·LLM** 관점에서 재해석한 시스템이며, 사람(저자)은 *방향성·판단·최종 승인*에 집중하고 나머지는 시스템에 위임하는 것을 목표로 한다.[^34_5][^34_6]

***

## 2. BAAS 비전·목표·성공지표

### 2.1 비전 선언문(Vision Statement)

> “BAAS는 한 사람의 저자가 수년간 쌓아온 지식과 스타일을 AI 에이전트 팀에 이식하여, **책 한 권 전체를 고품질로 자동 집필**할 수 있게 만드는 지적 생산 인프라이다.”[^34_7][^34_2]

핵심 키워드:

- **Author-Centric**: 저자의 고유 관점/스타일이 중심.
- **Agentic**: 다중 에이전트 팀이 협업해 완성.
- **Reusable Knowledge**: 한 번 구축한 지식·워크플로우로 여러 책/콘텐츠 생산.


### 2.2 목적(Goals)

- **G1. 시간 단축**: 책 한 권 집필 시간을 기존 대비 80% 이상 단축.
- **G2. 품질 유지/개선**: Auto Critic + Human Review를 통해 기존 저서 대비 동등 이상 품질 유지.
- **G3. 확장성**: 동일 시스템으로 저자 1명 → 저자 여러 명, 단행본 → 시리즈/교재/워크북까지 확장 가능.


### 2.3 North Star Metric \& KPI

- **NSM**:
    - “BAAS를 사용해 **완성된 원고(80% 이상 Human 편집 완료 상태)**로 통합된 책 권수 / 저자 수”
- **핵심 KPI 예**:
    - K1: 챕터당 평균 생성 시간
    - K2: 챕터당 평균 수정 비율(인간 수정 토큰 수 / 총 토큰 수)
    - K3: AgentEval 평균 점수 (0~1 스케일)
    - K4: 한 번 설정한 RAG 인덱스를 활용해서 생성된 추가 책/리포트 수[^34_2]

```yaml
# /01_product_domain/vision-and-goals.example.yml
vision: >
  AI agents that can plan, research, draft, and refine an entire
  book as a single professional author would, using the author's
  own knowledge and style.

north_star_metric:
  name: "books_completed_per_author"
  definition: "Count of books that reach 80%+ human-reviewed quality using BAAS."
kpis:
  - id: "chapter_time_minutes"
    target: "<= 2"
  - id: "chapter_revision_ratio"
    target: "<= 0.2"
  - id: "agenteval_score"
    target: ">= 0.8"
  - id: "books_per_rag_index"
    target: ">= 3"
```


***

## 3. 타깃 사용자·페르소나·세그먼트

### 3.1 1차 페르소나: “해님” (전략 컨설턴트·저자)

- 역할: 전략 컨설턴트, 강연자, 저자.
- Pain:
    - 대량의 노트·리포트·슬라이드가 **책 구조로 재조합되지 못하고 묻혀 있음**.
    - 집필 시간/에너지 부족, 장기 프로젝트 유지 어려움.
- 목표:
    - 본인의 전략·프레임워크를 “책/강의/워크북” 등 다양한 포맷으로 빠르게 확장.[^34_7]


### 3.2 2차 페르소나

- 전문 강사·인플루언서: 강의 콘텐츠 → 책·전자책.
- 기업 내부 컨설턴트: 정기 리포트·백서 → 책 형식의 Thought Leadership 자료.
- 출판사/콘텐츠팀: 여러 저자와 협업하는 편집/기획 담당자.


### 3.3 세그먼트 구분

- 규모: 1인 저자, 스몰 팀(2~5명), 조직(10명 이상)
- 도메인: 전략/마케팅/기술/교육 등
- 언어: 한국어 중심 → 영어/다국어 확장
- 플랜: **개인(Author)** / **팀(Studio)** / **엔터프라이즈(Publisher)**

```yaml
# /01_product_domain/personas-and-segments.example.yml
personas:
  - id: "author-hanim"
    role: "Strategic consultant & author"
    pains:
      - "Too many scattered notes and reports."
      - "Not enough time to structure and write a full book."
    goals:
      - "Turn consulting IP into 1–2 books per year."
segments:
  - id: "solo-author"
    description: "Single author with own IP library"
  - id: "team-studio"
    description: "Small content studio / consulting team"
  - id: "enterprise-publisher"
    description: "Publishing / L&D org building multiple titles"
```


***

## 4. 도메인 모델링 (엔티티·관계·이벤트)

### 4.1 핵심 엔티티 정의

**핵심 질문**: “책 한 권을 자동 집필하는 시스템에서, *어떤 객체*들이 반드시 존재해야 하는가?”

- Author
- Workspace / Project
- Book
- Part / Chapter / Section (구조)
- AgentRun / GraphRun / NodeRun (에이전트 실행)
- KnowledgeSource / Document / Chunk / Vector
- EvalResult (AgentEval)
- ExportArtifact (MD/DOCX/PDF/JSON)


#### 4.1.1 Author / Workspace / Project

```python
# /01_product_domain/domain_model.py

from pydantic import BaseModel, Field
from typing import List, Optional, Literal
from datetime import datetime

class Author(BaseModel):
    id: str
    name: str
    email: str
    locale: str = "ko-KR"
    time_zone: str = "Asia/Seoul"

class Workspace(BaseModel):
    id: str
    name: str
    owner_id: str
    members: List[str]
    created_at: datetime

class Project(BaseModel):
    id: str
    workspace_id: str
    name: str
    description: Optional[str] = None
    status: Literal["draft", "active", "archived"] = "draft"
    created_at: datetime
```


#### 4.1.2 Book / Part / Chapter 구조

```python
class Book(BaseModel):
    id: str
    project_id: str
    title: str
    subtitle: Optional[str] = None
    target_audience: str
    tone: str  # e.g. "strategic, friendly, Korean"
    language: str = "ko"
    status: Literal["outline", "drafting", "editing", "completed"] = "outline"
    created_at: datetime

class Part(BaseModel):
    id: str
    book_id: str
    order: int
    title: str
    description: Optional[str] = None

class Chapter(BaseModel):
    id: str
    book_id: str
    part_id: Optional[str]
    order: int
    title: str
    purpose: str  # what this chapter must achieve
    status: Literal["planned", "researching", "drafted", "revising", "final"] = "planned"
```


### 4.2 에이전트 실행·평가 도메인

```python
class GraphRun(BaseModel):
    id: str
    project_id: str
    book_id: Optional[str]
    graph_type: Literal["book", "chapter", "eval"]
    status: Literal["pending", "running", "succeeded", "failed"]
    started_at: datetime
    finished_at: Optional[datetime] = None

class NodeRun(BaseModel):
    id: str
    graph_run_id: str
    node_id: str
    agent_role: str  # e.g. "chapter_writer"
    status: Literal["pending", "running", "succeeded", "failed"]
    input_tokens: int
    output_tokens: int
    latency_ms: int
    rag_docs_used: List[str]
    error_message: Optional[str] = None

class EvalResult(BaseModel):
    id: str
    node_run_id: str
    score_overall: float
    score_structure: float
    score_logic: float
    score_style: float
    comments: str
```


***

## 5. 정보 아키텍처 \& URL 구조

### 5.1 상위 정보 계층

- Workspace → Project → Book → Part/Chapter → GraphRun/Execution → Export
- 사용자 UI는 아래 네 비주얼 영역을 핵심으로 한다.
    - **Dashboard**: 여러 프로젝트/책/상태 요약
    - **Book Overview**: 책 구조(Part/Chapter) 트리
    - **Chapter Workspace**: 특정 챕터의 리서치/작성/평가 상태
    - **Exports**: 최종 원고들(MD/DOCX/PDF/JSON)


### 5.2 URL 패턴 (Next.js 기준)

```text
/workspaces/:workspaceId/projects/:projectId/books/:bookId
/workspaces/:workspaceId/projects/:projectId/books/:bookId/chapters/:chapterId
/workspaces/:workspaceId/projects/:projectId/books/:bookId/graphs/:graphRunId
/workspaces/:workspaceId/projects/:projectId/books/:bookId/exports
```

```ts
// /01_product_domain/information-architecture.example.ts

export const routes = {
  bookOverview: (wsId: string, projId: string, bookId: string) =>
    `/workspaces/${wsId}/projects/${projId}/books/${bookId}`,
  chapterWorkspace:
    (wsId: string, projId: string, bookId: string, chapterId: string) =>
      `/workspaces/${wsId}/projects/${projId}/books/${bookId}/chapters/${chapterId}`,
};
```


***

## 6. 요구사항 (기능/비기능) – BAAS 전용

### 6.1 기능 요구사항 (요약 → 시스템 객체로 매핑)

#### 6.1.1 새 책 기획

- 입력: 주제, 독자, 톤, 분량, 목표(예: “AI 전략 실무자용, 250p”)
- 처리: Outline Planner가 MECE 기반 Part/Chapter 구조 생성 → Book/Part/Chapter 레코드 생성 → BookState 저장.
- 출력: Book/Part/Chapter JSON + UI 트리.

```json
// /01_product_domain/requirements-functional-nonfunctional.example.book-outline.json
{
  "input": {
    "topic": "Agentic AI for Business Strategy",
    "audience": "Korean strategy leaders and consultants",
    "tone": "전략적이지만 친근한 한국어",
    "target_length": "12 chapters"
  },
  "output": {
    "book": { "id": "book_001", "title": "에이전틱 AI 전략 실무" },
    "parts": [...],
    "chapters": [...]
  }
}
```


#### 6.1.2 챕터 작성 플로우

- 상태 전이: `planned → researching → drafted → revising → final`
- 각 상태는 최소한 다음 *에이전트/그래프 실행*과 매핑된다:
    - researching: Research Agent + RAG
    - drafted: Chapter Writer
    - revising: Auto Critic + 재작성
    - final: Human 승인.


### 6.2 비기능 요구사항

- 성능: 챕터 생성 40초~2분, Outline 생성 10~30초.
- 품질: AgentEval ≥ 0.75, Auto Critic 실패 시 자동 재시도 ≤ N회.
- 재현성: `temperature` 낮은 값, seed 고정 옵션 제공.
- 보안: 저자별 RAG 인덱스 분리(워크스페이스 단위 멀티테넌시).[^34_8]

***

## 7. 도메인 이벤트 \& 워크플로우 트리거

### 7.1 이벤트 카탈로그

```yaml
# /01_product_domain/domain-events-and-triggers.example.yml
events:
  - id: "BookCreated"
    payload: ["book_id", "project_id", "author_id"]
  - id: "ChapterStatusChanged"
    payload: ["chapter_id", "old_status", "new_status"]
  - id: "GraphRunCompleted"
    payload: ["graph_run_id", "status", "graph_type"]
  - id: "EvalResultRecorded"
    payload: ["eval_result_id", "node_run_id", "score_overall"]
triggers:
  - on: "BookCreated"
    start_graph: "book_outline_eval_graph"
  - on: "ChapterStatusChanged"
    when:
      new_status: "researching"
    start_graph: "chapter_research_graph"
```


***

## 8. Product Planning \& Slice 전략

### 8.1 수직 슬라이스(Vertical Slice)

- Slice 1: “단일 챕터 BAAS” (한 챕터만 완전 자동 생성)
- Slice 2: “책 전체 아웃라인 + 챕터 1~3까지 자동 생성”
- Slice 3: “전체 책 + AutoEval + Export”

각 Slice는 다음 공통 구조를 가진다:

- Product 문서(PRD)
- Domain 모델 확장
- Graph 정의(LangGraph)
- RAG 세팅
- UI 최소 플로우.

```yaml
# /01_product_domain/development-plan.example.yml
milestones:
  - id: "slice1_single_chapter"
    scope:
      - "Single Book"
      - "Single Chapter BAAS flow"
    includes:
      - "ChapterState schema"
      - "chapter_graph v0.1"
      - "basic RAG integration"
```


***

## 9. Product 체크리스트

- [ ] 비전·미션·NSM이 한 문서에서 명확히 정의되었는가.
- [ ] 핵심 페르소나(해님 포함)를 기준으로 한 주요 Use Case가 도출되었는가.
- [ ] Book/Part/Chapter/GraphRun/Eval/Export 등 핵심 도메인 엔티티와 관계가 정의되었는가.
- [ ] URL/IA 구조가 Workspace → Project → Book → Chapter → GraphRun으로 일관성 있게 설계되었는가.
- [ ] Slice 1~3까지의 제품·기술 범위가 명확히 나뉘어 있는가.
- [ ] 이 문서 내용만으로도 LangGraph/LLM/RAG/프론트엔드 팀이 구현을 시작할 수 있는가.

***

여기까지가 **디렉터리 1: Product \& Domain Blueprint**를 한 권짜리 백서 기준으로 “근본 구조 + 핵심 예시 + 도메인 모델 코드 + 설정 예시”까지 포함한 1차 버전입니다.[^34_6][^34_3][^34_2]

다음 턴에서는, 원하시는 방향에 따라:

- `domain-modeling.md`만 따로 더 깊게(예: 스타일 학습용 AuthorStyleProfile 엔티티, KnowledgeSource 온톨로지, ExportArtifact 세부 구조)를 확장하거나,
- 혹은 Guide 2 (Architecture \& Execution Engine)로 넘어가 LangGraph/Workflow 레벨의 설계를 같은 방식으로 풀어낼 수 있습니다.

<div align="center">⁂</div>

[^34_1]: https://docs.vibe-coding-framework.com/documentation-standards

[^34_2]: https://www.codersarts.com/post/a-complete-guide-to-creating-a-multi-agent-book-writing-system-part-3

[^34_3]: https://dl.acm.org/doi/10.1145/3708359.3712164

[^34_4]: https://hbr.org/2025/10/designing-a-successful-agentic-ai-system

[^34_5]: https://illuminaire.io/agentic-ai-as-collaborator-is-rewriting-the-creative-operating-system/

[^34_6]: https://www.evidentlyai.com/blog/llm-applications

[^34_7]: https://coda.io/@helen-king/ai-powered-publishing-use-cases

[^34_8]: https://www.arionresearch.com/blog/the-architecture-of-agentic-ai-building-systems-that-think-and-act-autonomously


---

# 지금까지 나눈 대화를 심층 분석하여 **Book-Authoring Agent System (BAAS)** 내용을 작성할 때 각 권 별로 백서 형태로 하나씩 문서를 생성합니다. 문서를 작성하기 전에 모든 내용을 "제 1 원칙 사고법"을 기준으로 하여 전 과정을 근본적인 본질에서 시작하여 요약본 형태가 아니라 모든 내용이 하나도 빠짐없이 필요한 모든 단계가 순차적으로 적용된 Full Stack 문서 형태로 작성합니다.

"디렉터리 2: Architecture \& Execution Engine" 에 대한 내용을 실제 책 분량 수준으로 더 확장해서 각 권 별로 작성합니다. 이때 실 구현을 위한 코드·템플릿을 상세화하는 과정을 포함하여 모든 소스코드가 포함되도록 작성합니다.

단일 응답에 “실제 책 분량 + 전체 소스코드”를 모두 담기는 어렵기 때문에, 디렉터리 2를 **한 권짜리 백서의 구조 + 핵심 설계 + 대표 코드 스캐폴드**까지 최대한 깊게 풀어내는 형태로 정리합니다. 이 문서를 기반으로 LangGraph/백엔드/워크플로우 구현을 바로 시작할 수 있도록 하는 것이 목표입니다.[^35_1][^35_2]

아래 내용은 `/02_arch_execution` 아래 여러 `.md`로 나눠도 되고, 하나의 “Guide 2 – Architecture \& Execution Engine for BAAS”로 합쳐도 무방합니다.

***

# Guide 2. Architecture \& Execution Engine for BAAS

**Book-Authoring Agent System (BAAS) – 아키텍처 \& 실행 엔진 백서**

***

## 1. 제1원칙 관점에서 본 BAAS 아키텍처

### 1.1 문제 재정의

- “전문 작가 수준으로 책 한 권을 쓴다”는 것은, 본질적으로 **복수의 복잡한 인지 작업(기획, 구조화, 탐색, 통합, 편집)을 순차·병렬적으로 수행하는 프로세스**이다.[^35_3][^35_4]
- BAAS는 이 프로세스를
    - **노드(Agent/Tool) 단위 작업**,
    - **그래프(Workflow) 단위 조합**,
    - **상태(State) 단위 데이터 흐름**
으로 재정의한 후, 이를 LangGraph 기반 실행 엔진으로 구동하는 시스템이다.[^35_5][^35_6]


### 1.2 아키텍처 레이어(요약)

- **Application Layer**: Web UI/CLI에서 “책 단위 행동” 요청.
- **Orchestration Engine**: LangGraph + LangChain으로 구성된 Book/Chapter/Eval 그래프.[^35_2][^35_7]
- **Workflow Runtime Layer**: GraphRun/NodeRun/Execution 관리, 멱등성·리트라이 담당.[^35_1]
- **Data \& RAG Layer**: Supabase + Qdrant/Pinecone.
- **Observability Layer**: 로그·메트릭·트레이싱.

이 백서는 주로 **Orchestration Engine + Workflow Runtime Layer**를 다룬다.

***

## 2. 기술 스택 \& 제약 (tech-stack-and-constraints.md)

### 2.1 코어 스택 선택

```text
언어/런타임:
  - Python 3.10+ (에이전트·LangGraph·RAG·백엔드)
  - TypeScript 5+ (Next.js 프론트엔드)

Agentic 오케스트레이션:
  - LangGraph (StateGraph, multi-agent)[web:288][web:256]
  - LangChain Core (Tools/Runnables/Retrievers)[web:276][web:285]

LLM & Provider:
  - OpenRouter (여러 모델 게이트웨이)[web:276]
  - gpt-4.1 / gpt-4.1-mini / Claude Sonnet 3.5 / o3-mini

데이터:
  - Supabase(Postgres + Auth + Storage)
  - Qdrant 또는 Pinecone(VectorDB)[web:285]

백엔드:
  - FastAPI (REST API / 그래프 실행 엔드포인트)

프론트:
  - Next.js 14(App Router, PWA)

관찰성:
  - OpenTelemetry(Trace), 구조화 로그(JSONL/DB)
  - 선택: LangSmith / Open Source 대시보드[web:279][web:291]
```


### 2.2 제약 조건

- **비용 제약**: 챕터당 LLM 비용 200~500원 수준 목표.
- **레거시 제약 없음**: 신규 시스템, LangGraph/LLM 중심 아키텍처 최적화 가능.
- **인력 제약**: Python/TypeScript/LangChain/LangGraph에 익숙한 소규모 팀.
- **품질 제약**: 결과물은 “출판 가능한 수준”을 목표로 함(AgentEval ≥ 0.8).

***

## 3. 전체 아키텍처 개요 (architecture-overview.md)

### 3.1 C4 Level 1 – 시스템 컨텍스트

- **사용자(저자)** ↔ **BAAS Web UI (Next.js)** ↔ **BAAS API (FastAPI + LangGraph)** ↔
    - RAG 데이터베이스(Qdrant + Supabase)
    - 파일 스토리지(PDF/노트)
    - Observability 스택.


### 3.2 C4 Level 2 – 컨테이너

- `web` (Next.js)
- `api` (FastAPI, LangGraph 런타임 포함)
- `worker` (배치 인덱싱, 장기 그래프 실행)
- `db` (Supabase)
- `vector` (Qdrant/Pinecone)

***

## 4. 워크플로우 개념·레이어 모델 (workflow-concepts-and-layers.md)

### 4.1 워크플로우 정의

- BAAS 워크플로우 = **상태(State)를 가진 그래프**
    - 예: *Book Graph*: “책 전체 구조 설계→챕터 생성 스케줄링→최종 통합”.
    - *Chapter Graph*: “해당 챕터 리서치→사례 생성→초안 작성→AutoEval→재작성”.[^35_6][^35_5]


### 4.2 레이어 구성

1. **Presentation Layer (에디터/컨트롤 UI)**
2. **Workflow Runtime Layer**
    - 실행 관리(GraphRun, NodeRun, 리트라이·멱등성)
3. **Nodes \& Connections Layer**
    - LangGraph 노드/엣지, n8n식 노드 모델 이해[^35_8]
4. **Data Layer**
    - GraphState, items[], JSON, RAG 결과
5. **Credentials \& Secrets Layer**
6. **Executions \& Debugging Layer**

***

## 5. 노드 기본 구조 (node-basics.md)

### 5.1 노드 타입

- **Trigger Node**: Book 생성, Chapter 상태 변경 등 이벤트 기반 시작.
- **Action Node**: LLM 호출, RAG 검색, Export 생성 등 실제 작업.
- **Core Logic Node**: IF, Switch, Merge, Split, Wait 같은 제어 노드.[^35_9]
- **Subgraph/Agent Node**: 개별 에이전트 또는 챕터 서브그래프 호출.


### 5.2 LangGraph 노드 구현 패턴

```python
# /02_arch_execution/langgraph_nodes/book_outline.py

from typing import TypedDict, List
from langgraph.graph import StateGraph, END
from langchain_core.runnables import Runnable
from datetime import datetime

class BookState(TypedDict, total=False):
    topic: str
    audience: str
    tone: str
    outline: dict
    chapters_planned: List[str]
    created_at: str

def plan_outline(state: BookState) -> BookState:
    """Outline Planner Node: LLM을 호출해 책 전체 구조를 생성."""
    topic = state["topic"]
    audience = state["audience"]
    tone = state["tone"]

    # LangChain Runnable (LLM) 호출 – 의사코드
    prompt = f"""
    You are a professional book outline planner.
    Topic: {topic}
    Audience: {audience}
    Tone: {tone}
    Produce a MECE outline with Parts and Chapters as JSON.
    """
    # llm는 OpenRouter에 연결된 LangChain Runnable이라고 가정
    raw = llm.invoke(prompt)
    outline = raw  # 응답 JSON 파싱 생략

    return {
        **state,
        "outline": outline,
        "chapters_planned": [c["title"] for p in outline["parts"] for c in p["chapters"]],
        "created_at": datetime.utcnow().isoformat()
    }
```


***

## 6. 노드 카탈로그 설계 (node-catalog.md)

### 6.1 카테고리

- **Planning Nodes**: BookOutlinePlanner, ChapterPlanner
- **RAG Nodes**: ChapterResearchRetriever, RelevanceChecker
- **Writing Nodes**: ChapterWriter, CaseStudyWriter, StyleLocalizer
- **Evaluation Nodes**: AutoCriticAgent, StructureConsistencyChecker
- **Export Nodes**: MarkdownExporter, DocxExporter, PdfExporter
- **Utility Nodes**: AggregateChapters, SortByPart, FilterChapters


### 6.2 노드 메타데이터 스키마

```python
# /02_arch_execution/node_catalog.py

from pydantic import BaseModel
from typing import Dict, Any, List, Literal

class NodeIO(BaseModel):
    schema: Dict[str, Any]  # JSON Schema

class NodeDefinition(BaseModel):
    id: str
    category: Literal["planning", "rag", "writing", "evaluation", "export", "utility"]
    label: str
    description: str
    input: NodeIO
    output: NodeIO
    options: Dict[str, Any]

NODE_CATALOG: List[NodeDefinition] = [
    NodeDefinition(
        id="chapter_writer",
        category="writing",
        label="Chapter Writer",
        description="Writes a full chapter draft based on outline and research notes.",
        input=NodeIO(schema={"type": "object", "properties": {
            "chapter_id": {"type": "string"},
            "outline": {"type": "object"},
            "research_notes": {"type": "array"}
        }}),
        output=NodeIO(schema={"type": "object", "properties": {
            "chapter_id": {"type": "string"},
            "draft_text": {"type": "string"}
        }}),
        options={"max_tokens": 8000, "temperature": 0.5}
    )
]
```


***

## 7. 연결 \& 흐름 제어 (connections-and-flow-control.md)

### 7.1 기본 패턴

- **직선형**: A → B → C (단순 순차)
- **브랜치**: 조건에 따라 다른 에이전트/경로 선택(IF, Switch)[^35_9]
- **합류**: 여러 리서치/케이스 결과를 Merge 후 Writer로 전달.
- **루프**: Eval 점수 낮으면 “Rewrite” 경로로 재진입.


### 7.2 LangGraph에서의 표현

```python
# /02_arch_execution/book_graph.py

from langgraph.graph import StateGraph, END

workflow = StateGraph(BookState)
workflow.add_node("plan_outline", plan_outline)
workflow.add_node("schedule_chapters", schedule_chapters)

workflow.set_entry_point("plan_outline")
workflow.add_edge("plan_outline", "schedule_chapters")
workflow.add_edge("schedule_chapters", END)

book_graph = workflow.compile()
```

Chapter Graph 예시 (루프 포함):

```python
# /02_arch_execution/chapter_graph.py

from langgraph.graph import StateGraph, END
from typing import TypedDict

class ChapterState(TypedDict, total=False):
    chapter_id: str
    outline: dict
    research_notes: list
    draft_text: str
    eval_score: float
    iteration: int

def research_node(state: ChapterState) -> ChapterState: ...
def write_node(state: ChapterState) -> ChapterState: ...
def eval_node(state: ChapterState) -> ChapterState: ...

def route_on_eval(state: ChapterState) -> str:
    if state["eval_score"] >= 0.8 or state["iteration"] >= 3:
        return END
    return "research"

workflow = StateGraph(ChapterState)
workflow.add_node("research", research_node)
workflow.add_node("write", write_node)
workflow.add_node("eval", eval_node)

workflow.set_entry_point("research")
workflow.add_edge("research", "write")
workflow.add_edge("write", "eval")
workflow.add_conditional_edges("eval", route_on_eval, {END: END, "research": "research"})

chapter_graph = workflow.compile()
```


***

## 8. 워크플로우 내 데이터 모델 (data-model-in-workflows.md)

### 8.1 GraphState 설계 원칙

- BookState, ChapterState 등 **타입 안전한 TypedDict**를 사용해 LangGraph State를 정의.[^35_10][^35_5]
- 각 노드는 **입력·출력 State 키**를 명시적으로 읽고 쓴다.


### 8.2 ChapterState 예시

```python
class ChapterState(TypedDict, total=False):
    chapter_id: str
    part_id: str
    book_id: str
    topic: str
    outline: dict
    research_notes: list  # list[dict]
    case_studies: list    # list[dict]
    draft_text: str
    eval_score: float
    eval_feedback: str
    iteration: int
```

노드 구현 시, **State를 가능한 한 불변처럼 다루고** 새 State를 리턴하는 패턴 유지.

***

## 9. Credentials \& Secrets (credentials-and-secrets.md)

### 9.1 LLM/RAG 자격증명 모델

```python
# /02_arch_execution/credentials_model.py

class LLMProviderCredentials(BaseModel):
    id: str
    provider: Literal["openrouter"]
    api_key: str  # 저장 시 암호화
    default_model: str = "gpt-4.1"

class VectorDBCredentials(BaseModel):
    id: str
    provider: Literal["qdrant", "pinecone"]
    api_url: str
    api_key: str
```

- API 키는 DB 저장 시 KMS/Vault로 암호화.
- 워크플로우/그래프 정의에서는 **자격 증명 ID만 참조**.

***

## 10. 실행 \& 로깅 (executions-and-logging.md)

### 10.1 실행 모델

```python
# /02_arch_execution/executions_model.py

class ExecutionStatus(str, Enum):
    pending = "pending"
    running = "running"
    succeeded = "succeeded"
    failed = "failed"

class Execution(BaseModel):
    id: str
    graph_type: Literal["book", "chapter", "eval"]
    state_snapshot: dict
    status: ExecutionStatus
    created_at: datetime
    finished_at: Optional[datetime] = None
```


### 10.2 로깅 \& Observability 연계

- 각 NodeRun 시 아래 구조의 JSON 로그 생성:

```json
{
  "run_id": "book_20250101",
  "node_id": "chapter_writer",
  "graph_type": "chapter",
  "timestamp_start": "...",
  "timestamp_end": "...",
  "latency_ms": 23890,
  "input_tokens": 4250,
  "output_tokens": 9800,
  "rag_docs_used": ["DOC_2024_AI_01_p12_c03"],
  "status": "success"
}
```


***

## 11. 디버깅 \& 데이터 핀닝 (debugging-and-data-pinning.md)

### 11.1 목적

- 개발·테스트 단계에서 **같은 입력 상태로 반복 테스트**하기 위한 도구.[^35_11][^35_12]
- 프로덕션에서는 **생성 실행에는 영향을 주지 않도록** 설계.


### 11.2 구현 스케치

```python
# /02_arch_execution/debug_pinning.py

import json
from pathlib import Path
from typing import Any, Dict

PIN_DIR = Path(".pins")

def pin_state(name: str, state: Dict[str, Any]) -> None:
    PIN_DIR.mkdir(exist_ok=True)
    (PIN_DIR / f"{name}.json").write_text(json.dumps(state, ensure_ascii=False, indent=2))

def load_pinned_state(name: str) -> Dict[str, Any]:
    return json.loads((PIN_DIR / f"{name}.json").read_text())
```

- 예: 실전 한 번 실행 후 BookState/ChapterState를 pin → 이후 개발 시 그 상태를 그대로 불러와 노드/그래프만 재실행.

***

## 12. LangChain + LangGraph 통합 (langchain-langgraph-integration.md)

### 12.1 역할 분리 원칙[^35_7][^35_10]

- LangChain: **LLM/Tool/Retriever 컴포넌트**
- LangGraph: **에이전트/워크플로우 런타임(StateGraph)**


### 12.2 통합 예시: RAG + Writer 노드

```python
# /02_arch_execution/langchain_integration.py

from langchain_core.runnables import RunnableParallel, RunnableLambda
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI, OpenAIEmbeddings

llm = ChatOpenAI(model="gpt-4.1")  # 실제로는 OpenRouter 래퍼 사용
embeddings = OpenAIEmbeddings(model="text-embedding-3-large")

def build_research_chain():
    prompt = ChatPromptTemplate.from_template(
        "Summarize key insights from the following context for chapter: {chapter_title}\n\n{context}"
    )
    chain = (
        {"context": RunnableLambda(retrieve_docs), "chapter_title": RunnableLambda(lambda state: state["title"])}
        | prompt
        | llm
    )
    return chain
```

LangGraph 노드에서:

```python
def research_node(state: ChapterState) -> ChapterState:
    chain = build_research_chain()
    summary = chain.invoke(state)
    state["research_notes"] = [{"type": "summary", "text": summary.content}]
    return state
```


***

## 13. Prompt-to-Graph 전략 (prompt-to-graph-strategy.md)

### 13.1 목적

- “설명(Describe) → 그래프 설계(Plan) → 그래프 코드(Scaffold)”로 가는 **PTG(프롬프트→그래프)** 자동화.[^35_13][^35_1]


### 13.2 품질 체크리스트[^35_14][^35_1]

- 루프/종료 조건 명시 여부.
- 에러 경로/예외 처리 노드 존재 여부.
- 자격 증명/보안 관련 노드 존재 여부.
- 비용 관점에서 불필요한 LLM 호출 루프 여부.


### 13.3 PTG용 프롬프트 예시

```text
[developer]
너는 LangGraph 기반 멀티에이전트 시스템 아키텍트이다.
입력 요구사항을 StateGraph와 노드/에지 정의로 설계한다.

[user]
다음 요구사항을 만족하는 "Chapter Graph"를 설계하고,
Python LangGraph 코드 스캐폴드를 생성해줘.

요구사항:
- State: ChapterState(TypedDict)
- Nodes: research, write, eval
- Flow: research -> write -> eval -> (score<0.8 && iter<3 -> research else END)
- Observability: run_id, node_id 기준 로그 출력
```


***

## 14. 아키텍처 \& 실행 엔진 체크리스트

- [ ] Book/Chapter/Eval 그래프 구조가 LangGraph StateGraph로 정의되어 있는가.
- [ ] 각 노드에 대해 입력/출력/옵션/에러 동작이 명시되어 있는가.
- [ ] GraphRun/NodeRun/Execution 모델이 정의되어 있고, 실행 로그가 JSON/Trace로 남는가.
- [ ] RAG/LLM 호출은 LangChain 컴포넌트로 캡슐화되고, LangGraph 노드에서는 이를 조합만 하는가.
- [ ] PTG(프롬프트→그래프) 파이프라인을 위한 프롬프트/체크리스트가 정의되어 있는가.

***

위 백서는 **디렉터리 2: Architecture \& Execution Engine**을 기준으로, 기획 단계에서 정의된 Product \& Domain Blueprint를 실제 **LangGraph 기반 실행 엔진 구조 + 코드 스캐폴드**로 연결하는 데 필요한 내용을 거의 전부 포함합니다.[^35_15][^35_2][^35_5]

다음 단계로는:

- 이 문서를 기준으로 `/02_arch_execution` 아래에 파일을 실제로 분할 생성하고,
- 필요한 부분(예: `chapter_graph.py` 전체 구현, RAG Retriever 실제 코드, OpenRouter 래퍼)만 채워 넣으면, 바로 **실행 가능한 BAAS 오케스트레이션 코어**를 구축할 수 있습니다.

<div align="center">⁂</div>

[^35_1]: https://github.com/langchain-ai/langgraph/issues/3365

[^35_2]: https://www.langchain.com/langgraph

[^35_3]: https://www.invent.ai/blog/key-components-of-agentic-ai-architecture-building-the-foundation

[^35_4]: https://dl.acm.org/doi/10.1145/3708359.3712164

[^35_5]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^35_6]: https://blog.langchain.com/langgraph-multi-agent-workflows/

[^35_7]: https://peliqan.io/blog/langchain-vs-langgraph/

[^35_8]: https://docs.n8n.io/workflows/

[^35_9]: https://docs.n8n.io/workflows/components/nodes/

[^35_10]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^35_11]: https://docs.n8n.io/data/data-pinning/

[^35_12]: https://docs.n8n.io/data/data-mocking/

[^35_13]: https://vibecoding.app/blog/how-vibe-coding-works

[^35_14]: https://github.com/langchain-ai/langgraph/discussions/2090

[^35_15]: https://www.swarnendu.de/blog/langgraph-best-practices/


---

# 지금까지 나눈 대화를 심층 분석하여 **Book-Authoring Agent System (BAAS)** 내용을 작성할 때 각 권 별로 백서 형태로 하나씩 문서를 생성합니다. 문서를 작성하기 전에 모든 내용을 "제 1 원칙 사고법"을 기준으로 하여 전 과정을 근본적인 본질에서 시작하여 요약본 형태가 아니라 모든 내용이 하나도 빠짐없이 필요한 모든 단계가 순차적으로 적용된 Full Stack 문서 형태로 작성합니다.

"디렉터리 3: LLM · RAG · Agentic Layer " 에 대한 내용을 실제 책 분량 수준으로 더 확장해서 각 권 별로 작성합니다. 이때 실 구현을 위한 코드·템플릿을 상세화하는 과정을 포함하여 모든 소스코드가 포함되도록 작성합니다.

단일 응답에 “책 분량 + 전체 소스코드”를 모두 담을 수는 없으므로, 디렉터리 3을 **한 권짜리 백서 구조 + 핵심 설계 + 대표 코드/템플릿 스캐폴드**까지 최대한 깊게 펼친 1차 버전으로 작성합니다. 이 문서를 기반으로 실제 레포에서 파일만 쪼개면 바로 BAAS의 LLM·RAG·Agent 레이어를 구현할 수 있습니다.[^36_1][^36_2][^36_3][^36_4]

아래는 “Guide 3 – LLM · RAG · Agentic Layer for BAAS”로 보는 단일 백서 구조입니다.

***

# Guide 3. LLM · RAG · Agentic Layer for BAAS

**Book-Authoring Agent System (BAAS) – LLM·RAG·에이전트 레이어 백서**

***

## 1. 제1원칙: BAAS에 필요한 “생각하는 레이어” 정의

### 1.1 본질적 질문

- “책 한 권을 AI가 쓰게 하려면, AI에게 어떤 **인지 능력**과 **정보 구조**를 줘야 하는가?”
- 최소 요구 능력:[^36_5][^36_6]
    - 주제·독자·톤을 이해하고 → 책 구조로 계획(Planning)
    - 필요한 정보를 찾아서(Research/RAG) → 정리·요약(Synthesis)
    - 전체 구조와 스타일을 유지하며 장문을 생성(Writing)
    - 자기 평가·비판·수정(Evaluation/Refinement)


### 1.2 LLM·RAG·Agentic의 역할 분리

- **LLM Layer**:
    - “생성/추론” 엔진. 모델 선택·토큰·비용·출력 안정성을 관리.
- **RAG Layer**:
    - 저자의 지식/외부 자료를 LLM이 사용할 수 있는 형태로 제공.
- **Agentic Layer(LangGraph)**:
    - 플래너·리서처·라이터·크리틱 등 역할을 가진 에이전트 팀이, 상태를 공유하며 협업하는 그래프.[^36_3][^36_7]

이 가이드는 이 세 레이어가 **BAAS에서 어떻게 상호작용하는지**를 모두 정의한다.

***

## 2. LLM Provider \& OpenRouter 전략 (llm-provider-strategy-openrouter.md)

### 2.1 왜 OpenRouter 기반인가

- 여러 모델을 상황별로 선택해 **비용·성능 최적화**.[^36_1]
- 공급자 락인 최소화, 지역 규제/모델 별 제약 회피.
- BAAS는 역할별로 **모델을 다르게 쓰는 설계**가 핵심이므로, 라우팅 유연성이 중요.


### 2.2 역할별 모델 매핑 규칙

PRD에서 정의한 역할–모델 매핑을 LLM 라우터 규칙으로 형식화:

```python
# /03_llm_rag_agents/llm_router.py

from typing import Literal, Dict, Any

AgentRole = Literal[
    "book_supervisor",
    "outline_planner",
    "research_agent",
    "case_study_agent",
    "chapter_writer",
    "structure_consistency_agent",
    "style_localization_agent",
    "auto_critic",
    "marketing_agent",
]

ROLE_MODEL_MAP: Dict[AgentRole, Dict[str, Any]] = {
    "book_supervisor": {"model": "gpt-4.1-mini", "temperature": 0.3},
    "outline_planner": {"model": "gpt-4.1", "temperature": 0.4},
    "research_agent": {"model": "gpt-4.1", "temperature": 0.2},
    "case_study_agent": {"model": "gpt-4.1", "temperature": 0.7},
    "chapter_writer": {"model": "gpt-4.1", "temperature": 0.5},
    "structure_consistency_agent": {"model": "gpt-4.1-mini", "temperature": 0.2},
    "style_localization_agent": {"model": "gpt-4.1", "temperature": 0.4},
    "auto_critic": {"model": "gpt-4.1-mini", "temperature": 0.1},
    "marketing_agent": {"model": "gpt-4.1", "temperature": 0.7},
}
```

환경별 기본/대체 모델:

```python
ENV_MODEL_DEFAULTS = {
    "dev": {
        "default": "gpt-4.1-mini",
        "fallback": "o3-mini",
    },
    "prod": {
        "default": "gpt-4.1",
        "fallback": "gpt-4.1-mini",
    },
}
```


### 2.3 OpenRouter 래퍼(공통 클라이언트)

```python
# /03_llm_rag_agents/openrouter_client.py

import os
from typing import Dict, Any
import httpx

OPENROUTER_API_KEY = os.environ["OPENROUTER_API_KEY"]
OPENROUTER_BASE_URL = os.getenv("OPENROUTER_BASE_URL", "https://openrouter.ai/api/v1")

class OpenRouterClient:
    def __init__(self, agent_role: str, env: str = "prod"):
        from .llm_router import ROLE_MODEL_MAP, ENV_MODEL_DEFAULTS
        self.agent_role = agent_role
        self.env = env
        self.model_config = ROLE_MODEL_MAP[agent_role]
        self.default_model = ENV_MODEL_DEFAULTS[env]["default"]

    async def chat(self, messages: list[dict], **overrides: Any) -> Dict[str, Any]:
        payload = {
            "model": overrides.get("model") or self.model_config["model"] or self.default_model,
            "messages": messages,
            "temperature": overrides.get("temperature", self.model_config.get("temperature", 0.3)),
        }
        headers = {
            "Authorization": f"Bearer {OPENROUTER_API_KEY}",
            "Content-Type": "application/json",
        }
        async with httpx.AsyncClient(timeout=60) as client:
            resp = await client.post(f"{OPENROUTER_BASE_URL}/chat/completions",
                                     json=payload, headers=headers)
            resp.raise_for_status()
            return resp.json()
```


***

## 3. LLM Layer Architecture (llm-layer-architecture.md)

### 3.1 공통 호출 레이어 설계

- 책임:[^36_2]
    - Role → 모델/파라미터 매핑
    - 호출 로깅(run_id, node_id, tokens, latency)
    - 실패·재시도·백오프
    - 출력 형식(JSON 구조화/파싱)

```python
# /03_llm_rag_agents/llm_layer.py

from typing import Any, Dict, List
from time import perf_counter
from .openrouter_client import OpenRouterClient
from ..observability.logger import log_llm_call  # /04_delivery_stack에서 실제 구현

async def llm_call(
    agent_role: str,
    messages: List[Dict[str, str]],
    run_id: str,
    node_id: str,
    **overrides: Any,
) -> Dict[str, Any]:
    client = OpenRouterClient(agent_role)
    t0 = perf_counter()
    try:
        resp = await client.chat(messages, **overrides)
        t1 = perf_counter()
        usage = resp.get("usage", {})
        log_llm_call(
            run_id=run_id,
            node_id=node_id,
            model=resp.get("model", ""),
            latency_ms=int((t1 - t0) * 1000),
            input_tokens=usage.get("prompt_tokens", 0),
            output_tokens=usage.get("completion_tokens", 0),
            status="success",
        )
        return resp
    except Exception as e:
        t1 = perf_counter()
        log_llm_call(
            run_id=run_id,
            node_id=node_id,
            model="unknown",
            latency_ms=int((t1 - t0) * 1000),
            input_tokens=0,
            output_tokens=0,
            status="error",
            error=str(e),
        )
        raise
```


***

## 4. 프롬프트 아키텍처 \& Role 체계 (prompt-roles-and-instruction-hierarchy.md)

### 4.1 5가지 역할의 원칙[^36_8][^36_9][^36_10]

- **developer**: BAAS 전역 행동 규칙·보안·톤·출력 형식 등 “헌법” 수준 규칙.
- **system**: 현재 책/챕터 상태·컨텍스트·RAG 요약·실행 맥락.
- **user**: 저자/운영자가 내리는 지시(“이 챕터를 이렇게 써줘”).
- **assistant**: 모델의 응답(초안·리뷰·코드 등).
- **tool**: RAG/툴 호출 결과를 구조화된 JSON으로 전달.[^36_11]


### 4.2 developer 프롬프트 예시

```python
DEVELOPER_PROMPT = """
You are an AI agent working inside the Book-Authoring Agent System (BAAS).
You ALWAYS follow these rules:
1) Preserve the author's perspective, domain expertise, and tone.
2) Prefer structured outputs (JSON, Markdown with headings) whenever possible.
3) Never fabricate hard facts when RAG says context is insufficient; explicitly say so.
4) For Korean content, write in clear, professional Korean suitable for a published business book.
"""
```


### 4.3 system 컨텍스트 템플릿

```python
def build_system_context(book_meta: dict, chapter_meta: dict, rag_summary: str | None) -> str:
    return f"""
[BOOK METADATA]
Title: {book_meta['title']}
Audience: {book_meta['audience']}
Tone: {book_meta['tone']}

[CHAPTER METADATA]
Title: {chapter_meta['title']}
Purpose: {chapter_meta['purpose']}
Order: {chapter_meta['order']}

[RAG SUMMARY]
{rag_summary or '(No RAG context available or relevant.)'}
"""
```


***

## 5. Prompt Templates \& Patterns (prompt-templates-and-patterns.md)

### 5.1 챕터 작성 프롬프트 패턴

```python
def build_chapter_writer_messages(
    book_meta: dict,
    chapter_meta: dict,
    outline: dict,
    research_notes: list[dict],
    rag_citations: list[str],
) -> list[dict]:
    system_msg = {
        "role": "system",
        "content": build_system_context(book_meta, chapter_meta, rag_summary="\n\n".join(
            n["text"] for n in research_notes
        )),
    }
    user_msg = {
        "role": "user",
        "content": f"""
아래 정보를 바탕으로 이 챕터의 초안을 작성해줘.

[요구사항]
- 제목과 소제목을 명확히 구조화할 것
- 사례와 인사이트를 적절히 섞되, 과장하지 말 것
- 마케팅 문구가 아니라, 전략 컨설팅 리포트 스타일에 가깝게

[출력 형식]
- Markdown
- H2: 챕터 제목 (이미 정해져 있으면 재사용)
- H3: 주요 섹션 제목
- 필요한 경우 Bullet/Numbered list 사용

[Outline JSON]
{outline}

[RAG 문맥 출처 ID]
{rag_citations}
""",
    }
    return [
        {"role": "system", "content": DEVELOPER_PROMPT},
        system_msg,
        user_msg,
    ]
```

이 패턴을 Planner/Research/CaseStudy/AutoCritic 등에 각각 정의한다.

***

## 6. Prompt Library 구조 (prompt-library-structure.md)

```text
/03_llm_rag_agents/prompts/
  developer/
    global_rules.md
    safety_policies.md
  system/
    book_context.md
    chapter_context.md
  user/
    plan_book.md
    write_chapter.md
    evaluate_chapter.md
  tool/
    rag_result_format.md
    eval_result_format.md
```

각 파일에는 “프롬프트 텍스트 + 사용 예시 + 버전 메타데이터”를 포함.

```yaml
# /03_llm_rag_agents/prompts/metadata.yml
prompts:
  - id: "write_chapter_v1"
    path: "user/write_chapter.md"
    purpose: "Full chapter draft for strategic business books"
    version: "1.0.0"
    created_at: "2025-01-01"
```


***

## 7. 멀티에이전트 아키텍처 (multi-agent-architecture.md)

### 7.1 BAAS 에이전트 팀 구조[^36_12][^36_3]

- **Book Supervisor**: 전체 플로우 관리, 실패 시 재계획.
- **Outline Planner**: BookState 기반 Part/Chapter 구조 설계.
- **Research Agent**: Part/Chapter별 RAG 검색 + 요약.
- **Case Study Agent**: 사례 생성(실제/가상) 및 구조화.
- **Chapter Writer**: 장문 초안 생성.
- **Structure Consistency Agent**: 구조 통일·중복 검출.
- **Style Localization Agent**: 문체·톤 통일.
- **Auto Critic**: 품질 평가·점수·개선안 제시.
- **Marketing Agent**: 제목·카피·블럽 생성.


### 7.2 GraphState 설계 (예: BookState, ChapterState)

```python
# /03_llm_rag_agents/states.py

from typing import TypedDict, List, Optional

class BookState(TypedDict, total=False):
    book_id: str
    topic: str
    audience: str
    tone: str
    outline: dict
    parts: List[dict]
    chapters: List[dict]
    errors: List[str]

class ChapterState(TypedDict, total=False):
    chapter_id: str
    book_id: str
    part_id: Optional[str]
    title: str
    purpose: str
    outline: dict
    research_notes: List[dict]
    case_studies: List[dict]
    draft_text: str
    eval_score: float
    eval_feedback: str
    iteration: int
    errors: List[str]
```


***

## 8. Agent Patterns \& Best Practices (agent-patterns-and-best-practices.md)

### 8.1 Supervisor/Worker 패턴[^36_13][^36_12]

- Supervisor:
    - Book 전체 상태 관점에서 “어떤 챕터를 언제 생성/재생성할지” 결정.
- Worker:
    - Chapter Graph를 실행해 한 챕터에 집중.


### 8.2 Reflection 패턴

- Chapter Writer → Auto Critic → (점수 < threshold) → 재작성 루프.
- GraphRecursionError 방지를 위해 iteration/step 수 제한.[^36_12]

```python
def eval_node(state: ChapterState) -> ChapterState:
    # ... Auto Critic 호출, eval_score 업데이트
    if state["eval_score"] < 0.8:
        state["iteration"] = state.get("iteration", 0) + 1
    return state

def route_on_eval(state: ChapterState) -> str:
    if state["eval_score"] >= 0.8:
        return "finalize"
    if state.get("iteration", 0) >= 3:
        state.setdefault("errors", []).append("Max iterations reached")
        return "finalize"
    return "research"
```


***

## 9. 데이터 \& RAG 인프라 (data-rag-infra.md)

### 9.1 벡터 스키마 설계[^36_14][^36_2]

```python
# /03_llm_rag_agents/rag/schema.py

from pydantic import BaseModel
from typing import List, Literal, Dict, Any

Level = Literal["concept", "framework", "case", "data"]

class ChunkMetadata(BaseModel):
    source: str           # filename or URL
    page: int
    section: str
    topics: List[str]
    level: Level
    part_candidates: List[int]
    language: str = "ko"
    created_at: str
```


### 9.2 Qdrant/Pinecone 컬렉션 설계

- 컬렉션: `baas_author_{workspace_id}`
- 벡터: 임베딩(text-embedding-3-large)
- 페이로드: `ChunkMetadata.dict()`.


### 9.3 Chunking \& 인덱싱 파이프라인

```python
# /03_llm_rag_agents/rag/ingest_pdf.py

import pdfplumber
from datetime import datetime
from .schema import ChunkMetadata
from .vector_store import VectorStore

def ingest_pdf(path: str, part_candidates: list[int], topics: list[str]) -> None:
    chunks = []
    with pdfplumber.open(path) as pdf:
        for page_num, page in enumerate(pdf.pages, start=1):
            text = page.extract_text() or ""
            # 간단히 문단 단위 → 토큰 기준 chunking은 실제 구현에서 추가
            for paragraph in text.split("\n\n"):
                if not paragraph.strip():
                    continue
                meta = ChunkMetadata(
                    source=path,
                    page=page_num,
                    section="",
                    topics=topics,
                    level="concept",
                    part_candidates=part_candidates,
                    created_at=datetime.utcnow().isoformat(),
                )
                chunks.append((paragraph, meta))
    vs = VectorStore()  # 벡터 DB 클라이언트
    vs.add_documents(chunks)
```


***

## 10. RAGStore 인터페이스 \& 구현 (relevance-checker-module.md 포함)

### 10.1 RAGStore 인터페이스

```python
# /03_llm_rag_agents/rag/store.py

from typing import List, Dict, Any, Tuple
from .schema import ChunkMetadata

class RAGStore:
    def search(self, query: str, filters: Dict[str, Any], k: int) -> List[Tuple[str, ChunkMetadata]]:
        raise NotImplementedError

    def add_documents(self, docs: List[Tuple[str, ChunkMetadata]]) -> None:
        raise NotImplementedError

    def reindex(self, new_docs: List[Tuple[str, ChunkMetadata]]) -> None:
        raise NotImplementedError
```


### 10.2 Relevance Checker Runnable[^36_4]

```python
# /03_llm_rag_agents/rag/relevance_checker.py

from typing import Dict, Any
from ..llm_layer import llm_call

RELEVANCE_SYSTEM_PROMPT = """
You are a relevance checker for a book-writing RAG system.
Given a question and a context, decide if the context is truly useful.
Return JSON: {"is_relevant": bool, "score": float, "rationale": "..." }.
"""

async def check_relevance(question: str, context: str, run_id: str, node_id: str) -> Dict[str, Any]:
    messages = [
        {"role": "system", "content": RELEVANCE_SYSTEM_PROMPT},
        {"role": "user", "content": f"Question:\n{question}\n\nContext:\n{context}"},
    ]
    resp = await llm_call(
        agent_role="auto_critic",
        messages=messages,
        run_id=run_id,
        node_id=node_id,
        temperature=0.0,
    )
    content = resp["choices"][^36_0]["message"]["content"]
    # JSON 파싱 로직 필요(try/except + fallback)
    import json
    return json.loads(content)
```


### 10.3 LangGraph에서의 RAG + Relevance 라우팅[^36_12]

```python
# /03_llm_rag_agents/rag/graph_nodes.py

from .store import RAGStore
from .relevance_checker import check_relevance
from ..states import ChapterState

async def retrieve_with_relevance(state: ChapterState, run_id: str, node_id: str) -> ChapterState:
    question = f"{state['title']} - {state['purpose']}"
    filters = {"part_candidates": [state["part_id"]]} if state.get("part_id") else {}
    store = RAGStore()
    candidates = store.search(question, filters=filters, k=10)

    relevant_notes = []
    citations = []
    for text, meta in candidates:
        res = await check_relevance(question, text, run_id, node_id)
        if res["is_relevant"] and res["score"] >= 0.6:
            relevant_notes.append({"text": text, "meta": meta.dict(), "relevance": res})
            citations.append(f"{meta.source}_p{meta.page}")

    state["research_notes"] = relevant_notes
    state["rag_citations"] = citations
    return state
```


***

## 11. RAG + Agent 통합 패턴 (rag-agent-integration-patterns.md)

### 11.1 표준 패턴

- Retrieval → Relevance → Summarization → Planning/Generation.[^36_2][^36_14]
- BAAS에서는 **Chapter Graph**에서 다음 구조 사용:
    - `research` 노드: RAG + Relevance + note 생성
    - `write` 노드: research_notes·outline 기반 초안
    - `eval` 노드: Auto Critic + 점수·피드백
    - 루프/종료: iteration/score 기준.


### 11.2 품질 평가 루프

- 각 실행에서 **question-context-answer-eval** 4요소를 구조화해 저장.[^36_10]
- 이후:
    - Recall/Precision 기반 통계
    - 프롬프트/임계값 튜닝
    - 지식 인덱스 보강.

```python
# /03_llm_rag_agents/eval/log_schema.py

class RAGEvalRecord(BaseModel):
    id: str
    question: str
    context_snippets: List[str]
    answer: str
    eval_score: float
    eval_feedback: str
    created_at: datetime
```


***

## 12. 체크리스트 – LLM · RAG · Agentic Layer

- [ ] 역할별 모델 매핑·OpenRouter 구성·공통 LLM 레이어가 구현되어 있는가.[^36_1]
- [ ] developer/system/user/assistant/tool 역할 프롬프트 아키텍처와 템플릿이 명시되어 있는가.[^36_9][^36_8]
- [ ] 모든 주요 에이전트(Book Supervisor, Outline Planner, Research/Case/Writer/Style/Auto Critic)가 역할/입출력/프롬프트를 갖고 있는가.[^36_15][^36_3]
- [ ] RAG 파이프라인(PDF→청크→임베딩→벡터DB→검색→관련성체커)이 구현되어 있는가.[^36_4][^36_2]
- [ ] Relevance Checker 모듈이 LangChain Runnable/노드로 존재하며, LangGraph 라우팅에 통합되어 있는가.[^36_4][^36_12]
- [ ] RAG + Agent 통합 패턴에서 품질 평가 루프(질문·문맥·응답·평가)가 데이터로 축적되고 있는가.[^36_10]

***

이 백서는 디렉터리 3: **LLM · RAG · Agentic Layer**를 기준으로, BAAS의 “생각하는 레이어”를 **역할 정의 → 모델 라우팅 → 프롬프트 구조 → RAG 인프라 → Relevance Checker → LangGraph 통합**까지 끊김 없이 연결할 수 있도록 구성했습니다.[^36_3][^36_2][^36_1][^36_4]

레포에서 실제로 구현할 때는, 이 문서의 코드 블록을 다음 경로들로 분할하면 됩니다:

- `/03_llm_rag_agents/llm_router.py`
- `/03_llm_rag_agents/openrouter_client.py`
- `/03_llm_rag_agents/llm_layer.py`
- `/03_llm_rag_agents/states.py`
- `/03_llm_rag_agents/prompts/...`
- `/03_llm_rag_agents/rag/schema.py`, `store.py`, `ingest_pdf.py`, `relevance_checker.py`, `graph_nodes.py`
- `/03_llm_rag_agents/eval/log_schema.py`

원하시면 다음 턴에서, 특정 부분(예: **멀티에이전트 설계 전체 코드** 또는 **RAG 인덱싱/검색 모듈 전체 코드**)만 골라 훨씬 더 디테일한 “실행 가능한 코드 전체”를 이어서 작성할 수 있습니다.

<div align="center">⁂</div>

[^36_1]: https://peliqan.io/blog/langchain-vs-langgraph/

[^36_2]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^36_3]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^36_4]: https://wikidocs.net/267810

[^36_5]: https://vectorize.io/blog/designing-agentic-ai-systems-part-1-agent-architectures

[^36_6]: https://www.invent.ai/blog/key-components-of-agentic-ai-architecture-building-the-foundation

[^36_7]: https://blog.langchain.com/langgraph-multi-agent-workflows/

[^36_8]: https://learning.sap.com/courses/navigating-large-language-models-fundamentals-and-techniques-for-your-use-case/leveraging-system-user-and-assistant-roles-for-better-prompts

[^36_9]: https://practiqai.com/blog/system-prompts-roles-instruction-hierarchy

[^36_10]: https://www.clarifai.com/blog/agentic-prompt-engineering

[^36_11]: https://docs.nvidia.com/nim/large-language-models/latest/system-example.html

[^36_12]: https://www.swarnendu.de/blog/langgraph-best-practices/

[^36_13]: https://blog.langchain.com/building-langgraph/

[^36_14]: https://www.siddharthbharath.com/build-deep-research-agent-langgraph/

[^36_15]: https://www.codersarts.com/post/a-complete-guide-to-creating-a-multi-agent-book-writing-system-part-3


---

# 지금까지 나눈 대화를 심층 분석하여 **Book-Authoring Agent System (BAAS)** 내용을 작성할 때 각 권 별로 백서 형태로 하나씩 문서를 생성합니다. 문서를 작성하기 전에 모든 내용을 "제 1 원칙 사고법"을 기준으로 하여 전 과정을 근본적인 본질에서 시작하여 요약본 형태가 아니라 모든 내용이 하나도 빠짐없이 필요한 모든 단계가 순차적으로 적용된 Full Stack 문서 형태로 작성합니다.

"디렉터리 4: Delivery Stack (Backend · Frontend · DevOps)  " 에 대한 내용을 실제 책 분량 수준으로 더 확장해서 각 권 별로 작성합니다. 이때 실 구현을 위한 코드·템플릿을 상세화하는 과정을 포함하여 모든 소스코드가 포함되도록 작성합니다.

단일 응답에 “책 분량 + 전체 소스코드”를 모두 담을 수는 없어서, 디렉터리 4를 **한 권짜리 백서 구조 + 핵심 설계 + 대표 코드/템플릿 스캐폴드** 수준까지 최대한 깊게 풀어내겠습니다. 이 문서 하나로 BAAS의 Backend · Frontend · DevOps 뼈대를 그대로 구현할 수 있게 만드는 것이 목표입니다.[^37_1][^37_2][^37_3]

아래는 “Guide 4 – Delivery Stack (Backend · Frontend · DevOps) for BAAS”의 구조입니다.

***

# Guide 4. Delivery Stack (Backend · Frontend · DevOps) for BAAS

**Book-Authoring Agent System (BAAS) – 전달 계층 \& 운영 백서**

***

## 1. 제1원칙: BAAS Delivery Stack의 역할

### 1.1 본질적 질문

- BAAS의 “생각하는 레이어(LLM·RAG·Agentic)”는 이미 설계되었다.
- 이제 필요한 것은, 이 능력이 **실제 사용자(저자)가 클릭 한 번으로 사용할 수 있는 서비스**가 되는 경로이다.[^37_4][^37_5]

이 경로는 세 층으로 분해된다:

1) **Backend Layer**:
    - BAAS API, LangGraph 실행 엔드포인트, RAG 인덱싱 배치, 관찰성 훅.
2) **Frontend Layer**:
    - 저자가 프로젝트를 만들고, 책 구조를 보고, 챕터 상태를 모니터링하고, 결과를 편집·Export하는 UI.[^37_2][^37_6]
3) **DevOps Layer**:
    - 코드 → 빌드 → 테스트 → 배포 → 모니터링 → 스케일링까지 자동화하는 운영 인프라.[^37_3][^37_1]

***

## 2. Monorepo 개요

### 2.1 디렉터리 구조 설계

```text
baas/
  apps/
    web/           # Next.js PWA
    api/           # FastAPI + LangGraph
    worker/        # 배치 작업, RAG 인덱싱, 장기 그래프 실행
  packages/
    core/          # 도메인 모델, 공통 타입, 유틸
    llm_rag/       # Guide 3 코드 (LLM·RAG·Agent)
    workflows/     # LangGraph 그래프 정의
    ui/            # React/shadcn 컴포넌트 라이브러리
  infra/
    terraform/     # IaC (옵션)
    k8s/           # 배포 매니페스트 (옵션)
  docs/
    01_product_domain/
    02_arch_execution/
    03_llm_rag_agents/
    04_delivery_stack/
    05_ux_interaction_ops/
```

- `apps/api` 는 BAAS의 **싱글 백엔드 진입점**이다.[^37_1]
- `packages/workflows` 안에 LangGraph 그래프(Book/Chapter/Eval)를 모듈화한다.[^37_7]

***

## 3. Backend – FastAPI \& LangGraph (fastapi-architecture.md, langgraph-backend-integration.md)

### 3.1 FastAPI 프로젝트 구조

```text
apps/api/
  app/
    main.py
    deps.py
    config.py
    routes/
      books.py
      chapters.py
      graphs.py
      exports.py
    services/
      books_service.py
      chapters_service.py
      graphs_service.py
    repositories/
      books_repo.py
      chapters_repo.py
      executions_repo.py
    models/
      domain_models.py
      db_models.py
    workflows/
      book_graph_adapter.py
      chapter_graph_adapter.py
  tests/
```


### 3.2 설정 \& DI

```python
# apps/api/app/config.py
from pydantic import BaseSettings

class Settings(BaseSettings):
    env: str = "dev"
    db_url: str
    supabase_url: str
    supabase_key: str
    vector_db_url: str
    vector_db_key: str
    openrouter_api_key: str

    class Config:
        env_file = ".env"

settings = Settings()
```

```python
# apps/api/app/deps.py
from fastapi import Depends
from .config import settings
from packages.llm_rag.rag.store import RAGStore
from packages.workflows.book_graph import book_graph
from packages.workflows.chapter_graph import chapter_graph

def get_settings():
    return settings

def get_rag_store():
    return RAGStore(settings.vector_db_url, settings.vector_db_key)

def get_book_graph():
    return book_graph

def get_chapter_graph():
    return chapter_graph
```


### 3.3 Graph 실행 API 설계

#### 3.3.1 Book Graph 실행 API

```python
# apps/api/app/routes/graphs.py
from fastapi import APIRouter, Depends
from pydantic import BaseModel
from datetime import datetime
from packages.workflows.book_graph import BookState
from ..deps import get_book_graph
from ..repositories.executions_repo import ExecutionsRepo

router = APIRouter(prefix="/graphs", tags=["graphs"])

class BookGraphInput(BaseModel):
    book_id: str
    topic: str
    audience: str
    tone: str

class BookGraphResponse(BaseModel):
    graph_run_id: str
    status: str
    outline: dict

@router.post("/book/run", response_model=BookGraphResponse)
async def run_book_graph(
    payload: BookGraphInput,
    book_graph = Depends(get_book_graph),
    executions_repo: ExecutionsRepo = Depends(ExecutionsRepo),
):
    state: BookState = {
        "book_id": payload.book_id,
        "topic": payload.topic,
        "audience": payload.audience,
        "tone": payload.tone,
    }
    run_id = executions_repo.create_run(
        graph_type="book",
        initial_state=state,
        started_at=datetime.utcnow(),
    )

    # LangGraph 실행 (동기 예시)
    final_state = book_graph.invoke(state)

    executions_repo.finish_run(run_id, final_state)

    return BookGraphResponse(
        graph_run_id=run_id,
        status="succeeded",
        outline=final_state["outline"],
    )
```


#### 3.3.2 Chapter Graph 실행 API

```python
@router.post("/chapter/run")
async def run_chapter_graph(
    payload: ChapterGraphInput,
    chapter_graph = Depends(get_chapter_graph),
    executions_repo: ExecutionsRepo = Depends(ExecutionsRepo),
):
    state: ChapterState = {
        "chapter_id": payload.chapter_id,
        "book_id": payload.book_id,
        "title": payload.title,
        "purpose": payload.purpose,
        "outline": payload.outline,
        "iteration": 0,
    }
    run_id = executions_repo.create_run(...)
    final_state = chapter_graph.invoke(state)
    executions_repo.finish_run(run_id, final_state)
    return final_state
```


### 3.4 External Integrations (external-integrations.md)

여기서는 핵심만 스캐폴드로 제시합니다.

- ESP: **책 완성 시 자동 이메일 발송** (저자에게 알림, PDF 링크).
- Slack: 주요 에이전트 이벤트 슬랙 알림(폭주, 실패, 비용 초과).
- Stripe: BAAS를 서비스화할 경우 요금제·결제와 연계.

```python
# apps/api/app/services/notifications_service.py
from .esp_client import send_email

def notify_book_completed(author_email: str, book_title: str, download_url: str):
    subject = f"[BAAS] '{book_title}' 원고가 준비되었습니다."
    body = f"""
안녕하세요,

요청하신 '{book_title}'의 원고가 생성되었습니다.
아래 링크에서 확인하실 수 있습니다.

{download_url}

감사합니다.
"""
    send_email(to=author_email, subject=subject, body=body)
```


***

## 4. Frontend – Next.js PWA (nextjs-architecture.md, state-and-data-fetching.md, workflow-editor-ui.md)

### 4.1 Next.js 프로젝트 구조

```text
apps/web/
  app/
    layout.tsx
    page.tsx               # 홈/대시보드
    workspaces/
      [workspaceId]/
        layout.tsx
        page.tsx           # 프로젝트 리스트
        projects/
          [projectId]/
            page.tsx       # 책 리스트
            books/
              [bookId]/
                page.tsx   # Book Overview
                chapters/
                  [chapterId]/
                    page.tsx   # Chapter Workspace
                exports/
                  page.tsx
  components/
    layout/
    book/
    chapter/
    common/
  lib/
    api-client.ts
    routes.ts
    query-client.ts
```


### 4.2 데이터 패칭 – RSC + TanStack Query

```ts
// apps/web/app/workspaces/[workspaceId]/projects/[projectId]/books/[bookId]/page.tsx
import { fetchBookDetail } from "@/lib/api-client";
import BookOverview from "@/components/book/BookOverview";

export default async function BookPage({ params }: { params: { workspaceId: string; projectId: string; bookId: string }}) {
  const book = await fetchBookDetail(params.bookId);
  return <BookOverview book={book} />;
}
```

```ts
// apps/web/lib/api-client.ts
export async function fetchBookDetail(bookId: string) {
  const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/books/${bookId}`, {
    cache: "no-store",
  });
  if (!res.ok) throw new Error("Failed to fetch book");
  return res.json();
}
```

Chapter Workspace는 클라이언트 컴포넌트 + TanStack Query를 사용해 **그래프 실행 상태를 폴링/스트리밍**.[^37_2]

***

### 4.3 Workflow Editor UI 스캐폴드

```tsx
// apps/web/components/chapter/ChapterWorkspace.tsx
"use client";

import { useQuery, useMutation } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { ChapterGraphTimeline } from "./ChapterGraphTimeline";
import { ChapterDraftViewer } from "./ChapterDraftViewer";
import { runChapterGraph } from "@/lib/api-client";

type Props = {
  chapterId: string;
  bookId: string;
};

export function ChapterWorkspace({ chapterId, bookId }: Props) {
  const { data: execution, refetch } = useQuery({
    queryKey: ["chapter-execution", chapterId],
    queryFn: () => fetchChapterExecution(chapterId),
    refetchInterval: 5000,
  });

  const mutation = useMutation({
    mutationFn: () => runChapterGraph({ chapterId, bookId }),
    onSuccess: () => refetch(),
  });

  return (
    <div className="flex h-full">
      <div className="flex-1 border-r">
        <ChapterGraphTimeline execution={execution} />
      </div>
      <div className="flex-1 flex flex-col">
        <div className="p-2 border-b flex justify-between items-center">
          <h2 className="font-semibold">Chapter Draft</h2>
          <Button onClick={() => mutation.mutate()} disabled={mutation.isPending}>
            {mutation.isPending ? "Running..." : "Run Chapter Graph"}
          </Button>
        </div>
        <div className="flex-1 overflow-auto">
          <ChapterDraftViewer execution={execution} />
        </div>
      </div>
    </div>
  );
}
```

- `ChapterGraphTimeline` 컴포넌트는 NodeRun 리스트를 타임라인/단계 진행 바 형태로 렌더링.
- `ChapterDraftViewer`는 마지막 상태의 `draft_text`를 Markdown 렌더링.

***

## 5. DevOps – Monorepo, CI/CD, 배포 \& 비용 최적화 (monorepo-structure-and-env.md, ci-cd-pipelines.md, deployment-and-cost-optimization.md)

### 5.1 환경변수 \& Secret 관리

```text
.env.development
.env.staging
.env.production
```

예:

```bash
# apps/api/.env
ENV=dev
DB_URL=postgres://...
SUPABASE_URL=...
SUPABASE_KEY=...
VECTOR_DB_URL=...
VECTOR_DB_KEY=...
OPENROUTER_API_KEY=...
```

CI에서는 `.env` 대신 **GitHub Actions Secrets / Vault** 참조.

***

### 5.2 CI/CD 파이프라인 스캐폴드 (GitHub Actions 예)[^37_3][^37_1]

```yaml
# .github/workflows/ci-cd.yml
name: CI-CD

on:
  push:
    branches: [main]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        ports: ["5432:5432"]
        env:
          POSTGRES_PASSWORD: postgres
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install backend deps
        run: |
          pip install -r apps/api/requirements.txt
      - name: Run backend tests
        run: |
          cd apps/api && pytest

      - uses: actions/setup-node@v4
        with:
          node-version: "20"
      - name: Install frontend deps
        run: |
          cd apps/web && npm ci
      - name: Run frontend tests
        run: |
          cd apps/web && npm test

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      # 빌드 & 컨테이너 이미지 push (예: ghcr.io, ECR)
      # 이후 infra/k8s 또는 Cloud Run, Vercel CLI 사용해 배포
```


***

### 5.3 배포 전략 \& 비용 최적화

- **API/Worker**: Cloud Run / ECS / K8s 중 선택.
- **Web**: Vercel / Static Export.
- LLM 비용 줄이기:
    - Dev 환경: gpt-4.1-mini / o3-mini 사용.
    - RAG로 컨텍스트 최소화, 요약 체인 삽입.
    - AgentEval/AutoCritic도 “샘플 실행만 평가” 전략.[^37_8][^37_9]

***

## 6. End-to-End 요청 플로우 예시

1) 저자가 Web UI에서 “새 책 생성 → 아웃라인 생성” 클릭.
2) Web → API `/graphs/book/run` 호출.
3) FastAPI에서 BookState 생성 → LangGraph Book Graph 실행 → Outline 생성.
4) 결과는 DB에 저장, UI에서 Book Overview에 렌더링.
5) 저자가 특정 챕터를 선택하고 “Run Chapter Graph” 클릭.
6) Web → API `/graphs/chapter/run` → Chapter Graph 실행 → RAG/Writer/Eval 루프.
7) 실행 상태는 Executions/NodeRuns 테이블에서 폴링 → Timeline \& Draft 뷰에 시각화.
8) 최종 통합 후 Export API 호출 → MD/DOCX/PDF/JSON 생성 → 다운로드 링크 제공.

이 플로우에서:

- **디렉터리 2·3의 그래프/에이전트/LLM·RAG 레이어**는 이미 작성한 코드와 연결되고,
- **디렉터리 4의 Backend/Frontend/DevOps**가 그 레이어를 실제 사용자와 연결해 준다.[^37_10][^37_11]

***

## 7. Delivery Stack 체크리스트

- [ ] FastAPI 백엔드가 Book/Chapter/Graph/Export API를 제공하는가.
- [ ] LangGraph 그래프(Book/Chapter/Eval)가 API에 통합되어 있는가.
- [ ] Next.js Web UI에서 프로젝트/책/챕터/실행/Export를 전부 다룰 수 있는가.
- [ ] CI/CD 파이프라인이 테스트→빌드→배포까지 자동화되어 있는가.[^37_1][^37_3]
- [ ] 비용·성능·장애를 관측할 수 있는 모니터링과 알람이 설정되어 있는가.

***

이 백서는 디렉터리 4: **Delivery Stack (Backend · Frontend · DevOps)**를 기준으로, BAAS의 “생각하는 코어”를 실제 저자가 사용할 수 있는 SaaS/내부 도구로 만들기 위한 풀스택 구조와 코드 스캐폴드를 포함합니다.[^37_2][^37_3][^37_1]

다음 단계로는:

- `apps/api`와 `apps/web`, `packages/workflows` 레포를 실제로 초기화하고,
- 여기 포함된 코드 블록을 그대로 옮겨 스켈레톤을 만든 뒤,
- 세부 구현(에러 처리, 인증, UI 디테일, 실제 배포 스크립트)을 채워 넣으면 됩니다.

<div align="center">⁂</div>

[^37_1]: https://forum.cursor.com/t/best-practices-for-structuring-a-next-js-fastapi-supabase-project/49706

[^37_2]: https://www.pronextjs.dev/workshops/next-js-react-server-component-rsc-architecture-jbvxk/understanding-the-example-monorepo-structure-4gpny

[^37_3]: https://github.com/belgattitude/nextjs-monorepo-example/blob/main/README.md

[^37_4]: https://github.com/cpjet64/vibecoding/blob/main/system-architecture-guide.md

[^37_5]: https://docs.vibe-coding-framework.com/documentation-standards

[^37_6]: https://cloud.google.com/discover/what-is-vibe-coding

[^37_7]: https://www.langchain.com/langgraph

[^37_8]: https://peliqan.io/blog/langchain-vs-langgraph/

[^37_9]: https://www.evidentlyai.com/blog/llm-applications

[^37_10]: https://blog.langchain.com/langgraph-multi-agent-workflows/

[^37_11]: https://github.com/langchain-ai/langgraph/issues/3365


---

# 지금까지 나눈 대화를 심층 분석하여 **Book-Authoring Agent System (BAAS)** 내용을 작성할 때 각 권 별로 백서 형태로 하나씩 문서를 생성합니다. 문서를 작성하기 전에 모든 내용을 "제 1 원칙 사고법"을 기준으로 하여 전 과정을 근본적인 본질에서 시작하여 요약본 형태가 아니라 모든 내용이 하나도 빠짐없이 필요한 모든 단계가 순차적으로 적용된 Full Stack 문서 형태로 작성합니다.

"디렉터리 5: UX · Interaction · Ops Runbook" 에 대한 내용을 실제 책 분량 수준으로 더 확장해서 각 권 별로 작성합니다. 이때 실 구현을 위한 코드·템플릿을 상세화하는 과정을 포함하여 모든 소스코드가 포함되도록 작성합니다.

디렉터리 5는 BAAS를 “실제 사람이 매일 쓰는 서비스”로 만들기 위한 **UX / 상호작용 / 관찰성 / 운영 Runbook**의 풀스택 레이어입니다. 아래는 한 권짜리 백서 수준으로 설계한 “Guide 5 – UX · Interaction · Ops Runbook for BAAS”의 구조와 핵심 내용·코드 스캐폴드입니다.[^38_1][^38_2][^38_3]

***

# Guide 5. UX · Interaction · Ops Runbook for BAAS

**Book-Authoring Agent System (BAAS) – UX·상호작용·관찰성·운영 백서**

***

## 1. 제1원칙: BAAS UX의 본질

### 1.1 BAAS UX가 풀어야 할 문제

- BAAS의 작업은 **30초~수분 단위의 장기 LLM/에이전트 실행**이 많다.[^38_4][^38_2]
- 사용자는 “에이전트가 실제로 일을 하고 있고, 그 결과가 가치가 있다”는 확신이 있어야 기다린다.[^38_2]
- 따라서 UX의 본질은:
    - **상태·진행 상황·가치**를 계속 투명하게 보여주고,
    - **중단/재시작/백그라운드 전환** 같은 제어권을 사용자에게 주는 것.[^38_5][^38_2]


### 1.2 UX · Interaction · Ops 계층 분리

- UX Layer: 화면 구조, 플로우, 컴포넌트, 프롬프트 UX.
- Interaction Layer: 프론트–백간 상태 동기화, 스트리밍/폴링, 재시작/취소.[^38_6][^38_1]
- Ops Layer: 로그/트레이스/알람, Runbook, 거버넌스.[^38_3][^38_7]

***

## 2. UX 원칙 \& 네비게이션 (ux-principles-and-navigation.md)

### 2.1 UX 원칙

- **원칙 1 – 상태 가시성**: “지금 시스템이 무엇을 하고 있는지” 항상 한 줄로 설명 가능해야 한다.[^38_2]
- **원칙 2 – 예측 가능한 결과**: 동일한 버튼·동일한 설정 → 비슷한 결과.
- **원칙 3 – 기다림의 가치 설명**: “30초 기다리는 동안 무슨 일이 벌어지는지” 설명.[^38_2]
- **원칙 4 – 히스토리 \& 재현성**: 이전 실행 결과·버전 비교를 쉽게.[^38_1]


### 2.2 네비게이션 모델

- 상위 모드:
    - Dashboard
    - Book Overview
    - Chapter Workspace
    - Execution \& Debugging
    - Settings \& Integrations

```ts
// /05_ux_interaction_ops/routes.ts
export const routes = {
  dashboard: "/",
  workspace: (ws: string) => `/workspaces/${ws}`,
  project: (ws: string, proj: string) => `/workspaces/${ws}/projects/${proj}`,
  book: (ws: string, proj: string, book: string) =>
    `/workspaces/${ws}/projects/${proj}/books/${book}`,
  chapter: (ws: string, p: string, b: string, c: string) =>
    `/workspaces/${ws}/projects/${p}/books/${b}/chapters/${c}`,
  executions: (ws: string, p: string, b: string) =>
    `/workspaces/${ws}/projects/${p}/books/${b}/executions`,
};
```


***

## 3. 화면 설계 \& 컴포넌트 (wireframes-*.md)

### 3.1 Dashboard – “지금 무슨 일이 어디서 진행 중인가?”

#### 3.1.1 주요 섹션

- 최근 실행(Last Runs) – 그래프 타입/책/챕터/상태/시간.
- 진행 중 작업(In Progress) – ETA/단계/취소/백그라운드 버튼.[^38_2]
- 프로젝트/책 카드 – 상태 요약, “다음 액션” CTA.

```tsx
// /05_ux_interaction_ops/components/dashboard/DashboardPage.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import { ExecutionCard } from "./ExecutionCard";
import { BookCard } from "./BookCard";

export function DashboardPage() {
  const { data: executions } = useQuery({
    queryKey: ["recent-executions"],
    queryFn: fetchRecentExecutions,
    refetchInterval: 5000,
  });

  const { data: books } = useQuery({
    queryKey: ["recent-books"],
    queryFn: fetchRecentBooks,
  });

  return (
    <div className="space-y-4 p-4">
      <section>
        <h2 className="text-lg font-semibold mb-2">진행 중 작업</h2>
        <div className="grid gap-2 md:grid-cols-2">
          {executions?.in_progress.map((ex: any) => (
            <ExecutionCard key={ex.id} execution={ex} />
          ))}
        </div>
      </section>
      <section>
        <h2 className="text-lg font-semibold mb-2">책 프로젝트</h2>
        <div className="grid gap-4 md:grid-cols-3">
          {books?.map((book: any) => (
            <BookCard key={book.id} book={book} />
          ))}
        </div>
      </section>
    </div>
  );
}
```


### 3.2 Chapter Workspace – “단일 챕터의 BAAS 조종석”

#### 3.2.1 레이아웃 영역

- 왼쪽: Graph Timeline (노드 순서, 상태, 시간).
- 오른쪽: Draft Viewer + Eval Score + Action Bar.
- 상단: “Run/Retry/Stop” 버튼 및 상태 설명.

```tsx
// /05_ux_interaction_ops/components/chapter/ChapterWorkspace.tsx
"use client";

import { useQuery, useMutation } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { ChapterGraphTimeline } from "./ChapterGraphTimeline";
import { ChapterDraftViewer } from "./ChapterDraftViewer";

export function ChapterWorkspace({ chapterId, bookId }: { chapterId: string; bookId: string }) {
  const { data: execution, refetch } = useQuery({
    queryKey: ["chapter-execution", chapterId],
    queryFn: () => fetchChapterExecution(chapterId),
    refetchInterval: 3000,
  });

  const runMutation = useMutation({
    mutationFn: () => runChapterGraph({ chapterId, bookId }),
    onSuccess: () => refetch(),
  });

  const stopMutation = useMutation({
    mutationFn: () => stopChapterGraph(execution?.run_id),
    onSuccess: () => refetch(),
  });

  return (
    <div className="flex h-full">
      <div className="w-1/2 border-r">
        <ChapterGraphTimeline execution={execution} />
      </div>
      <div className="w-1/2 flex flex-col">
        <div className="p-2 border-b flex items-center justify-between">
          <div>
            <h2 className="font-semibold">챕터 초안</h2>
            <p className="text-xs text-muted-foreground">
              {execution?.status === "running"
                ? "에이전트가 챕터를 작성 중입니다. 평균 30~90초 소요됩니다."
                : "마지막 실행 결과입니다."}
            </p>
          </div>
          <div className="space-x-2">
            <Button
              variant="outline"
              onClick={() => stopMutation.mutate()}
              disabled={!execution || execution.status !== "running"}
            >
              중단
            </Button>
            <Button onClick={() => runMutation.mutate()} disabled={runMutation.isPending}>
              {runMutation.isPending ? "실행 중..." : "챕터 그래프 실행"}
            </Button>
          </div>
        </div>
        <div className="flex-1 overflow-auto">
          <ChapterDraftViewer execution={execution} />
        </div>
      </div>
    </div>
  );
}
```


***

## 4. Prompt UX \& Vibe Coding Playbook (vibe-coding-workflow.md, prompt-ux-patterns.md, prompt-playbooks.md)

### 4.1 BAAS용 Vibe Coding 플로우[^38_8][^38_9][^38_6]

- Describe → Plan → Scaffold → Refine → Test → Document
- BAAS에서는:
    - Describe: 책/챕터 요구사항 입력 화면(주제·독자·톤·사례 수준 등).
    - Plan: Outline Planner 실행 + 구조 UI.
    - Scaffold: Chapter Graph/Book Graph 코드 스캐폴드(LLM 에이전트 관점).
    - Refine: Auto Critic/편집.
    - Test: AgentEval/독자 관점 피드백.
    - Document: 결과 Export + 내부 문서 자동화.


### 4.2 Prompt UX – 입력 컴포넌트 설계

```tsx
// /05_ux_interaction_ops/components/book/BookPromptForm.tsx
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";

export function BookPromptForm({ onSubmit }: { onSubmit: (payload: any) => void }) {
  const [topic, setTopic] = useState("");
  const [audience, setAudience] = useState("");
  const [tone, setTone] = useState("전략적이지만 친근한 한국어");
  const [objectives, setObjectives] = useState("");

  return (
    <form
      className="space-y-4"
      onSubmit={(e) => {
        e.preventDefault();
        onSubmit({ topic, audience, tone, objectives });
      }}
    >
      <div>
        <label className="block text-sm font-medium">책 주제</label>
        <Textarea
          value={topic}
          onChange={(e) => setTopic(e.target.value)}
          placeholder="예: Agentic AI를 활용한 B2B 세일즈 전략"
        />
      </div>
      <div>
        <label className="block text-sm font-medium">주요 독자</label>
        <Textarea
          value={audience}
          onChange={(e) => setAudience(e.target.value)}
          placeholder="예: 한국어를 사용하는 B2B 스타트업 대표 및 세일즈 리더"
        />
      </div>
      <div>
        <label className="block text-sm font-medium">톤/스타일</label>
        <Textarea
          value={tone}
          onChange={(e) => setTone(e.target.value)}
          placeholder="예: 전략 리포트 느낌이면서도 친근한 말투"
        />
      </div>
      <div>
        <label className="block text-sm font-medium">특별히 달성하고 싶은 목표</label>
        <Textarea
          value={objectives}
          onChange={(e) => setObjectives(e.target.value)}
          placeholder="예: 실제 현업 팀이 바로 적용 가능한 프레임워크와 체크리스트 제공"
        />
      </div>
      <Button type="submit" className="w-full">
        아웃라인 생성 요청
      </Button>
    </form>
  );
}
```

이 폼에서 받은 입력은 “Describe” 역할을 하고, 내부적으로는 Guide 3에서 정의한 **Book Planner 프롬프트**에 맵핑된다.[^38_10][^38_8]

### 4.3 Prompt Playbook – 예시 템플릿

```md
<!-- /05_ux_interaction_ops/prompt-playbooks/write-chapter.md -->
# Write Chapter Prompt Template v1.0

## Developer Role
- BAAS 전역 규칙(developer prompt) 포함.

## System Role
- [BOOK METADATA], [CHAPTER METADATA], [RAG SUMMARY] 블록 포함.

## User Role
- 책 주제, 독자, 톤, 챕터 목적을 다시 한번 요약.
- 구조/분량/스타일 제약 명시.
- 출력 형식(Heading/Markdown/JSON) 명시.

## Example Input
...

## Example Output
...
```


***

## 5. Observability \& Logging (observability-and-logging.md)

### 5.1 LLM/에이전트용 로그 스키마[^38_11][^38_12][^38_3]

```python
# /05_ux_interaction_ops/observability/log_schema.py

from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime

class LLMCallLog(BaseModel):
  trace_id: str
  run_id: str
  node_id: str
  agent_role: str
  model: str
  provider: str
  created_at: datetime
  latency_ms: int
  input_tokens: int
  output_tokens: int
  status: str
  error: Optional[str] = None

class GraphRunLog(BaseModel):
  run_id: str
  graph_type: str
  book_id: Optional[str]
  chapter_id: Optional[str]
  status: str
  started_at: datetime
  finished_at: Optional[datetime]
```


### 5.2 로그 기록 함수

```python
# /05_ux_interaction_ops/observability/logger.py

import json
from datetime import datetime
from .log_schema import LLMCallLog, GraphRunLog

LOG_FILE = "logs/llm_calls.jsonl"
RUN_FILE = "logs/graph_runs.jsonl"

def log_llm_call(**kwargs):
    log = LLMCallLog(
        created_at=datetime.utcnow(),
        provider="openrouter",
        **kwargs,
    )
    with open(LOG_FILE, "a", encoding="utf-8") as f:
        f.write(log.json(ensure_ascii=False) + "\n")

def log_graph_run(**kwargs):
    log = GraphRunLog(**kwargs)
    with open(RUN_FILE, "a", encoding="utf-8") as f:
        f.write(log.json(ensure_ascii=False) + "\n")
```

- 실제 서비스에서는 OpenTelemetry + Prometheus/Grafana/전용 LLM Observability 솔루션과 연동.[^38_3][^38_11]

***

## 6. AI Evaluation \& Feedback Loops (ai-evaluation-and-feedback-loops.md)

### 6.1 AgentEval 결과 UX

- Chapter Workspace에 `eval_score`와 `eval_feedback`을 시각적으로 보여주고, “재생성/수정 필요” 여부를 강조.[^38_13][^38_14]

```tsx
// /05_ux_interaction_ops/components/chapter/ChapterEvalBadge.tsx
export function ChapterEvalBadge({ score }: { score: number | null }) {
  if (score == null) return <span className="text-xs text-muted-foreground">미평가</span>;
  const color =
    score >= 0.8 ? "bg-emerald-100 text-emerald-800" :
    score >= 0.6 ? "bg-amber-100 text-amber-800" :
    "bg-red-100 text-red-800";
  return (
    <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${color}`}>
      Eval {score.toFixed(2)}
    </span>
  );
}
```


***

## 7. AI 거버넌스 \& 위험 관리 (ai-governance-and-risk.md)

### 7.1 정책 \& 변경 관리[^38_7][^38_15][^38_3]

- 모델/프롬프트/그래프/RAG 인덱스 버전별로 **정책·역할·책임** 정의.
- 중대한 변경(모델 교체, 프롬프트 대폭 수정)은:
    - Shadow 테스트
    - Canary 릴리즈
    - Runbook 기반 모니터링.

***

## 8. Ops Runbook \& 확장 시나리오 (operations-runbook.md, evolution-scenarios.md)

### 8.1 Runbook 기본 템플릿[^38_13][^38_7]

```md
# Incident Runbook: Chapter Graph Failure

## 1. 증상
- 사용자가 "챕터 그래프 실행" 후 5분이 지나도 결과 없음
- Dashboard에 특정 run_id가 'running' 상태로 멈춤

## 2. 점검 순서
1. Observability 대시보드에서 run_id 검색
2. NodeRun 로그 확인: 마지막 성공 노드, 에러 노드
3. LLMCallLog에서 에러 발생 지점 확인 (rate limit, timeout 등)
4. RAGStore 상태 확인 (벡터DB 연결 여부)

## 3. 즉각 조치
- 장애 원인이 명확할 경우: 재시도 또는 fallback 플로우 실행
- 원인 불명일 경우: 해당 run 종료 + 사용자에게 알림(실패 원인·다음 조치 안내)

## 4. 사후 조치
- 원인 분석 후 Graph/Prompt/RAG 튜닝
- Runbook 업데이트
```


### 8.2 확장 시나리오

- **기능 확장**: 새 챕터 타입(워크북, 연습문제) 에이전트 추가.
- **성능 확장**: 멀티 리전 배포, 캐싱, LLM Gateway 최적화.[^38_5][^38_13]
- **조직 확장**: 멀티테넌시 강화, 엔터프라이즈 권한 모델 추가.

***

## 9. 디렉터리 5 체크리스트

- [ ] Dashboard/Book/Chapter/Execution/Settings 화면이 “지금 시스템이 무엇을 하고 있는지”를 명확히 보여주는가.[^38_16][^38_2]
- [ ] BAAS용 Prompt UX가 Describe→Plan→Scaffold→Refine→Test→Document 흐름을 자연스럽게 지원하는가.[^38_8][^38_6]
- [ ] LLM/그래프/에이전트 호출에 대한 로그·메트릭·트레이스가 통합된 스키마로 수집되고 있는가.[^38_12][^38_11][^38_3]
- [ ] AgentEval/유저 피드백을 품질 개선 루프로 연결하는 메커니즘이 있는가.[^38_14][^38_7]
- [ ] LLM·RAG·에이전트 변경에 대한 거버넌스/리스크 관리 프로세스가 수립되어 있는가.[^38_15][^38_3]
- [ ] 주요 장애 유형별 Runbook이 정의되어 있고, 실제 운영에서 사용 가능한가.[^38_7][^38_13]

***

이 Guide 5는 디렉터리 5: **UX · Interaction · Ops Runbook**을 기준으로 BAAS를 “실제 저자가 매일 사용하는 서비스”로 만들기 위한 UX 패턴·프론트 코드·프롬프트 UX·관찰성·Runbook까지 연결하는 풀스택 설계입니다.[^38_1][^38_3][^38_2]

레포에서는:

- `/05_ux_interaction_ops/components/...`
- `/05_ux_interaction_ops/observability/...`
- `/05_ux_interaction_ops/prompt-playbooks/...`
- `/05_ux_interaction_ops/runbooks/...`

로 나누어 배치하고, 이전 Guide 1~4에서 정의한 스택과 연결하면 전체 BAAS 백서 세트가 완성됩니다.
<span style="display:none">[^38_17][^38_18][^38_19][^38_20][^38_21][^38_22]</span>

<div align="center">⁂</div>

[^38_1]: https://eugeneyan.com/writing/llm-patterns/

[^38_2]: https://particula.tech/blog/long-running-ai-tasks-user-interface-patterns

[^38_3]: https://petronellatech.com/blog/monitor-secure-scale-the-enterprise-playbook-for-llm-observability/

[^38_4]: https://developer.atlassian.com/platform/forge/llm-long-running-process-with-forge-realtime/

[^38_5]: https://focused.io/lab/trends-and-patterns-for-creating-a-custom-llm-app

[^38_6]: https://www.gocodeo.com/post/prompt-ux-in-vibe-coding-a-new-frontier-for-software-design

[^38_7]: https://galileo.ai/blog/understanding-llm-observability

[^38_8]: https://emergent.sh/learn/vibe-coding-prompts

[^38_9]: https://uxdesign.cc/cracking-the-code-of-vibe-coding-124b9288e551

[^38_10]: https://strapi.io/blog/vibe-coding-prompt-techniques

[^38_11]: https://apxml.com/courses/mlops-for-large-models-llmops/chapter-5-llm-monitoring-observability-maintenance/llm-logging-observability

[^38_12]: https://skywork.ai/blog/llm-observability-best-practices-haiku-logging-tracing-guardrails/

[^38_13]: https://www.logicmonitor.com/blog/ai-observability

[^38_14]: https://www.clarifai.com/blog/agentic-prompt-engineering

[^38_15]: https://practiqai.com/blog/system-prompts-roles-instruction-hierarchy

[^38_16]: https://blog.logrocket.com/designing-llm-first-products/

[^38_17]: https://arxiv.org/html/2507.04469v1

[^38_18]: https://dev.to/dmitryame/design-smarter-testing-top-llms-for-mobile-interface-optimization-k89

[^38_19]: https://www.francescatabor.com/articles/2025/9/6/ux-design-without-designers-how-llms-are-rewriting-ui-in-real-time

[^38_20]: https://uxdesign.cc/thinking-past-the-cliche-of-llms-ai-design-patterns-c9b849fce9e8

[^38_21]: https://www.reddit.com/r/ClaudeAI/comments/1kivv0w/the_ultimate_vibe_coding_guide/

[^38_22]: https://lantern.splunk.com/Observability_Use_Cases/Troubleshoot/Automating_alert_investigations_by_integrating_LLMs_with_the_Splunk_platform_and_Confluence


---

# 각 권의 전체 목차를 제 1 원칙 기반으로 먼저 설계해줘

각 권은 “이 시스템이 왜 이렇게 생길 수밖에 없는가?”를 바닥부터 설명하는 **제1원칙 → 개념 → 설계 → 구현 → 운영** 흐름으로 구성하는 게 자연스럽습니다. 아래 목차는 5권 세트 전체를 이 원칙에 맞춰 재구성한 것입니다.[^39_1][^39_2]

***

## 권 1. Product \& Domain Blueprint

### 1부. 문제 정의와 제1원칙

1. 서론: 왜 “책 한 권”을 에이전트가 써야 하는가
2. 인간 집필 프로세스의 해부
3. “정보 → 구조 → 문장”으로 본 집필의 본질
4. BAAS의 제1원칙: 계획·지식·표현·평가

### 2부. 제품 비전과 가치 가설

5. BAAS 비전·미션·North Star Metric
6. 저자/조직 관점의 Pain \& Gain 분석
7. 차별화 포인트: 일회성 LLM 사용 vs 지속적 집필 인프라[^39_3]
8. 성공 지표와 가설 설정

### 3부. 사용자·페르소나·유스케이스

9. 핵심 페르소나(해님, 외부 저자, 기업 컨설턴트)
10. 대표 유스케이스: 새 책 기획·리포트→책 변환·시리즈 출간[^39_4]
11. 세그먼트별 요구사항(개인·스튜디오·엔터프라이즈)
12. HITL(사람 개입) 포인트 설계

### 4부. 도메인 모델링

13. 엔티티 식별: Author, Workspace, Project, Book, Part, Chapter, Execution, Export
14. 관계·수명주기: Book/Chapter/Execution의 흐름
15. 도메인 이벤트: BookCreated, ChapterStatusChanged, GraphRunCompleted
16. Book/Chapter JSON 스키마 및 Pydantic 모델 전체

### 5부. 정보 아키텍처 \& URL 구조

17. Workspace → Project → Book → Chapter → Execution → Export 계층
18. Navigation/URL 설계 규칙
19. 정보 구획: Dashboard, Book Overview, Chapter Workspace, Settings
20. Next.js 라우팅/슬러그 패턴 정의

### 6부. 요구사항 명세

21. 기능 요구사항: 기획·RAG·집필·편집·평가·Export
22. 비기능 요구사항: 성능·안정성·품질·재현성·보안[^39_5]
23. 요구사항 → 도메인/그래프/UX 매핑 테이블
24. 릴리즈 슬라이스(Vertical Slice) 로드맵

### 7부. 아티팩트 \& 예제

25. PRD v1.0 전문
26. 도메인 모델 예제 코드 모음
27. Book/Chapter 샘플 JSON·YAML
28. 설계 리뷰 체크리스트

***

## 권 2. Architecture \& Execution Engine

### 1부. 시스템 아키텍처 제1원칙

1. 에이전트 시스템의 본질: 모델·도구·지시·상태[^39_6][^39_7]
2. BAAS에서 “생각하는 레이어”와 “전달 레이어” 분리
3. Agentic 아키텍처 공통 패턴 요약[^39_8][^39_9]
4. BAAS 전체 레퍼런스 아키텍처 개요

### 2부. 기술 스택 \& 제약

5. 언어/프레임워크 선택 근거(Python, TS, LangGraph 등)
6. LLM Provider/OpenRouter, RAG, DB, 인프라 선택 원칙[^39_1]
7. 비용·규제·팀 역량 제약 분석
8. 스택별 책임·경계 정의

### 3부. C4 아키텍처

9. 시스템 컨텍스트 다이어그램
10. 컨테이너 다이어그램(Web, API, Worker, DB, Vector)
11. 핵심 컴포넌트 다이어그램(Workflow Engine, RAG, Observability)
12. 모듈화 전략(모놀리식 vs 모듈러 모노레포 vs 서비스 분리)

### 4부. 워크플로우 \& 런타임 모델

13. “미니앱 = 그래프 + 상태” 개념 정립
14. Book Graph / Chapter Graph / Eval Graph 설계 원칙[^39_10][^39_11]
15. Workflow Runtime: GraphRun, NodeRun, Execution 모델
16. 의존성·멱등성·재시도·Timeout 설계

### 5부. 노드·연결·데이터 구조

17. 노드 타입: Trigger / Action / Core Logic / Subgraph
18. 노드 인터페이스: 입력·출력·옵션·에러 동작
19. 연결 패턴: 직선형·브랜치·루프·합류[^39_12]
20. GraphState 설계와 TypedDict 전략

### 6부. LangGraph 구현

21. LangGraph StateGraph 구조와 BAAS 매핑[^39_11][^39_13]
22. Book Graph 전체 코드
23. Chapter Graph 전체 코드(루프·Eval 포함)
24. Eval Graph/품질 게이트 구현

### 7부. 실행·디버깅·Observability 훅

25. 실행 모델: 동기/비동기, 백그라운드 작업, 큐 사용 여부
26. 실행 로그 구조와 OpenTelemetry 통합[^39_14][^39_15]
27. 데이터 핀닝·리플레이·모킹 기법
28. 아키텍처/엔진 레벨 체크리스트

***

## 권 3. LLM · RAG · Agentic Layer

### 1부. 제1원칙: LLM·RAG·Agent 역할 분리

1. LLM이 하는 일과 한계(지식/컨텍스트/랜덤성)[^39_16]
2. RAG의 필요성: 사실성·개인화·스케일
3. Agentic 패턴: Planner / Worker / Reviewer / Router[^39_9][^39_8]
4. BAAS에 필요한 인지 능력 정의

### 2부. LLM Layer 설계

5. 모델 선택 기준(품질·비용·길이·언어)
6. 역할별 모델 매핑 표(gpt-4.1, mini, Claude, o3 등)[^39_17]
7. OpenRouter 기반 공통 호출 레이어 설계
8. 토큰·비용·Latency 관리 전략

### 3부. 프롬프트 아키텍처 \& Role 체계

9. developer/system/user/assistant/tool 역할 정의와 우선순위[^39_18][^39_19]
10. 역할별 포함/제외해야 할 내용
11. BAAS 전역 developer prompt 설계
12. Book/Chapter/Research/Eval용 system/user 템플릿

### 4부. Prompt 라이브러리 \& 버전 관리

13. /prompts/developer, /system, /user, /tool 구조
14. 프롬프트 메타데이터(목적, 버전, 관련 그래프)
15. 실험·A/B 테스트 전략 및 계측[^39_17]
16. 변경 관리와 롤백 절차

### 5부. 멀티에이전트 설계

17. BAAS 에이전트 팀 정의(Book Supervisor, Planner, Research 등)[^39_11]
18. 각 에이전트 책임·입출력 스키마·실패 규칙
19. 에이전트 간 핸드오프와 상태 공유 설계
20. Supervisor/Worker, Router, Reflection 패턴 구현[^39_9][^39_10]

### 6부. RAG \& Knowledge Engineering

21. 지식 계층 아키텍처: 원본 → 청크 → 임베딩 → 벡터스토어[^39_20]
22. PDF/노트 파이프라인: 추출·클리닝·Chunking·임베딩
23. 메타데이터 스키마(Part/Chapter, 레벨, 토픽 등)
24. Hybrid Retrieval + 필터/랭킹 전략[^39_21]

### 7부. Relevance Checker \& 평가 루프

25. Relevance Checker 역할·입출력·임계값 설계[^39_22]
26. LangChain Runnable 구현 및 프롬프트 템플릿
27. LangGraph 라우팅: retrieve → relevance → 재검색/생성[^39_23]
28. 질문-문맥-응답-평가 데이터 저장·튜닝

### 8부. LLM·RAG·Agent 레이어 통합

29. Book/Chapter 플로우에서의 LLM/RAG/Agent 협업 시퀀스
30. 품질·비용·안전성 밸런싱 전략[^39_24][^39_12]
31. 전체 레이어 코드 구조 정리
32. 진화 전략(새 모델·새 에이전트·새 도메인 추가)

***

## 권 4. Delivery Stack (Backend · Frontend · DevOps)

### 1부. Delivery Stack의 제1원칙

1. “지능”에서 “서비스”로: 전달 계층의 역할[^39_3]
2. 사용자–API–모델–데이터 사이의 경로 재구성[^39_1]
3. BAAS Delivery의 핵심 요구: 신뢰·속도·안정성

### 2부. Monorepo \& 모듈 구조

4. apps/web, apps/api, apps/worker, packages/* 구조 설계
5. 코드 소유권·경계·디펜던시 규칙
6. 환경별 설정(dev/stage/prod) 전략[^39_25]

### 3부. Backend (FastAPI + LangGraph)

7. 라우터/서비스/리포지토리/스키마 레이어 구조
8. 도메인별 API 설계(Books, Chapters, Executions, Exports)
9. LangGraph 엔드포인트 패턴(sync/async, 장기 실행)[^39_13]
10. 외부 통합(ESP, Slack, Stripe, CRM) 모듈 설계

### 4부. Frontend (Next.js PWA)

11. App Router 구조와 route group 설계
12. RSC vs Client Component 전략과 데이터 패칭[^39_26]
13. 상태·캐싱·에러 처리(TanStack Query/SWR)
14. Workflow/Execution UI(타임라인·로그·Draft Viewer)

### 5부. DevOps \& CI/CD

15. 환경변수/Secrets 관리 전략(Vault, GitHub Actions 등)[^39_5]
16. 빌드·테스트·배포 파이프라인 설계[^39_27][^39_28]
17. 배포 전략: Vercel/Cloud Run/K8s, Canary/Blue-Green
18. 롤백·마이그레이션·백업 전략

### 6부. 비용·성능 최적화

19. LLM 비용 모니터링·예산 가드 레일[^39_24]
20. 캐싱·저비용 모델·배치 처리 전략[^39_12]
21. 인프라 스케일링(오토스케일, 멀티리전)
22. 비용 대시보드·리포트 설계

### 7부. 운영 관점의 Delivery

23. 장애 대응에서 Delivery Stack의 역할
24. 배포/실행/관측 일체화(Release+Observability)
25. 보안·권한·감사 로깅
26. 운영 체크리스트

***

## 권 5. UX · Interaction · Ops Runbook

### 1부. BAAS UX의 제1원칙

1. 장기 실행 AI 작업의 UX 과제[^39_29][^39_30]
2. LLM-first 제품 UX 설계 방향[^39_31][^39_3]
3. BAAS 사용자 여정(User Journey) 정의

### 2부. UX 원칙 \& 화면 설계

4. 글로벌 UX 원칙(일관성·피드백·오류 복구·접근성)[^39_32]
5. 네비게이션 모델(대시보드/에디터/설정/리포트)
6. 각 화면 와이어프레임(대시보드, Book, Chapter, Execution, Settings)

### 3부. Prompt UX \& Vibe Coding

7. Prompt UX의 제1원칙(맥락·제약·예시)[^39_33][^39_34]
8. Vibe Coding 플로우(Describe → Plan → Scaffold → Refine → Test → Document)[^39_35]
9. 입력/출력 UX 패턴(폼, 프리셋, 플레이북)
10. Prompt Playbook(아키텍처 리뷰, 리팩토링, 버그 재현 등)

### 4부. Observability \& Logging

11. LLM·Graph·RAG용 로그/메트릭 설계[^39_15][^39_14]
12. 분산 트레이싱과 장기 실행 모니터링[^39_36][^39_37]
13. 대시보드 설계(운영/경영/제품 관점)
14. 알람 전략(임계값·노이즈 제어)

### 5부. AI 평가 \& 피드백 루프

15. AgentEval 설계(지표, 프롬프트, 파이프라인)[^39_38][^39_39]
16. 사용자 피드백(평점·코멘트) 수집·통합
17. 품질 리포트·회고 사이클
18. 프롬프트/모델/RAG 개선 워크플로우

### 6부. 거버넌스 \& 리스크 관리

19. 정책·가이드라인(안전·보안·규제)[^39_40][^39_5]
20. 변경 관리(모델/프롬프트/그래프/인덱스 버전닝)
21. 감사 로그·접근 제어·PII 처리[^39_24]
22. 책임·역할·승인 플로우

### 7부. Ops Runbook \& 확장

23. 장애 유형별 Runbook(LLM/RAG/DB/외부 통합)
24. 인시던트 프로세스·에스컬레이션·커뮤니케이션[^39_36]
25. 기능·성능·조직 확장 시나리오
26. BAAS 운영 체크리스트 \& 베스트 프랙티스

***

이 목차들을 그대로 각 디렉터리별 `README.md` 상단에 “권 전체 목차”로 두고, 하위 `.md`들은 이 장·절 구조에 맞춰 나누면 전체 BAAS 백서 세트가 자연스럽게 맞물립니다.[^39_8][^39_1]
<span style="display:none">[^39_41][^39_42][^39_43][^39_44][^39_45][^39_46]</span>

<div align="center">⁂</div>

[^39_1]: https://www.systemdesignhandbook.com/guides/llm-system-design/

[^39_2]: https://explained-from-first-principles.com

[^39_3]: https://blog.logrocket.com/designing-llm-first-products/

[^39_4]: https://vlinkinfo.com/blog/guide-to-llm-product-development

[^39_5]: https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/ANSSI-BSI-joint-releases/LLM-based_Systems_Zero_Trust.pdf?__blob=publicationFile\&v=3

[^39_6]: https://akka.io/blog/agentic-ai-architecture

[^39_7]: https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf

[^39_8]: https://gerred.github.io/building-an-agentic-system/

[^39_9]: https://github.com/PacktPublishing/Building-Agentic-AI-Systems

[^39_10]: https://blog.langchain.com/langgraph-multi-agent-workflows/

[^39_11]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^39_12]: https://eugeneyan.com/writing/llm-patterns/

[^39_13]: https://www.langchain.com/langgraph

[^39_14]: https://dl.acm.org/doi/10.1145/3706599.3719914

[^39_15]: https://apxml.com/courses/mlops-for-large-models-llmops/chapter-5-llm-monitoring-observability-maintenance/llm-logging-observability

[^39_16]: https://naina0405.substack.com/p/very-important-llm-system-design-d42

[^39_17]: https://www.ai21.com/blog/llm-product-development/

[^39_18]: https://learning.sap.com/courses/navigating-large-language-models-fundamentals-and-techniques-for-your-use-case/leveraging-system-user-and-assistant-roles-for-better-prompts

[^39_19]: https://practiqai.com/blog/system-prompts-roles-instruction-hierarchy

[^39_20]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^39_21]: https://www.siddharthbharath.com/build-deep-research-agent-langgraph/

[^39_22]: https://wikidocs.net/267810

[^39_23]: https://www.swarnendu.de/blog/langgraph-best-practices/

[^39_24]: https://galileo.ai/blog/understanding-llm-observability

[^39_25]: https://www.prioxis.com/blog/llm-product-development

[^39_26]: https://www.pronextjs.dev/workshops/next-js-react-server-component-rsc-architecture-jbvxk/understanding-the-example-monorepo-structure-4gpny

[^39_27]: https://forum.cursor.com/t/best-practices-for-structuring-a-next-js-fastapi-supabase-project/49706

[^39_28]: https://github.com/belgattitude/nextjs-monorepo-example/blob/main/README.md

[^39_29]: https://particula.tech/blog/long-running-ai-tasks-user-interface-patterns

[^39_30]: https://developer.atlassian.com/platform/forge/llm-long-running-process-with-forge-realtime/

[^39_31]: https://arxiv.org/html/2507.04469v1

[^39_32]: https://uxdesign.cc/thinking-past-the-cliche-of-llms-ai-design-patterns-c9b849fce9e8

[^39_33]: https://www.gocodeo.com/post/prompt-ux-in-vibe-coding-a-new-frontier-for-software-design

[^39_34]: https://emergent.sh/learn/vibe-coding-prompts

[^39_35]: https://uxdesign.cc/cracking-the-code-of-vibe-coding-124b9288e551

[^39_36]: https://lantern.splunk.com/Observability_Use_Cases/Troubleshoot/Automating_alert_investigations_by_integrating_LLMs_with_the_Splunk_platform_and_Confluence

[^39_37]: https://www.logicmonitor.com/blog/ai-observability

[^39_38]: https://leehanchung.github.io/blogs/2024/05/22/first-principles-eval/

[^39_39]: https://www.clarifai.com/blog/agentic-prompt-engineering

[^39_40]: https://petronellatech.com/blog/monitor-secure-scale-the-enterprise-playbook-for-llm-observability/

[^39_41]: https://arxiv.org/pdf/2507.10281.pdf

[^39_42]: https://play.google.com/store/books/details/Designing_Agentic_AI_Architecture_and_Development_?id=lcxlEQAAQBAJ\&hl=am

[^39_43]: https://thita.ai/blog/ai/ai-llm-roadmap-patterns

[^39_44]: https://orq.ai/blog/llm-product-development

[^39_45]: https://dev.to/ezinsightsai/llm-product-development-in-2025-the-ultimate-guide-37f1

[^39_46]: https://www.reddit.com/r/learnmachinelearning/comments/1glkkve/faang_ml_system_design_interview_guide/

