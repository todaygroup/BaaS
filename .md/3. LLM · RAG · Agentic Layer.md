<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# 디렉터리 3: LLM · RAG · Agentic Layer (/03_llm_rag_agents)

“LLM·RAG·에이전트가 어떻게 협업하고, 비용·품질을 어떻게 관리하는가.”freecodecamp+2
3-1. LLM Provider \& OpenRouter 전략
llm-provider-strategy-openrouter.md
OpenRouter 중심 모델 전략(저비용/고품질 모델 조합)[peliqan](https://peliqan.io/blog/langchain-vs-langgraph/)
환경별 기본 모델·fallback 모델, rate limit·비용 가드
llm-layer-architecture.md
LLM 호출 레이어(공통 wrapper, 로깅, 재시도, 백오프)
동기/비동기 호출 패턴, 스트리밍 전략
3-2. 프롬프트 아키텍처 \& Role 체계
prompt-roles-and-instruction-hierarchy.md
developer/system/user/assistant/tool 역할 정의와 우선순위[learning.sap+2](https://learning.sap.com/courses/navigating-large-language-models-fundamentals-and-techniques-for-your-use-case/leveraging-system-user-and-assistant-roles-for-better-prompts)
역할별에 어떤 내용이 들어가야/들어가면 안 되는지
prompt-templates-and-patterns.md
아키텍처 생성 / 컴포넌트 생성 / 테스트 생성 / 리팩토링 / 평가 패턴[vibecoding+2](https://vibecoding.app/blog/how-vibe-coding-works)
Role별 메시지 셋 예시(바이브 코딩용 세트)
prompt-library-structure.md
/prompts/developer/, /prompts/system/, /prompts/user/, /prompts/tool/ 디렉터리 설계[roboco+1](https://roboco.io/posts/vibe-coding-manual/)
버전 관리·실험(A/B) 방법
3-3. 멀티에이전트 아키텍처 (LangGraph)
multi-agent-architecture.md
에이전트 역할: Planner, Retriever, Coder, Evaluator, Router 등[langchain-ai.github+1](https://langchain-ai.github.io/langgraph/concepts/multi_agent/)
GraphState 설계(키, 타입, reducer 패턴)
agent-patterns-and-best-practices.md
Supervisor/Worker, Router, Reflection 패턴[langchain+1](https://blog.langchain.com/building-langgraph/)
루프·비용 폭주 방지, 실패·fallback 전략
3-4. 데이터 \& RAG · Relevance Checker
data-rag-infra.md
Supabase 스키마, Qdrant 컬렉션, 인덱싱 파이프라인[freecodecamp](https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/)
ETL(배치/스트리밍), 데이터 등급·보안
relevance-checker-module.md
Relevance Checker 역할/입출력/스코어링 구조[wikidocs](https://wikidocs.net/267810)
LangChain Runnable 구현·프롬프트 예시
LangGraph 라우팅 패턴 (retrieve → relevance_check → 재검색/생성)[swarnendu](https://www.swarnendu.de/blog/langgraph-best-practices/)
rag-agent-integration-patterns.md
Retrieval → Relevance → Planning → Generation
품질 평가 루프(질문-문맥-응답 평가 데이터 저장)

**각 .md 파일의 세부 섹션/문단 수준까지 더 쪼개는 “세분화 작업”**

디렉터리 3의 각 `.md`를 바로 작성 가능하도록 **섹션/소제목 레벨까지 세분화한 구조**입니다.[^1][^2][^3][^4]

***

## 3-1. LLM Provider \& OpenRouter 전략

### 1) `llm-provider-strategy-openrouter.md`

#### 1. 서론

- 1.1 문서의 목적
- 1.2 전제(비용 제약, 다수 모델 활용, 글로벌 서비스 맥락)


#### 2. LLM Provider 선택 원칙

- 2.1 OpenRouter 중심 전략 개요[^1]
- 2.2 단일 클라우드 LLM vs OpenRouter(멀티 모델/멀티 벤더)의 비교
- 2.3 규제/데이터 위치 관점 고려사항


#### 3. 모델 포트폴리오 설계

- 3.1 경량 모델(초안/보조/유틸리티용)
- 3.2 고성능 모델(복잡 추론/생산 품질 응답용)
- 3.3 특화 모델(코딩, 비전, 로컬 언어 등)
- 3.4 각 모델별 권장 용도와 호출 가이드


#### 4. 환경별 기본/대체 모델 전략

- 4.1 Dev/Stage/Prod 환경 구분
- 4.2 환경별 기본 모델(default), fallback 모델 정의
- 4.3 모델 비가용 시 fallback 시나리오


#### 5. Rate Limit · 비용 가드

- 5.1 호출 한도·동시성 제한 설계
- 5.2 사용자/워크스페이스별 비용 상한(Soft/Hard limit)
- 5.3 비용 모니터링 메트릭(호출 수, 토큰, 비용 단가)


#### 6. 설정·환경변수 설계

- 6.1 `OPENROUTER_API_KEY`, `OPENROUTER_BASE_URL`, 기본 모델 환경변수
- 6.2 per-feature/per-graph 모델 설정 패턴


#### 7. 체크리스트


***

### 2) `llm-layer-architecture.md`

#### 1. 서론

- 1.1 LLM 레이어를 따로 두는 이유


#### 2. LLM 호출 레이어 구조

- 2.1 공통 Wrapper(로깅/리트라이/타임아웃) 설계[^2]
- 2.2 입력/출력 표준화(역할 메시지, 메타데이터 포함)
- 2.3 에러·예외 타입 정의


#### 3. 호출 패턴 (Sync/Async)

- 3.1 사용자 요청 동기 처리 패턴
- 3.2 백그라운드/배치 작업용 비동기 호출 패턴
- 3.3 큐·잡 시스템 연계 여부


#### 4. 스트리밍 전략

- 4.1 프론트로의 토큰 스트리밍 UX 패턴
- 4.2 스트리밍 중단/취소/재시도 처리
- 4.3 로그·감사 데이터와 스트리밍의 관계


#### 5. 관찰성·성능 최적화

- 5.1 LLM 레이어 메트릭(지연, 오류율, 비용)
- 5.2 캐싱 전략(입력/출력 캐시)
- 5.3 동일 요청 중복 방지(Deduplication)


#### 6. 체크리스트


***

## 3-2. 프롬프트 아키텍처 \& Role 체계

### 3) `prompt-roles-and-instruction-hierarchy.md`

#### 1. 서론

- 1.1 Role 기반 프롬프트 구조의 필요성[^5][^6]
- 1.2 이 문서가 다루는 범위(5 roles)


#### 2. Role 정의와 우선순위

- 2.1 developer(구 system) 역할: 전역 규칙·정책·톤[^6]
- 2.2 system 역할: 런타임 컨텍스트·요약·툴 결과[^5]
- 2.3 user 역할: 인간 사용자의 의도·요구사항
- 2.4 assistant 역할: 모델 응답 채널
- 2.5 tool 역할: 외부 도구 결과·상태 보고[^7]
- 2.6 우선순위 계층(Developer > System > Tool facts > User > Assistant)


#### 3. 역할별 “포함해야 할 내용”과 “금지할 내용”

- 3.1 developer: 정책, 불변 규칙 / 동적 컨텍스트 금지
- 3.2 system: 현재 상태, 문맥 / 장기 규칙 중복 정의 금지
- 3.3 user: 명령·질문·예시 / 내부 구현 세부 규칙 강제 금지
- 3.4 assistant: 결과·설명 / 새 정책 선언 금지(승격 프로세스 없이)
- 3.5 tool: 원시 결과·에러 / 해석·추론 포함 금지[^8][^5]


#### 4. Instruction Hierarchy 설계

- 4.1 상충 시 우선순위 규칙
- 4.2 정책 업데이트 프로세스(developer 메시지 변경 시 영향도)


#### 5. 예시 메시지 셋

- 5.1 아키텍처 설계 세션 예시(5 roles 풀 세트)
- 5.2 워크플로우 디버깅 세션 예시
- 5.3 UI/컴포넌트 생성 세션 예시


#### 6. 체크리스트


***

### 4) `prompt-templates-and-patterns.md`

#### 1. 서론

#### 2. 아키텍처 생성 프롬프트 패턴

- 2.1 시스템·제약·요구사항 입력 구조
- 2.2 “구조 → 다이어그램 → 근거”를 요구하는 템플릿[^9][^10]


#### 3. 컴포넌트/화면 생성 프롬프트 패턴

- 3.1 컴포넌트 트리·Props·상태·이벤트까지 요구하는 템플릿
- 3.2 shadcn/Tailwind 매핑을 명시하는 패턴


#### 4. 테스트·리팩토링 프롬프트

- 4.1 단위·통합 테스트 케이스 생성 템플릿
- 4.2 성능/보안/구조 리팩토링 제안 템플릿[^11][^12]


#### 5. 평가·리뷰 프롬프트

- 5.1 코드 리뷰·아키텍처 리뷰 프롬프트
- 5.2 RAG 응답 품질 평가 프롬프트


#### 6. Role별 메시지 셋 예시

- 6.1 developer + system + user 조합 예시(바이브 코딩 세션)
- 6.2 user/assistant/outil 상호작용 예시


#### 7. 체크리스트


***

### 5) `prompt-library-structure.md`

#### 1. 서론

#### 2. 디렉터리 구조

- 2.1 `/prompts/developer/` : 전역 규칙·도메인 정책[^11]
- 2.2 `/prompts/system/` : 워크플로우/에이전트별 컨텍스트 템플릿
- 2.3 `/prompts/user/` : 기능/코드/리뷰용 유저 프롬프트
- 2.4 `/prompts/tool/` : 도구 응답 포맷 정의[^10]


#### 3. 파일 네이밍·메타데이터 규칙

- 3.1 이름 규칙(도메인-용도-버전)
- 3.2 메타데이터(작성자, 버전, 목표, 관련 그래프)


#### 4. 버전 관리·릴리즈

- 4.1 프롬프트 변경에 따른 영향도 관리
- 4.2 Git·Changelog·릴리즈 노트 패턴


#### 5. 실험·A/B 테스트

- 5.1 프롬프트 A/B 구조(변경 포인트만 분리)
- 5.2 메트릭(정확도, 사용자 만족도, 비용) 정의[^6][^8]


#### 6. 체크리스트


***

## 3-3. 멀티에이전트 아키텍처 (LangGraph)

### 6) `multi-agent-architecture.md`

#### 1. 서론

- 1.1 멀티에이전트가 필요한 이유[^3][^8]


#### 2. 에이전트 역할 정의

- 2.1 Planner/Orchestrator
- 2.2 Researcher/Retriever
- 2.3 Coder/Tool Executor
- 2.4 Evaluator/Guardrail
- 2.5 Router/Dispatcher[^3]


#### 3. GraphState 설계

- 3.1 상태 키 목록(question, plan, context, result, cost 등)
- 3.2 타입·초기값·필수/옵션 구분
- 3.3 Reducer 패턴(상태 병합 규칙)[^13][^3]


#### 4. 노드(StateGraph Node) 설계

- 4.1 함수 시그니처(state 입력/출력)
- 4.2 툴/LLM 호출을 포함하는 노드 vs 단순 로직 노드
- 4.3 부작용·IO를 다루는 규칙


#### 5. 에이전트 경계·책임

- 5.1 각 에이전트가 처리할 것 vs 넘길 것
- 5.2 재사용 가능한 서브그래프 정의


#### 6. 체크리스트


***

### 7) `agent-patterns-and-best-practices.md`

#### 1. 서론

#### 2. Supervisor/Worker 패턴

- 2.1 구조(상위 계획 → 하위 작업 분배)[^14][^13]
- 2.2 장점·단점·사용 시점
- 2.3 구현 시 고려사항(상태 크기, 비용)


#### 3. Router 패턴

- 3.1 입력에 따라 다른 에이전트로 라우팅
- 3.2 라우팅 기준(질문 타입, 위험도, 비용 예측)


#### 4. Reflection/검증 루프 패턴

- 4.1 초안 생성 → 평가 → 수정 루프 구조
- 4.2 Evaluator 에이전트의 역할 정의[^8][^13]


#### 5. 루프·비용 폭주 방지

- 5.1 최대 스텝/깊이 제한
- 5.2 GraphRecursionError 대비 전략
- 5.3 비용 상한 초과시 중단·요약·fallback


#### 6. 실패·fallback 전략

- 6.1 도구 오류·LLM 오류 핸들링
- 6.2 대체 경로(보수적 응답, 수동 개입 요청) 설계


#### 7. 체크리스트


***

## 3-4. 데이터 \& RAG · Relevance Checker

### 8) `data-rag-infra.md`

#### 1. 서론

#### 2. 데이터 계층 구조

- 2.1 OLTP(Supabase) vs Vector(Qdrant) vs 로그/메트릭[^2]
- 2.2 각 계층의 책임과 경계


#### 3. Supabase 스키마 개요

- 3.1 도메인 테이블(워크플로우/실행/유저 등)
- 3.2 RAG 관련 테이블(문서 메타, 인덱싱 상태)


#### 4. Qdrant 컬렉션 설계

- 4.1 컬렉션별 목적(docs/templates/faq/logs)
- 4.2 벡터·메타데이터 스키마, 샤딩/Replica 전략


#### 5. 인덱싱 파이프라인

- 5.1 문서 수집/전처리/분할/임베딩[^2]
- 5.2 업데이트/삭제·역인덱싱 전략


#### 6. ETL/동기화 워크플로우

- 6.1 배치 방식 vs 스트리밍 방식
- 6.2 에러·재시도·관찰성 포인트


#### 7. 데이터 등급·보안

- 7.1 PII/비PII 구분
- 7.2 접근 제어·마스킹·익명화


#### 8. 체크리스트


***

### 9) `relevance-checker-module.md`

#### 1. 서론

- 1.1 왜 관련성(Relevance)을 따로 체크해야 하는가[^4]


#### 2. 역할과 책임

- 2.1 RAG 파이프라인에서 Relevance Checker 위치
- 2.2 책임 범위: 문맥이 질문에 충분히 관련 있는지 판정


#### 3. 입출력·스코어링 구조

- 3.1 입력: question, context_chunk, 기타 메타데이터
- 3.2 출력: is_relevant, score, rationale
- 3.3 임계값(threshold), 경계값(회색 영역) 정의[^4]


#### 4. LangChain Runnable 구현

- 4.1 프롬프트 템플릿 구조(질문/컨텍스트/지침)[^4]
- 4.2 Runnable/Chain 구성, 예제 코드 스케치
- 4.3 테스트 케이스 설계(엣지 케이스 포함)


#### 5. LangGraph 라우팅 패턴

- 5.1 retrieve → relevance_check → (검색 반복/생성) 그래프 구조[^13]
- 5.2 GraphState에 relevance 정보를 어떻게 기록할 것인가
- 5.3 루프 제한·timeout·fallback 설계


#### 6. 관찰성·튜닝

- 6.1 Relevance 실패율·재검색 횟수 메트릭
- 6.2 임계값·프롬프트 튜닝 프로세스


#### 7. 체크리스트


***

### 10) `rag-agent-integration-patterns.md`

#### 1. 서론

#### 2. RAG + 에이전트 기본 플로우

- 2.1 Retrieval → Relevance → Planning → Generation[^3][^2]
- 2.2 각 단계 에이전트/노드의 책임


#### 3. 패턴 1: 단일 쿼리 RAG

- 3.1 간단 Q\&A/FAQ 패턴
- 3.2 품질/비용 트레이드오프


#### 4. 패턴 2: 멀티스텝 리서치

- 4.1 다단계 문서 탐색·요약 패턴
- 4.2 중간 결과 저장·재사용 전략


#### 5. 품질 평가 루프

- 5.1 질문-문맥-응답-평가 데이터를 구조화해 저장
- 5.2 자동 평가(LLM-based grader) + 사용자 피드백 통합[^8]


#### 6. 실패·안전 패턴

- 6.1 관련 문맥 부족|충돌 감지 시 보수적 응답
- 6.2 “I don’t know” 및 재질문 전략


#### 7. 체크리스트


***

이 세분화 구조를 그대로 `/03_llm_rag_agents`의 `.md` 헤더로 사용하면, 이후에는 각 섹션마다 **설명·예시·프롬프트·코드 스니펫**만 채워 넣으면 됩니다.[^1][^2][^3][^4]

<div align="center">⁂</div>

[^1]: https://peliqan.io/blog/langchain-vs-langgraph/

[^2]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^3]: https://langchain-ai.github.io/langgraph/concepts/multi_agent/

[^4]: https://wikidocs.net/267810

[^5]: https://learning.sap.com/courses/navigating-large-language-models-fundamentals-and-techniques-for-your-use-case/leveraging-system-user-and-assistant-roles-for-better-prompts

[^6]: https://practiqai.com/blog/system-prompts-roles-instruction-hierarchy

[^7]: https://docs.nvidia.com/nim/large-language-models/latest/system-example.html

[^8]: https://www.clarifai.com/blog/agentic-prompt-engineering

[^9]: https://vibecoding.app/blog/how-vibe-coding-works

[^10]: https://github.com/cpjet64/vibecoding/blob/main/system-architecture-guide.md

[^11]: https://roboco.io/posts/vibe-coding-manual/

[^12]: https://zread.ai/tukuaiai/vibe-coding-cn/2-quick-start

[^13]: https://www.swarnendu.de/blog/langgraph-best-practices/

[^14]: https://blog.langchain.com/building-langgraph/

