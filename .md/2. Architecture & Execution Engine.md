<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# 디렉터리 2: Architecture \& Execution Engine(/02_arch_execution)

“어떤 기술 스택과 아키텍처로, 어떻게 실행·흐름을 제어할 것인가.”swarnendu+2
2-1. 전체 아키텍처 \& 스택
tech-stack-and-constraints.md
프론트: Next.js PWA, shadcn/ui, Tailwind 등
백엔드: FastAPI, LangGraph, LangChain, Supabase, Qdrant
인프라: Vercel/Cloud Run/K8s, CDN, ESP, 모니터링 스택
제약(예산/팀 능력/공급자·리전 제약)
architecture-overview.md
C4 컨텍스트/컨테이너/컴포넌트 다이어그램
모놀리식 vs 모듈러 모노레포 vs 마이크로서비스 선택 근거
2-2. Workflow · 노드 · 데이터 런타임
workflow-concepts-and-layers.md
레이어: Presentation(에디터) / Workflow Runtime / Nodes / Connections / Data / Credentials / Executions / Debugging[n8n+1](https://docs.n8n.io/workflows/)
“미니앱 = 그래프(노드/엣지 + 상태)” 개념
node-basics.md
노드 타입: 트리거/액션/코어 로직/서브그래프·에이전트
노드 생명주기(생성→설정→실행→로깅→버전)
node-catalog.md
기능별 노드 카탈로그(유저/워크스페이스, 통합, AI/RAG, 유틸리티)
각 노드의 입력/출력 스키마, 옵션, 실패 시 동작
connections-and-flow-control.md
단일/병렬/브랜치/합류 패턴
순서 결정, 의존성, 멱등성 고려
LangGraph StateGraph와의 매핑[langchain+1](https://www.langchain.com/langgraph)
data-model-in-workflows.md
워크플로우 내 데이터 구조(items[], JSON, 멀티모달)
변환·검증 규칙, 에러 처리, 타입 전략
2-3. Credentials \& Secrets · 실행 \& 디버깅
credentials-and-secrets.md
API 키/OAuth/서비스 계정 모델, 암호화 저장, 로테이션
워크플로우에서의 스코프·권한 최소화[n8n+1](https://docs.n8n.io/integrations/builtin/credentials/)
executions-and-logging.md
실행(run) 모델, 상태(대기/성공/실패), 리트라이 정책
실행 로그 구조(노드별 입력/출력/에러/메트릭)
debugging-and-data-pinning.md
데이터 핀닝·모킹 개념과 사용 가이드
에러 패턴(JSON, Expression, 타임아웃 등)별 디버깅 레시피[n8n+1](https://docs.n8n.io/data/data-pinning/)
2-4. LangChain + LangGraph · Prompt-to-Graph
langchain-langgraph-integration.md
제1원칙: LangChain=컴포넌트(Chain/Tool/Retriever), LangGraph=오케스트레이터[peliqan+1](https://peliqan.io/blog/langchain-vs-langgraph/)
LangChain 객체를 LangGraph 노드에서 호출하는 패턴
prompt-to-graph-strategy.md
자연어 → 노드 그래프 생성(PTG/Opal/자체 도구) 전략
그래프 품질 체크리스트(루프, 에러 경로, 자격 증명, 비용)[github+1](https://github.com/langchain-ai/langgraph/issues/3365)

**각 .md 파일의 세부 섹션/문단 수준까지 더 쪼개는 “세분화 작업”**

디렉터리 2의 각 `.md`를 바로 작성 가능하도록 **섹션/소제목 단위까지 세분화**한 구조입니다.[^1][^2][^3][^4]

***

## 2-1. 전체 아키텍처 \& 스택

### 1) `tech-stack-and-constraints.md`

#### 1. 서론

- 1.1 문서의 목적
- 1.2 대상 독자(아키텍트, 리드 개발자, DevOps)


#### 2. 프론트엔드 스택

- 2.1 Next.js PWA 선택 이유
- 2.2 shadcn/ui \& Tailwind 설계 원칙
- 2.3 프론트에서 직접 사용하는 LLM/에이전트 호출 정책(가능/지양)


#### 3. 백엔드 스택

- 3.1 FastAPI 선택 이유 및 장단점
- 3.2 LangGraph(LangChain 포함) 역할(에이전트 런타임/워크플로우 엔진)[^2][^5]
- 3.3 Supabase(Postgres/Auth/Storage) 역할
- 3.4 Qdrant(RAG 벡터 스토어) 역할


#### 4. 인프라 스택

- 4.1 호스팅 전략: Vercel / Cloud Run / K8s 중 선택 기준
- 4.2 CDN·이미지 처리·캐시 계층 개요
- 4.3 ESP(메일), 모니터링/로그/트레이싱 스택 개요


#### 5. 공통 라이브러리·언어·버전 정책

- 5.1 언어·런타임(Node, Python) 버전
- 5.2 공통 유틸 패키지·코딩 규약


#### 6. 제약 조건(Constraints)

- 6.1 예산·비용 제약(LLM/인프라)
- 6.2 팀 역량·학습 곡선 제약
- 6.3 공급자, 리전, 규제 제약


#### 7. 바이브 코딩용 스택 설명 프롬프트

- 7.1 “이 스택 기준으로 아키텍처 제안” 프롬프트 템플릿


#### 8. 체크리스트


***

### 2) `architecture-overview.md`

#### 1. 서론

- 1.1 전체 아키텍처 문서의 역할


#### 2. C4 Level 1: 시스템 컨텍스트

- 2.1 사용자/외부 시스템/플랫폼 간 관계
- 2.2 주요 경계(프론트/백/에이전트/데이터)


#### 3. C4 Level 2: 컨테이너 다이어그램

- 3.1 프론트엔드 앱
- 3.2 API/에이전트 런타임(FastAPI + LangGraph)
- 3.3 데이터베이스/벡터스토어/스토리지
- 3.4 백그라운드 워커/큐(필요 시)


#### 4. C4 Level 3: 핵심 컴포넌트

- 4.1 워크플로우 엔진 컴포넌트
- 4.2 LLM/RAG/에이전트 컴포넌트
- 4.3 통합(ESP/Slack/Stripe 등) 컴포넌트
- 4.4 Observability 컴포넌트


#### 5. 아키텍처 스타일 선택 근거

- 5.1 모놀리식 vs 모듈러 모노레포 vs 마이크로서비스 비교
- 5.2 선택한 구조와 이유(팀 규모·복잡도·속도·비용)


#### 6. 진화/확장 시 고려사항

- 6.1 기능 확장 시 분리 후보
- 6.2 트래픽 증가 시 수평/수직 확장 전략


#### 7. 체크리스트


***

## 2-2. Workflow · 노드 · 데이터 런타임

### 3) `workflow-concepts-and-layers.md`

#### 1. 서론

- 1.1 워크플로우 개념의 중요성[^6][^1]


#### 2. 워크플로우 기본 개념

- 2.1 워크플로우 정의(Trigger → Nodes → Result)
- 2.2 워크플로우 vs 멀티에이전트 그래프(LangGraph StateGraph)


#### 3. 레이어 모델

- 3.1 Presentation Layer(에디터 UI)
- 3.2 Workflow Runtime Layer(엔진/스케줄러)
- 3.3 Nodes \& Connections Layer
- 3.4 Data Layer(아이템/JSON/상태)
- 3.5 Credentials Layer
- 3.6 Executions \& Debugging Layer[^7][^1]


#### 4. “미니앱 = 그래프(노드/엣지 + 상태)” 정의

- 4.1 미니앱 개념과 스코프
- 4.2 LangGraph의 상태 기반 그래프와의 대응[^2]


#### 5. 워크플로우 라이프사이클

- 5.1 생성·설정·테스트·배포·운영
- 5.2 버전 관리(변경 이력)


#### 6. 체크리스트


***

### 4) `node-basics.md`

#### 1. 서론

#### 2. 노드 타입 정의

- 2.1 트리거 노드(웹훅, 스케줄, 이벤트)[^1]
- 2.2 액션 노드(API/DB/이메일/AI 호출)
- 2.3 코어 로직 노드(IF, Switch, Merge, Split, Loop, Wait)[^8][^9]
- 2.4 서브그래프·에이전트 노드(LangGraph 서브그래프)[^2]


#### 3. 노드 인터페이스

- 3.1 입력 구조(입력 포트/스키마)
- 3.2 출력 구조(출력 포트/스키마)
- 3.3 설정 옵션(필수/선택)


#### 4. 노드 생명주기

- 4.1 생성(메타데이터·기본값)
- 4.2 설정(사용자 입력/검증)
- 4.3 실행(입력→처리→출력)
- 4.4 로깅(입출력/에러/메트릭)
- 4.5 버전 관리


#### 5. 노드 설계 원칙

- 5.1 단일 책임 원칙
- 5.2 순수 함수형 노드 vs 부작용 있는 노드 구분


#### 6. 체크리스트


***

### 5) `node-catalog.md`

#### 1. 서론

#### 2. 카탈로그 구조

- 2.1 카테고리(유저/워크스페이스, 통합, AI/RAG, 유틸리티 등)
- 2.2 노드 메타데이터(이름, 설명, 태그)


#### 3. 공통 정의 포맷

- 3.1 입력 스키마(필드, 타입, required)
- 3.2 출력 스키마
- 3.3 옵션(재시도, 타임아웃, 에러 정책)


#### 4. 카테고리별 노드 정의

- 4.1 유저·워크스페이스 관리 노드
- 4.2 통합(ESP/Slack/Stripe/CRM) 노드
- 4.3 AI·RAG 노드(OpenRouter LLM 호출, RAG Retriever, Relevance Checker 등)[^5][^10]
- 4.4 유틸리티 노드(Set/Transform/Filter/Merge 등)[^8]


#### 5. 노드 재사용·버전 전략

#### 6. 체크리스트


***

### 6) `connections-and-flow-control.md`

#### 1. 서론

#### 2. 연결(Connections) 기본 개념

- 2.1 노드 간 연결의 의미(데이터·제어 흐름)
- 2.2 단일/다중 연결, 순서


#### 3. 흐름 제어 패턴

- 3.1 직선형(Sequential)
- 3.2 병렬(Parallel)
- 3.3 브랜치(IF, Switch 기반)
- 3.4 합류(Merge/Join)[^1][^8]


#### 4. 순서·의존성·멱등성

- 4.1 의존 관계 모델링
- 4.2 멱등성 고려(재실행·재시도 시 문제 방지)


#### 5. LangGraph StateGraph 매핑

- 5.1 노드 함수 ↔ 워크플로우 노드 대응
- 5.2 엣지 조건 ↔ 브랜치/라우팅 로직 대응[^3][^2]


#### 6. 체크리스트


***

### 7) `data-model-in-workflows.md`

#### 1. 서론

#### 2. 데이터 구조

- 2.1 items[] 배열 기반 구조(n8n 스타일)[^7]
- 2.2 JSON 필드 구조, 멀티모달(텍스트+파일) 표현


#### 3. 데이터 변환 규칙

- 3.1 타입 변환(문자열↔숫자↔날짜 등)
- 3.2 구조화/정규화/플래트닝 패턴


#### 4. 데이터 검증·에러 처리

- 4.1 필수 필드·형식 검증
- 4.2 검증 실패 시 처리 정책(드롭/에러/보정)


#### 5. 타입 전략

- 5.1 스키마 정의·버전 관리
- 5.2 LangChain/LangGraph 쪽 타입 구조와의 정렬[^11][^2]


#### 6. 체크리스트


***

## 2-3. Credentials \& Secrets · 실행 \& 디버깅

### 8) `credentials-and-secrets.md`

#### 1. 서론

#### 2. 자격 증명 모델

- 2.1 API 키, OAuth, 서비스 계정 유형[^12]
- 2.2 워크스페이스/조직/사용자 범위 스코프


#### 3. 저장·암호화 전략

- 3.1 저장 위치(DB/전용 비밀 관리)
- 3.2 암호화·키 로테이션 정책[^13]


#### 4. 워크플로우에서의 참조 패턴

- 4.1 노드 설정에서의 Credential 참조 방식
- 4.2 최소 권한 원칙, 접근 제어


#### 5. 보안·감사

- 5.1 접근 로그·사용 이력
- 5.2 보안 사고 대응 플랜


#### 6. 체크리스트


***

### 9) `executions-and-logging.md`

#### 1. 서론

#### 2. 실행(run) 모델

- 2.1 실행 단위 정의(Workflow Execution)
- 2.2 상태(대기, 실행 중, 성공, 실패)[^1]


#### 3. 리트라이·멱등성

- 3.1 리트라이 정책(횟수, 백오프)
- 3.2 멱등성 키·중복 처리 전략


#### 4. 실행 로그 구조

- 4.1 노드별 입력/출력 저장 방식
- 4.2 에러·스택트레이스·메트릭(시간·비용) 저장


#### 5. 모니터링 뷰

- 5.1 실행 리스트 화면 요구사항
- 5.2 Drill-down(노드·타임라인) 요구사항[^1]


#### 6. 체크리스트


***

### 10) `debugging-and-data-pinning.md`

#### 1. 서론

#### 2. 디버깅 워크플로우

- 2.1 실패 실행 재현
- 2.2 부분 실행(특정 노드부터/까지 실행)


#### 3. 데이터 핀닝(Data Pinning)

- 3.1 개념·목적(개발용, 프로덕션 제외)[^4]
- 3.2 핀 가능한 데이터/불가(바이너리)
- 3.3 주의사항(실제 환경과 괴리, 과도한 핀)[^14]


#### 4. 모킹(Mock) 데이터 전략

- 4.1 외부 API 응답 모킹
- 4.2 RAG/LLM 응답 모킹


#### 5. 에러 패턴별 디버깅 레시피

- 5.1 JSON Parse Error
- 5.2 Expression/타입 오류
- 5.3 외부 API 타임아웃·Rate limit
- 5.4 LangGraph 에러(루프, GraphRecursionError 등)[^3]


#### 6. 체크리스트


***

## 2-4. LangChain + LangGraph · Prompt-to-Graph

### 11) `langchain-langgraph-integration.md`

#### 1. 서론

#### 2. 역할 분리 원칙

- 2.1 LangChain=컴포넌트(Chain/Tool/Retriever)[^5][^11]
- 2.2 LangGraph=오케스트레이션 런타임(StateGraph)[^3][^2]


#### 3. 통합 패턴

- 3.1 LangChain Retriever/Tool을 LangGraph 노드에서 호출
- 3.2 공통 LLM wrapper 사용(로그, 비용, 메트릭)


#### 4. 코드 구조 가이드

- 4.1 `llm/`, `rag/`, `agents/`, `graphs/` 패키지 구조 예
- 4.2 테스트 전략(체인 수준 vs 그래프 수준)


#### 5. 체크리스트


***

### 12) `prompt-to-graph-strategy.md`

#### 1. 서론

#### 2. Prompt-to-Graph(PTG) 개념

- 2.1 자연어 → 워크플로우 그래프 생성 목적
- 2.2 Opal/자체 PTG/다른 도구와의 비교[^15][^16]


#### 3. PTG 프로세스

- 3.1 요구사항 요약/정제
- 3.2 후보 노드/연결 계획 생성
- 3.3 그래프 구조 생성·검증
- 3.4 사용자 확인·수정 루프


#### 4. 그래프 품질 체크리스트

- 4.1 루프·종료 조건
- 4.2 에러 경로·fallback
- 4.3 자격 증명 사용·권한·보안
- 4.4 비용/성능 고려[^16][^17]


#### 5. PTG용 프롬프트 템플릿

- 5.1 “요구사항 → 노드 그래프 제안”
- 5.2 “그래프 리뷰·수정 요청”


#### 6. 체크리스트


***

이 구조를 그대로 `/02_arch_execution` 아래 `.md` 파일 헤더로 쓰면, 다음 단계에서는 각 섹션별로 **설명·표·예시 코드·프롬프트**만 채우면 됩니다.[^4][^2][^3][^1]

<div align="center">⁂</div>

[^1]: https://docs.n8n.io/workflows/

[^2]: https://www.langchain.com/langgraph

[^3]: https://www.swarnendu.de/blog/langgraph-best-practices/

[^4]: https://docs.n8n.io/data/data-pinning/

[^5]: https://peliqan.io/blog/langchain-vs-langgraph/

[^6]: https://deepwiki.com/n8n-io/n8n-docs/2.1-workflows-and-data-flow

[^7]: https://wikidocs.net/302246

[^8]: https://docs.n8n.io/workflows/components/nodes/

[^9]: https://wikidocs.net/310103

[^10]: https://wikidocs.net/267810

[^11]: https://www.freecodecamp.org/news/how-to-use-langchain-and-langgraph-a-beginners-guide-to-ai-workflows/

[^12]: https://docs.n8n.io/integrations/builtin/credentials/

[^13]: https://www.reco.ai/hub/secure-n8n-workflows

[^14]: https://docs.n8n.io/data/data-mocking/

[^15]: https://vibecoding.app/blog/how-vibe-coding-works

[^16]: https://github.com/langchain-ai/langgraph/issues/3365

[^17]: https://github.com/langchain-ai/langgraph/discussions/2090

